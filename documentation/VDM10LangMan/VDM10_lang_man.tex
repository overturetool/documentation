% Overture Language Manual
\documentclass{overturerepchap}
\usepackage{url}
\usepackage{graphics}
\usepackage{times}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{longtable} % ,multirow
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage{fancyhdr}

\newcommand{\nonstandard}[1]{}
\newcommand{\vdmtools}{VDMTools}
\newcommand{\vdmstyle}[1]{\texttt{#1}}
\newcounter{exerciseno}
\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newcounter{exerciseno}
\newcommand{\MYEQUIV}{$\equiv$}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  Operator Name & Semantics Description \\ \hline\hline \endhead}%
  {\hline\end{longtable}}

\newcommand\thebookexercise{\thechapter.\arabic{exerciseno}}
\newenvironment{myexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise}\enskip}{$\Box$\\
}
\newenvironment{myhardexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise $\star$}\enskip}{$\Box$\\
}
\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newenvironment{mysolution}{
%} %% This will be replaced by a perl script extracting the solutions
  %% and inserting them automatically into the solutions chapter.
\newcommand{\insertfig}[4]{ % Filename, epsheight, epswidth, caption,  label
\begin{figure}[htb]
\begin{center}
\includegraphics[width=#2]{#1}
\end{center}
\caption{{\em #3}} #4
\end{figure}
}

\newcommand{\insertfignw}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\includegraphics{#1}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\newcommand{\insertfignwrot}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\scalebox{1}%
{\rotatebox{270}{%
\includegraphics{#1}}}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

%\newcommand{\insertcommentedvdm*}[2]{}
  %% This macro is identified by perl script which will move the
  %% parameter to the solutions chapter.
% definition of VDM++, JavaCC, JJTree, JTB, ANTLR and SableCC for listings
\include{customlangdef}
% define the layout for listings
\lstdefinestyle{tool}{basicstyle=\ttfamily,
                         frame=trBL,
			 showstringspaces=false,
			 frameround=ffff,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
\lstdefinestyle{mystyle}{basicstyle=\ttfamily,
                         frame=trBL,
%                         numbers=left,
%			 gobble=0,
			 showstringspaces=false,
%			 linewidth=\textwidth,
			 frameround=fttt,
			 aboveskip=5mm,
			 belowskip=5mm,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
%\lstdefinestyle{mystyle}{basicstyle=\sffamily\small,
%			 frame=tb,
%                         numbers=left,
%			 gobble=0,
%			 showstringspaces=false,
%			 linewidth=345pt,
%			 frameround=ffff,
%			 framexleftmargin=8mm,
%			 framexrightmargin=8mm,
%			 framextopmargin=1mm,
%			 framexbottommargin=1mm,
%			 aboveskip=7mm,
%			 belowskip=5mm,
%			 xleftmargin=10mm,}

\lstset{style=mystyle}
\lstset{language=VDM++}
\lstset{alsolanguage=Java}
% The command below enables you to escape into normal LaTeX mode inside your 
% VDM chunks by starting with a `!��? character and ending with a `!��?
\lstset{escapeinside=!!}

%\newcommand{\kw}[1]{{\tt #1}}

%%%%%%%%%%%%%%%%%% Commands for bibtex %%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************
%                                                                       *
%       Bibliography and Terminology supporting commands                *
%                                                                       *
%************************************************************************

\newcommand{\bthisbibliography}[1]{\chapter*{References}%
   \begin {list} {}%
     {\settowidth {\labelwidth} {[#1]XX}%
      \setlength {\leftmargin} {\labelwidth}%
      \addtolength{\leftmargin} {\labelsep}%
      \setlength {\parsep} {1ex}%
      \setlength {\itemsep} {2ex}%
     }
  }
\newcommand{\ethisbibliography}{\end{list}}
\newcommand{\refitem}[2]
  {\bibitem[#1]{#2}}

% Requirements environment
\newenvironment{reqs}{%
\begin{enumerate}
%\renewcommand{\labelenumi}{\textbf{R\theenumi}}
\renewcommand{\theenumi}{\textbf{R\arabic{enumi}}}
}{%
\end{enumerate}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index

  \end{tabbing}\end{quote}
  }
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\bf\ttfamily #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt
    #1}\makebox[\kwlen][l]{{\bf\ttfamnily #1}}}
\newcommand{\keyw}[1]{{\bf\ttfamily #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{lstlisting}\input{#1}\end{lstlisting}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\keyw{map }#1\keyw{ to }#2}
\newcommand{\INMAP}[2]{\keyw{inmap }#1\keyw{ to }#2}
\newcommand{\SEQ}[1]{\keyw{seq of }#1}
\newcommand{\NSEQ}[1]{\keyw{seq1 of }#1}
\newcommand{\SET}[1]{\keyw{set of }#1}
\newcommand{\SETONE}[1]{\keyw{set1 of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{#1 $\To$ #2}
\newcommand{\FUN}[2]{#1 $\To$ #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}

\newcommand{\experience}[1]{%
\begin{center}
\fbox{
\begin{minipage}[t]{.8\textwidth}
#1
\end{minipage}}
\end{center}}


\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{VDM-10 Language Manual}
\fancyhead[RO,LE]{\resizebox{0.05\textwidth}{!}{\includegraphics{overture}}}
\fancyfoot[C]{\thepage}
\makeindex

\begin{document}

\title{VDM-10 Language Manual}
\author{Peter Gorm Larsen\\
        Kenneth Lausdahl\\
        Nick Battle\\
        John Fitzgerald\\
        Sune Wolff\\
        Shin Sahara\\
        Marcel Verhoef\\
        Peter W. V. Tran-J\o{}rgensen\\
        Tomohiro Oda\\
        Paul Chisholm}

\date{Feb 2018}
\reportno{TR-001}

\pagenumbering{roman}
\maketitle


{\textbf{Document history}}

\begin{tabular}{|l|l|l|l|l|}\hline
Month   & Year & Version & Version of Overture.exe & Comment \\ \hline
April   & 2010 &         & 0.2   & \\ \hline
May     & 2010 & 1       & 0.2   &  \\ \hline
February& 2011 & 2       & 1.0.0 &  \\ \hline
July    & 2012 & 3       & 1.2.2 & \\ \hline
April   & 2013 & 4       & 2.0.0 & \\ \hline
March & 2014 & 5 & 2.0.4 &
Includes RMs \#16, \#17, \#18, \#20 \\ \hline
November & 2014 & 6 & 2.1.2 &
Includes RMs \#25, \#26, \#29 \\ \hline
August & 2015 & 7 & 2.3.0 &
Includes RMs \#27 \\ \hline
April & 2016 & 8 & 2.3.4 & Review inputs from Paul Chisholm \\ \hline
September & 2016 & 9 & 2.4.0 & RMs \#35, \#36 \\ \hline
May & 2017 & 10 & 2.5.0 & RM \#39\\ \hline
Feb & 2018 & 11 & 2.6.0 & Includes RM \#42 \\ \hline
\end{tabular}

%\addtocounter{page}{2}
\tableofcontents
\newpage
\mbox{}
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Introduction}

The Vienna Development Method (VDM)
\cite{Bjorner&78,Jones90a,Fitzgerald&08c} was originally developed at
the IBM laboratories in Vienna in the 1970's and as such it is one of
the longest established formal methods.
This document is a common language manual for the three dialects for
VDM-SL, VDM++ and VDM-RT in the VDM-10 commonly agreed language
revision. These dialects  are supported by both VDMTools (minus VDM-RT)
\cite{Fitzgerald&08a} (in the appropriate version) as well as in the
Overture open source tool \cite{Larsen&10a} built on top of the
Eclipse platform. Whenever a construct is common to the three
different dialects the term ``VDM languages'' will be used. Whenever a
construct is specific to a subset of the VDM languages the specific
dialect term mentioned above will be mentioned explicitly.

\section{The VDM Specification Language (VDM-SL)}

The syntax and semantics of the VDM-SL
language is essentially the standard ISO/VDM-SL \cite{ISOVDM96}
with a modular extension\footnote{A few other extensions are also included.}.
Notice that all syntactically correct VDM-SL specifications are also correct in
 VDM-SL.
Even though we have tried to present the language in a
clear and understandable way the document is not a complete VDM-SL
reference manual.
For a more thorough presentation of the language we refer to the
existing literature\footnote{A more tutorial like
presentation is given in \cite{Fitzgerald&98b,Fitzgerald&09} whereas proofs in VDM-SL
are treated best in \cite{Jones90a} and \cite{Bicarregui&94}.}.
Wherever the  VDM-SL notation differs from
the VDM-SL standard notation the semantics will of course be carefully
explained.

\section{The VDM++ Language}

VDM++ is a formal specification language intended to specify object
oriented systems with parallel and real-time behaviour, typically in
technical environments~\cite{Fitzgerald&05}.  The language is based on
VDM-SL~\cite{ISOVDM96}, and has been extended with class and object
concepts, which are also present in languages like Smalltalk-80 and
Java.  This combination facilitates the development of object oriented
formal specifications.

\section{The VDM Real Time Language (VDM-RT)}

The VDM-RT language (formerly called VICE as an acronym for ``VDM++ In
Constrained Environments'') is used to appropriately model and analyse
Real-Time embedded and distributed
systems~\cite{Mukherjee&00,Verhoef&06b,Verhoef&07,Verhoef08,Larsen&09b}. Thus
VDM-RT is an extension of the VDM++ language.

\section{Purpose of The Document}

This document is the language reference manual for all the VDM-10 dialects.  The
syntax of VDM language constructs is defined using grammar rules.
The meaning of each language construct is explained in an informal
manner and some small examples are given. The description is supposed
to be suited for `looking up' information rather than for `sequential
reading'; it is a manual rather than a tutorial.  The reader is
expected be familiar with the concepts of object oriented
programming/design.

We will use the ASCII (also called the interchange)
concrete syntax but we will display all reserved words in a special
keyword font. Note that general Unicode identifiers are allowed so
it is for example possible to write Japanese characters directly.

\section{Structure of the Document}

Chapter~\ref{syntax-notation} presents the BNF notation used for the
description of syntactic constructs.  The VDM notations are described
in Chapter~\ref{typedef} to Chapter~\ref{chap:trace}.
%Section~\ref{diff} provides a complete list of the differences between
%ISO/VDM-SL and the VDM-10 notations while s
The complete syntax of the language is described in
Appendix~\ref{app-a}, the lexical specification in
Appendix~\ref{app-b} and the operator precedence in
Appendix~\ref{app-c}. Appendix~\ref{sec:diff} presents a list of the
differences between symbols in the mathematical syntax and the ASCII
concrete syntax.
%In Appendex~\ref{stdlib} details of the Standard
%libraries and how to use it are given. Finally, an index of the
%defining occurrences of all the syntax rules in the document is given.

\chapter{Concrete Syntax Notation}
\label{syntax-notation}


Wherever the syntax for parts of the language is presented in the
document it will be described in a BNF dialect. The BNF notation
used employs the following special symbols:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  the concatenate symbol \\
  = & the define symbol \\
  \dsepl & the definition separator symbol (alternatives)\\
  \OptPt{} & enclose optional syntactic items \\
  \SeqPt{} & enclose syntactic items which may occur zero or more times \\
  \Lit{ } & single quotes are used to enclose terminal symbols \\
    meta identifier & non-terminal symbols are written in lower-case letters
    (possibly including spaces) \\
  ;  & terminator symbol to denote the end of a rule \\
  (\ ) & used for grouping, e.g. ``a, (b\dsepl c)'' is equivalent to
    ``a, b\dsepl a, c''. \\
  -- & denotes subtraction from a set of terminal symbols
    (e.g. ``character -- (\Lit{\singleQuote})'' denotes all characters
    excepting the double quote character.)
\end{tabular}

\chapter{Data Type Definitions}
\label{typedef}

As in traditional programming languages it is possible to define data
types in the VDM languages and give them appropriate names.
Such an equation might look like:

\begin{lstlisting}
types

  Amount = nat
\end{lstlisting}

Here we have defined a data type with the name ``{\tt Amount}'' and
stated that the values which belong to this type are natural numbers
(\keyw{nat} is one of the basic types described below). One general
point about the type system of the VDM languages which is
worth mentioning at this point is that equality and inequality can be
used between any value. In programming languages it is often required
that the operands have the same type. Because of a
construct called a union type (described below) this is not the case
for the VDM languages.

In this chapter we will present the syntax of data type
definitions. In addition, we will show how values belonging to a type
can be constructed and manipulated (by means of built-in operators).
We will present the basic data types first and then we will proceed
with the compound types.

\section{Basic Data Types}

In the following a number of basic types will be presented. Each of
them will contain:

\begin{itemize}
\item Name of the construct.
\item Symbol for the construct.
\item Special values belonging to the data type.
\item Built-in operators for values belonging to the type.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.%
  \footnote{In these examples the Meta symbol `$\equiv$' will be used
    to indicate what the given example is equivalent to.}
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt a}, {\tt b}, {\tt x}, {\tt y}
etc.

The basic types are the types defined by the language with distinct
values that cannot be analysed into simpler values. There are five
fundamental basic types: booleans, numeric types,
characters, tokens and quote types. The basic types will be explained one by
one in the following.

\subsection{The Boolean Type}\label{bool}

In general the VDM languages allow one to specify systems in
which computations may fail to terminate or to deliver a result. To
deal with such potential undefinedness,
the VDM languages employ a three valued logic: values may be
true, false or bottom (undefined).
The semantics of the VDM interpreters differs from the ISO/VDM-SL standard
in that it does
not have an LPF (Logic of Partial Functions) three valued logic where
the order of the operands is
unimportant (see \cite{Jones90a}).  The \keyw{and} operator, the
\keyw{or} operator and the imply operator, though, have a conditional
semantics meaning that if the first operand is sufficient to determine
the final result, the second operand will not be evaluated. In a sense
the semantics of the logic in the VDM interpreter can still be considered
to be three-valued as for ISO/VDM-SL. However, bottom values may
either result in infinite computation or a run-time error in the
VDM interpreter.

\begin{description}
\item[Name:] \Index{Boolean}
\item[Symbol:] \Index{\keyw{bool}}
\item[Values:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[Operators:] Assume that {\tt a} and {\tt b} in the following
  denote arbitrary boolean expressions:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name       & Type                       \\ \hline
    {\tt \keyw{not} b}& Negation   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& Conjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& Disjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& Implication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& Biimplication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & Equality   & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& Inequality & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[Semantics of Operators:] Semantically {\tt <=>} and {\tt =} are
  equivalent when we deal with boolean values. There is a conditional
  semantics for \keyw{and}, \keyw{or} and {\tt=>}.

  We denote undefined terms (e.g. \ applying a map with a key outside
  its domain)  by $\perp$. The truth tables for the boolean operators
  are then%
  \footnote{Notice that in standard VDM-SL all these truth tables
  (except {\tt =>}) would be symmetric.}:

  \begin{tabular}{ll}
    Negation {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    Conjunction {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Disjunction {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Implication {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Biimplication {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}

\item[Examples:]
  Let {\tt a = \keyw{true}} and {\tt b = \keyw{false}} then:

  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsection{The Numeric Types}\label{numeric}

There are five basic numeric types: positive naturals, naturals,
integers, rationals and reals.  Except for three, all the
numerical operators can have mixed operands of the three types. The
exceptions are integer division, modulo and the remainder operation.

The five numeric types denote a subset hierarchy where \Index{\keyw{real}} is
the most general type followed by \Index{\keyw{rat}}\footnote{From the
VDM interpreter's point of view there is no
  difference between \keyw{real} and \keyw{rat} because only rational
  numbers can be represented in a computer.}, \Index{\keyw{int}},
\Index{\keyw{nat}} and \Index{\keyw{nat1}}. Note that no ``casting''
like it is done in many programming languages is needed in the VDM
languages.

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  Type & Values \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
This means that any number of type \keyw{int} is also automatically of type
\keyw{real} but not necessarily of type \keyw{nat}.  Another way to
illustrate this is to say that the positive natural numbers are a subset of
the natural numbers which again are a subset of the integers which again
are a subset of the rational numbers which finally are a subset of the real
numbers. The following table shows some numbers and their associated
type:

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  Number & Type \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
Note that all numbers are necessarily of type \keyw{real} (and
\keyw{rat}).

\begin{description}
\item[Names:] real, rational, integer, natural and positive natural
  numbers.
\item[Symbols:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[Values:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[Operators:] Assume in the following that {\tt x} and {\tt y} denote
  numeric expressions. No assumptions are made regarding their type.

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name & Type \\ \hline
    {\tt -x}& Unary minus & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& Absolute value & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& Floor  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& Sum    & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& Difference & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& Product  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& Division & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& Integer division & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& Remainder & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& Modulus   & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& Power & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& Less than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& Greater than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& Less or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& Greater or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& Equal  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& Not equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  The types stated for operands are the most general types allowed.  This
  means for instance that unary minus works for operands of all five types
  (\keyw{nat1}, \keyw{nat}, \keyw{int}, \keyw{rat} and \keyw{real}).

\input{sem-numtypes}

\item[Examples:] Let {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} then:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6
  \end{longtable}
\end{description}

\subsection{The Character Type}

The character type contains all the single character
elements of the VDM character set
(see Table~\ref{charSetTable} on page~\pageref{charSetTable}).

\begin{description}
\item[Name:] \Index{Char}
\item[Symbol:] \Index{\keyw{char}}
\item[Values:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[Operators:] Assume that {\tt c1} and {\tt c2} in the following denote arbitrary
  characters:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name      & Type \\ \hline
    {\tt c1 = c2}  & Equal     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & Not equal & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[Examples:] \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsection{The Quote Type}

The quote type corresponds to enumerated types in a programming
language like Pascal. However, instead of writing the different quote
literals between curly brackets in VDM it is done
by letting a quote type consist of a single quote literal and
then let them be a part of a union type.
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[Name:] \Index{Quote}
\item[Symbol:] e.g. {\tt <QuoteLit>}\index{\texttt{<>}!quote value}
\item[Values:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[Operators:] Assume that \texttt{q} and \texttt{r} in the
  following denote arbitrary quote values belonging to an enumerated
  type {\tt T}:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt q = r}  & Equal     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & Not equal & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[Examples:] Let \texttt{T} be the type defined as:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  If for example {\tt a = <France>}
  then:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsection{The Token Type}

The token type consists of a countably infinite set of distinct
values, called tokens. The only operations that can be carried out on
tokens are equality and inequality. In VDM,
tokens cannot be individually represented whereas they can be written
with a \keyw{mk\_token} around an arbitrary expression. This is a way
of enabling testing of specifications that contain token
types. However, in order to resemble the ISO/VDM-SL standard these token
values cannot be decomposed by means of any pattern matching and they
cannot be used for anything other than equality and inequality
comparisons.

\begin{description}
\item[Name:] \Index{Token}
\item[Symbol:] \Index{\keyw{token}}
\item[Values:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[Operators:] Assume that {\tt s} and {\tt  t} in the following denote arbitrary
  token values:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt s = t}  & Equal     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & Not equal & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[Examples:] Let for example {\tt s = \keyw{mk\_token}(6)},  let {\tt t
    = \keyw{mk\_token}(1)} and  {\tt u = mk\_token(\{1,2\})} in:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
    {\tt u = \keyw{mk\_token}(\{2,1\})} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\section{Compound Types}

In the following compound types will be presented. Each of
them will contain:
\begin{itemize}
\item The syntax for the compound type definition.
\item An equation illustrating how to use the construct.
\item Examples of how to construct values belonging to the type. In
  most cases there will also be given a forward reference to the
  section where the syntax of the basic constructor expressions is given.
\item Built-in operators for values belonging to the
  type\footnote{These operators are used in either unary or binary
    expressions which are given with all the operators in
    section~\ref{unandbin}.}.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt m}, {\tt m1}, {\tt s}, {\tt
  s1} etc.

\subsection{Set Types}
\label{sets}

A set is an unordered collection of values, all of the same
type\footnote{Note however that it is always possible to find a common
  type for two values by the use of a union type (see
  section~\ref{unions}.)}, which is treated as a whole. All sets in
VDM languages are finite, i.e.\ they contain only a finite
number of elements. The elements of a set type can be arbitrarily
complex, they could for example be sets themselves. Sets may include the
empty set (set0 type), or may require at least one element (set1 type).

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt S} is a set type, {\tt s}, {\tt s1}, {\tt s2} are set
values, {\tt ss} is a set of set values, {\tt e}, {\tt e1}, {\tt e2}
and {\tt en} are elements from the sets, {\tt bd1,} {\tt bd2}, \ldots,
{\tt bdm} are bindings of identifiers to sets or types, and {\tt P} is
a logical predicate.

\begin{description}
\item[Syntax:]
  \Rule{type}{
   \Ruleref{set type} \dsep
    \ldots
    }

  \Rule{set type}{\Ruleref{set0 type} \dsep
    \Ruleref{set1 type}
  }

  \Rule{set0 type}{\Lop{set of}, \Ruleref{type}}
  \Rule{set1 type}{\Lop{set1 of}, \Ruleref{type}}

\item[Equation:] {\tt S = \keyw{set of} A }\index{\keyw{set of}} or {\tt S = \keyw{set1 of} A}\index{\keyw{set1 of}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Set enumeration:] \verb|{e1, e2, ..., en}| constructs a set of the
    enumerated elements. The empty set is denoted by {\tt \{\}}.

  \item[Set comprehension:] \verb+{e | bd1, bd2, ..., bdm & P}+
    constructs a set by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}.
    A binding is either a set binding, a sequence binding, or a type
    binding\footnote{Notice that type bindings over infinite types (discharging the invariant limitations) cannot be executed by
      the VDM interpreters because in general
      they are not executable (see section~\ref{bind} for further
      information about this).}.  A set bind {\tt bdn} has the form
    {\tt pat1, \ldots, patp \keyw{in set} s}, where {\tt pati} is a
    pattern (normally simply an identifier), and {\tt s} is a set
    constructed by an expression. A sequence (or type) binding is similar, in the
    sense that \keyw{in set} is replaced by \keyw{in seq} (or a colon) and {\tt s} is
    replaced with a sequence (or type) expression.
  \end{description}
  The syntax and semantics for all set expressions are given in
  section~\ref{setexpr}.%
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt e \keyw{in set} s1} & Membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & Not membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& Union & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& Intersection & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& Difference & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& Subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & Proper subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& Equality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& Inequality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& Cardinality & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& Distributed union& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&Distributed intersection & \TO{\SETONE{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&Finite power set & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  Note that the types {\tt A, \SET{A}} and {\tt \SET{\SET{A}}} are only
  meant to illustrate the structure of the type. For instance it is
  possible to make
  a union between two arbitrary sets {\tt s1} and {\tt s2} and the type of
  the resultant set is the union type of the two set types. Examples
  of this will be given in section \ref{unions}.

\input{sem-settypes}

\item[Examples:]%
 Let {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}},
{\tt s2 = \{2, 4, 6, 8, 11\}} and {\tt s3 = \{\}} then:

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsection{Sequence Types}
\label{sequences}

A sequence value is an ordered collection of elements of some type
indexed by {\tt 1, 2, \ldots, n}; where {\tt n} is the length of the
sequence. A sequence type is the type of finite sequences of elements
of a type, either including the empty sequence (seq0 type) or
excluding it (seq1 type). The elements of a sequence type can be
arbitrarily complex; they could e.g.\ be sequences themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt L} is a sequence type, {\tt S} is a set type, {\tt l}, {\tt
  l1}, {\tt l2} are sequence values, {\tt ll} is a sequence of
sequence values.  {\tt e1}, {\tt e2} and {\tt en} are elements in
these sequences, {\tt i} will be a natural number, {\tt P} is a
predicate and {\tt e} is an arbitrary expression.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{seq type} \dsep
    \ldots
    }

  \Rule{seq type}{\Ruleref{seq0 type} \dsep
    \Ruleref{seq1 type}}

  \Rule{seq0 type}{\Lop{seq of}, \Ruleref{type}}

  \Rule{seq1 type}{\Lop{seq1 of}, \Ruleref{type}}
\item[Equation:] {\tt L = \keyw{seq of} A} or {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements.

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Sequence enumeration:] \verb+[e1, e2,..., en]+ constructs a
    sequence of the enumerated elements. The empty sequence is written
    as \verb+[]+.  A text literal is a shorthand for enumerating a sequence
    of characters (e.g.\ {\tt "ifad" = ['i','f','a','d']}).

  \item[Sequence comprehension:] 

    {\tt [e | id \keyw{in seq} S \& P]} constructs a sequence by
    evaluating the expression \texttt{e} on all the bindings for which
    the predicate \texttt{P} evaluates to \keyw{true}. The expression
    \texttt{e} will use the identifier \texttt{id}. \texttt{S} is a
    sequence of elements and \texttt{id} will be matched with the
    elements preserving the order of \texttt{S}.

{\tt [e | id \keyw{in set} S \& P]}
    constructs a sequence by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}. The
    expression {\tt e} will use the identifier {\tt id}. {\tt S} is a set
    of elements of a type with an order relation (section \ref{ord})  and {\tt id} will be matched to the elements from the set in increasing order.
  \end{description}
  The syntax and semantics of all sequence expressions are given in
  section~\ref{seqexpr}.%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}


\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt \keyw{hd} l} & Head & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & Tail & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & Length & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & Elements & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & Indexes & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt \keyw{reverse} l} & Reverse & \TO{\SEQ{A}}{\SEQ{A}}\\
    {\tt l1 \char'136\ l2} & Concatenation & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & Distributed concatenation & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & Sequence modification & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & Sequence application & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & Equality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & Inequality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\keyw{reverse}}\index{Reverse sequence}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


  The type {\tt A} is an arbitrary type and the operands for the
  concatenation and distributed concatenation operators do not have
  to be of the same ({\tt A}) type. The type of the resultant sequence
  will be the union type of the types of the operands. Examples will
  be given in section \ref{unions}.

\input{sem-seqtypes}

\item[Examples:] Let \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 =
    [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} then:

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{reverse} l1}  & $\equiv$ & \texttt{[2,9,5,1,4,1,3]} \\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2}
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2}
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)}
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsection{Map Types}\label{maps}

A map type from a type {\tt A} to a type {\tt B} is a type that
associates with each element of {\tt A} (or a subset of {\tt A}) an
element of {\tt B}.  A map value can be thought of as an unordered
collection of pairs.  The first element in each pair is called a key,
because it can be used as a key to get the second element (called the
information part) in that pair. All key elements in a map must therefore
be unique. The set of all key elements is called the domain of the map,
while the set of all information values is called the range of the map.
All maps in VDM languages are finite. The domain and range
elements of a map type can be arbitrarily complex, they could e.g. be
maps themselves.

A special kind of map is the injective map. An injective map is one
for which no element of the range is associated with more than one
element of the domain. For an injective map it is possible to invert
the map.

In the following this convention will be used: {\tt m}, {\tt m1} and {\tt
  m2} are maps from an arbitrary type {\tt A} to another arbitrary type
{\tt B}, {\tt ms} is a set of map values, {\tt a}, {\tt a1}, {\tt a2} and
{\tt an} are elements from {\tt A} while {\tt b}, {\tt b1}, {\tt b2} and
{\tt bn} are elements from {\tt B} and {\tt P} is a logic predicate. {\tt
  e1} and {\tt e2} are arbitrary expressions and {\tt s} is an arbitrary
set.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{map type} \dsep
    \ldots
    }

  \Rule{map type}{\Ruleref{general map type} \dsep
    \Ruleref{injective map type}}

  \Rule{general map type}{\Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

  \Rule{injective map type}{\Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

\item[Equation:] {\tt M = \keyw{map} A \keyw{to} B} or {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Map enumeration:] {\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    con\-structs a mapping of the enumerated maplets. The empty map is
    written as {\tt \{|->\}}.

  \item[Map comprehension:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}
    constructs a mapping by evaluating the expressions {\tt ed} and {\tt
      er} on all the possible bindings for which the predicate {\tt P}
    evaluates to \keyw{true}. {\tt bd1, \ldots, bdn} are bindings of
    free identifiers from the expressions {\tt ed} and {\tt er} to sets, sequences or types.
  \end{description}
  The syntax and semantics of all map expressions are given in
  section~\ref{mapexpr}.%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[Operators:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt \keyw{dom} m} & Domain & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & Range & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & Merge & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & Override & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & Distributed merge & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & Domain restrict to & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & Domain restrict by & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & Range restrict to & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & Range restrict by & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & Map apply & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & Map composition & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & Map iteration & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & Equality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & Inequality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & Map inverse & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\input{sem-maptypes}

\item[Examples:] Let

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  then:

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ &
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{5cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2,
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\

    \texttt{\keyw{merge}\{}
         \parbox[t]{6.5cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ &
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsection{Product Types}\label{tuples}

The values of a product type are called tuples. A tuple is a fixed
length list where the i'th element of the tuple must belong to the
i'th element of the product type.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{product type} \dsep
    \ldots
    }

  \Rule{product type}{
    \Ruleref{type}, \Lop{{\tt *}}, \Ruleref{type}, \SeqPt{\Lop{{\tt *}}, \Ruleref{type}}
    }

  A product type consists of at least two subtypes.

\item[Equation:] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!tuple type}

\item[Constructors:] The tuple constructor: {\tt \keyw{mk\_}(a1, a2,
    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}

    The syntax and semantics for the tuple constructor are given in
    section~\ref{tupexpr}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    \texttt{t.\#n}   & Select     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & Equality   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  The only operators working on tuples are component select, equality
  and inequality. Tuple components may be accessed using the select
  operator or by matching against a tuple pattern. Details of the
  semantics of the tuple select operator and an example of its use are
  given in section \ref{app-expr}.

\item[Examples:] Let {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} then:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{Composite Types}\label{records}

Composite types correspond to record types\index{record type} in programming languages.
Thus, elements of this type are somewhat similar to the tuples
described in the section about product types above. The difference
between the record type and the product type is that the different
components of a record can be directly selected by means of
corresponding selector functions. In addition records are tagged with
an identifier which must be used when manipulating the record. The
only way to tag a type is by defining it as a record. It is therefore
common usage to define records with only one field in order to give it
a tag. This is another difference to tuples as a tuple must have at
least two entries whereas records can be empty.

In VDM languages, \keyw{is\_} is a reserved prefix for names
and it is used in an {\it is expression}. This is a built-in operator
which is used to determine which record type a record value belongs to.
It is often used to discriminate between the subtypes of a union type
and will therefore be explained further in section~\ref{unions}. In
addition to record types the \keyw{is\_} operator can also determine if
a value is of one of the basic types.

In the following this convention will be used: {\tt A} is a record
type, {\tt A1, \ldots, Am} are arbitrary types, {\tt r}, {\tt r1}, and
{\tt r2} are record values, {\tt i1, \ldots, im} are selectors from
the {\tt r} record value (and these must be unique entrances inside one record definition), {\tt e1, \ldots, em} are arbitrary
expressions.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{composite type} \dsep
    \ldots
    }

  \Rule{composite type}{
    \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list},
    \Lop{end}
    }

  \Rule{field list}{\SeqPt{\Ruleref{field}}}

  \Rule{field}{\OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type}
  \dsep  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

  or the shorthand notation

  \Rule{composite type}{
    \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}}

  where identifier denotes both the type name and the tag name.

\item[Equation:]\mbox{}\label{a-type}
  \begin{lstlisting}
    A :: selfirst : A1
         selsec   : A2
  \end{lstlisting}%
\index{\texttt{::}}

  or

  \begin{lstlisting}
    A :: selfirst :  A1
         selsec   :- A2
  \end{lstlisting}%
\index{\texttt{:-}}

  or

  \begin{lstlisting}
    A :: A1 A2
  \end{lstlisting}

  In the second notation, an {\it equality abstraction\/} field
  \index{equality abstraction field} is
  used for the second field {\tt selsec}. The minus indicates that
  such a field is ignored when comparing records using the equality
  operator.  In the last notation the fields of {\tt A} can only be
  accessed by pattern matching (like it is done for tuples) as the
  fields have not been named.

 % In the last notation the fields of {\tt A} can only be accessed by
  %pattern matching (as is done for tuples) since the fields have not
  %been named.

  The shorthand notation {\tt ::} used in the two previous examples
   where the tag name equals the type
  name, is the notation most used.
  The more general \keyw{compose} notation is typically used if a
  composite type has to be specified directly as a component of a more
  complex type:
  \begin{lstlisting}
    T = map S to compose A of A1 A2 end
  \end{lstlisting}
  It should be noted however that composite types can only be used in
  type definitions, and not e.g.\ in signatures to functions or
  operations.

  Typically composite types are used as alternatives in a union type
  definition (see section~\ref{unions}) such as:

  \begin{lstlisting}
   MasterA = A | B | ...
  \end{lstlisting}
  where \texttt{A} and \texttt{B} are defined as composite types
  themselves. In this situation the \keyw{is\_} predicate can be used
  to distinguish the alternatives.

\item[Constructors:] The record constructor: {\tt \keyw{mk\_}A(a, b)} where
  {\tt a} belongs to the type {\tt A1} and {\tt b} belongs to the type {\tt
    A2}.

  The syntax and semantics for all record expressions are given in
  section~\ref{recexpr}.%
\index{\keyw{mk\_}!record constructor}

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt r.i} & Field select & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Is & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\input{sem-comtypes}

\item[Examples:] Let \texttt{Score} be defined as
\begin{lstlisting}
   Score :: team   : Team
            won    : nat
            drawn  : nat
            lost   : nat
            points : nat;
   Team = <Brazil> | <France> | ...
\end{lstlisting}
\label{scoredef}
and let

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} and \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}.
\end{tabular}

\noindent%
Then

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}
  \end{tabular}

  The equality abstraction field, written using `{\tt :-}' instead of
  `{\tt :}', may be useful, for example, when working with lower level
  models of an abstract syntax of a programming language. For example,
  one may wish to add a position information field to a type of
  identifiers without affecting the true identity of identifiers:

\begin{lstlisting}
  Id :: name :  seq of char
        pos  :- nat
\end{lstlisting}

The effect of this will be that the {\tt pos} field is
ignored in equality comparisons, e.g.\
the following would evaluate to true:

\begin{lstlisting}
  mk_Id("x",7) = mk_Id("x",9)
\end{lstlisting}

In particular this can be useful when looking up in an environment
which is typically modelled as a map of the following form:

\begin{lstlisting}
  Env = map Id to Val
\end{lstlisting}

Such a map will contain at most one index for a specific identifier,
and a map lookup will be independent of the {\tt pos} field.

Moreover, the equality abstraction field will affect set expressions.
For example,
\begin{lstlisting}
  {mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)}
\end{lstlisting}

will be equal to

\begin{lstlisting}
  {mk_Id("x",?),mk_Id("y",8)}
\end{lstlisting}

where the question mark stands for 7 or 9.

Finally, note that for equality abstraction fields valid patterns are
limited to don't care and identifier patterns. Since equality
abstraction fields are ignored when comparing two values, it does not
make sense to use more complicated patterns.
\end{description}

\subsection{Union and Optional Types}\label{unions}

The union type corresponds to a set-theoretic union, i.e.\ the type
defined by means of a union type will contain all the elements from
each of the components of the union type. It is possible to use types
that are not disjoint in the union type, even though such usage
would be bad practice.  However, the union type is normally used when
something belongs to one type from a set of possible types.  The
types which constitute the union type are often composite types.  This
makes it possible, using the \keyw{is\_} operator, to decide which of
these types a given value of the union type belongs to.

The optional type {\tt [T]} is a kind of shorthand for a union type {\tt T |
  \keyw{nil}}, where \keyw{nil} is used to denote the absence of a
value. However, it is not possible to use the set {\tt \{\keyw{nil}\}}
as a type so the only types \keyw{nil} will belong to will be optional
types.


\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{union type} \dsep
    \Ruleref{optional type} \dsep
    \ldots
    }

  \Rule{union type}{
    \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
    }

  \Rule{optional type}{\Lit{[}, \Ruleref{type}, \Lit{]}}

\item[Equation:] {\tt B = A1 | A2 | \ldots\ | [An]}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[Constructors:] None.

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[Examples:] In this example {\tt Expr} is a union type whereas
  {\tt Const}, {\tt Var}, {\tt Infix} and {\tt Cond} are composite
  types defined using the shorthand {\tt ::} notation.

\begin{lstlisting}
  Expr  = Const | Var | Infix | Cond;
  Const :: nat | bool;
  Var   :: id:Id
           tp: [<Bool> | <Nat>];
  Infix :: Expr * Op * Expr;
  Cond  :: test : Expr
           cons : Expr
           altn : Expr
\end{lstlisting}
\label{exprdef}
  and let {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} then:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
    {\tt expr.altn.tp} =} {\tt \keyw{nil} &$\equiv$& \keyw{true}\\
  \end{tabular}

  Using union types we can extend the use of previously defined
    operators. For instance, interpreting \texttt{=} as a test over
    \texttt{\keyw{bool} | \keyw{nat}} we have

 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  Similarly we can take use union types for taking unions of sets and
    concatenating sequences:

  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ &
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

  In the set union, we take the union over sets of type
    \texttt{\keyw{nat} | \keyw{bool}}; for the sequence concatenation
    we are manipulating sequences of type \texttt{\keyw{char} | <c> |
    <d>}.
\end{description}

\subsection{The Object Reference Type (VDM++ and VDM-RT)}

The object reference type has been added as part of the standard
VDM-SL\ types. Therefore there is no direct way of restricting the use
of object reference types (and thus of objects) in a way that conforms
to pure object oriented principles; no additional structuring
mechanisms than classes are foreseen. From these principles it follows
that the use of an object reference type in combination with a type
constructor (record, map, set, etc.) should be treated with caution.

A value of the object reference type can be regarded as a {\em
reference} to an object.  If, for example, an instance variable (see
section \ref{sec:ivars}) is defined to be of this type, this makes the
class in which that instance variable is defined, a `client' of the
class in the object reference type; a {\em clientship relation} is
established between the two classes.

An object reference type is denoted by a class name.  The class name
in the object reference type must be the name of a class defined in
the specification.

The only operators defined for values of this type is the test for
equality (\Lit{=}) and inequality (\Lit{<>}). Equality is based on references rather than
values. That is, if \texttt{o1} and \texttt{o2} are two distinct
objects which happen to have the same contents, \texttt{o1 = o2} will
yield false.

\begin{description}
\item[Constructors] Object references are constructed using the new
expression (see section \ref{sec:creation}).

\item[Operators]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}

\item[Examples]
An example of the use of object references is in the definition of the
class of binary trees:
\begin{lstlisting}
class Tree

types

  protected tree = <Empty> | node;

  public node :: lt   : Tree
                 nval : int
                 rt   : Tree

instance variables

  protected root: tree := <Empty>;
end Tree
\end{lstlisting}
\label{TreeDef}

Here we define the type of nodes, which consist of a node value, and
references to left and right tree objects.
Details of access specifiers may be found in section
\ref{ch:interface}.
\end{description}

\subsection{Function Types}

In the VDM languages function types can also be used in type
definitions.  A function type from a type {\tt A} (actually a list of
types as a tuple type) to a type {\tt B} is a type that associates with each element
of {\tt A} an element of {\tt B}. A function value can be thought of
as a function in a programming language which has no side-effects
(i.e.\ it does not use any global variables).

Such usage can be considered advanced in the sense
that functions are used as values (thus this section
may be skipped during the first reading). Function values may be created by
lambda expressions (see below), or by function definitions, which are
described in section~\ref{functiondef}.  Function values can be of
higher order in the sense that they can take functions as arguments or
return functions as results. In this way functions can be Curried such
that a new function is returned when the first set of parameters are
supplied (see the examples below).

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{partial function type} \dsep
    \ldots
    }

  \Rule{function type}{
    \Ruleref{partial function type} \dsep
    \Ruleref{total function type}
    }

  \Rule{partial function type}{
    \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}}

  \Rule{total function type}{
    \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}}

  \Rule{discretionary type}{\Ruleref{type} \dsepl \Lit{(},\Lit{)}}

\item[Equation:] {\tt F = A +> B}\footnote{Note that the total
function arrow can only be used in signatures of totally defined
functions and thus not in a type definition.} or {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[Constructors:] In addition to the traditional function
  definitions the only way to construct functions is by the lambda
  expression: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
  where the {\tt patj} are patterns, the {\tt Tj} are type expressions, and
  {\tt body} is the body expression which may use the pattern
  identifiers from all the patterns.

  The syntax and semantics for the lambda expression are given in
  section~\ref{lambda}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt f(a1,\ldots,an)} & Function apply & \TO{A1 * $\cdots$ * An}{B} \\
    {\tt f1 \keyw{comp} f2}& Function composition & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & Function iteration & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}

  Note that equality and inequality between type values should be used
  with great care. In the VDM languages this corresponds to the
  mathematical equality (and inequality) which is not computable for
  infinite values like general functions. Thus, in the
  VDM interpreters the
  equality is on the abstract syntax of the function value (see {\tt
    inc1} and {\tt inc2} below).

\input{sem-functypes}

\item[Examples:] Let the following function values be defined:
  \begin{lstlisting}
    f1 = lambda x : nat & lambda y : nat & x + y
    f2 = lambda x : nat & x + 2
    inc1 = lambda x : nat & x + 1
    inc2 = lambda y : nat & y + 1
  \end{lstlisting}
  then the following holds:

  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}

  Notice that the equality test does not yield the expected result with
  respect to the semantics of the VDM languages. Thus, one should
  be {\bf very} careful with the usage of equality for infinite values
  like functions.
\end{description}

\section{Invariants}

If the data types specified by means of equations as described above
contain values which should not be allowed, then it is possible to restrict
the values in a type by means of an invariant. The result is that the type
is restricted to a subset of its original values. Thus, by means of a
predicate the acceptable values of the defined type are limited to those
where this expression is true.

The general scheme for using invariants looks like this:

\begin{lstlisting}
  Id = Type
  inv pat == expr
\end{lstlisting}

\noindent where {\tt pat} is a pattern matching the values belonging to the type
{\tt Id}, and {\tt expr} is a truth-valued expression, involving some or
all of the identifiers from the pattern {\tt pat}.

If an invariant is defined, a new (total) function is implicitly
created with the signature:
\begin{lstlisting}
  inv_Id : Type +> bool
\end{lstlisting}
This function can be used within other invariant, function or operation
definitions.

For instance, recall the record type \texttt{Score} defined on page
\pageref{scoredef}. We can ensure that the number of points awarded
is consistent with the number of games won and drawn using an invariant:
\begin{lstlisting}
  Score :: team   : Team
           won    : nat
           drawn  : nat
           lost   : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}
The invariant function implicitly created for this type is:
\begin{lstlisting}
  inv_Score : Score +> bool
  inv_Score (sc) ==
    sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}

Note that where the {\tt compose} form is used to define a composite type with an invariant, a distinction must be drawn. Consider:
\begin{lstlisting}
Range = compose Rng of low:nat high:nat end
  inv mk_Rng(l, h) == l <= h;
\end{lstlisting}
This defines two types, {\tt Range} and {\tt Rng}, where {\tt Rng} is a pair of natural numbers with no constraint, while {\tt Range} is structurally the same as {\tt Rng} but must additionally satisfy the invariant.
For example, the following definitions are valid
\begin{lstlisting}
r:Range = mk_Rng(1, 2);
r2:Rng = mk_Rng(2, 1);
r3 = mk_Rng(2, 1);
\end{lstlisting}
{\tt r2} and {\tt r3} need not satisfy the invariant (in the absence of explicit declaration, {\tt r3} is of type {\tt Rng}).
On the other hand,
\begin{lstlisting}
r4:Range = mk_Rng(2, 1);
\end{lstlisting}
is invalid since {\tt r4} of type {\tt Range} violates the invariant.

\section{Equality}\label{eq}
Every type defined in VDM, both basic and compound types, is provided with an equality relation by default as described earlier.
The primitive equality is not always that which is desired.
If the values of a data type are normalised then structural equality is adequate, but this is not always the case.
Consider for example a data type that represents times and includes time zones.
The same point in time is represented differently in different time zones.
A type definition allows an equality relation to be defined explicitly for a type.
In such a case the explicit equality relation is employed when comparing values of the type in preference to the primitive equality.
The general scheme for defining an equality relation is:
\begin{lstlisting}
Id = Type
  eq pat1 = pat2 == expr
\end{lstlisting}
or
\begin{lstlisting}
Id :: fields
  eq pat1 = pat2 == expr
\end{lstlisting}
{\tt pat1} and {\tt pat2} are patterns for two values of the type (or composite type), and {\tt expr} is a boolean expression that is true exactly when the expressions represented by {\tt pat1} and {\tt pat2} are equal.

When defined, the explicit equality relation is also employed for inequality comparison with {\tt <>}.
If an \keyw{eq} clause is defined, a new (total) function is created implicitly with the signature:
\begin{lstlisting}
eq_T : T * T +> bool
\end{lstlisting}
such that {\tt eq\_T(t1,t2)} denotes the same value as {\tt t1 = t2}.

\begin{description}
\item[Examples:]Flight matching
\begin{lstlisting}
Flight :: id         : seq1 of char
          departure  : seq1 of char
          depTime    : DateTime
          destination: seq1 of char
  eq mk_Flight(i1,d1,dt1,a1) = mk_Flight(i2,d2,dt2,a2) ==
       i1 = i2 and d1 = d2 and a1 = a2 and 
       within(dt1, dt2, mk_Minute(10));
\end{lstlisting}

A simplified definition of a flight consisting of an identifier, departure location, departure date/time, and destination location. Two records refer to the same flight if they have the same identifier, same departure location, same destination location, and a departure time within 10 minutes of each other; it is the last item that renders structural equality inadequate.\footnote{We assume a type {\tt DateTime}, a type {\tt Minute}, and a function {\tt within}.}
Given
\begin{lstlisting}
f1 = mk_Flight("QF5", "YSSY", '17-04-01 12:20', "WSSS")
f2 = mk_Flight("QF5", "YSSY", '17-04-01 12:28', "WSSS")
f3 = mk_Flight("VOZ42", "YSSY", '16-12-25 02:21', "YBBN")
f4 = mk_Flight("VOZ42", "YSSY", '16-12-24 02:21', "YBBN")
f5 = mk_Flight("VOZ42", "YSSY", '16-12-24 02:21', "YMML")
\end{lstlisting}
We have

\begin{tabular}{l l}
{\tt f1 = f2} & $\equiv$  \keyw{true} \\
{\tt f3 = f4} & $\equiv$  \keyw{false} \\
{\tt f1 = f3} & $\equiv$  \keyw{false} \\
{\tt f2 <> f4} & $\equiv$  \keyw{true} \\
{\tt eq\_Flight(f4, f5)} & $\equiv$  \keyw{false}\\ 
\end{tabular}

A proof obligation is a condition that needs to be satisfied to verify a specification is consistent.
Whenever an equality relation is defined, the proof obligation requires the relation to be an equivalence relation; that is, it is reflexive, symmetric and transitive\footnote{\url{https://en.wikipedia.org/wiki/Equivalence_relation} gives a quick introduction to equivalence relation.}.
For a type {\tt T} we have:
\begin{description}
\item Reflexive:
\begin{lstlisting}
forall x:T & x = x
\end{lstlisting}
\item Symmetric:
\begin{lstlisting}
forall x,y:T & x = y => y = x
\end{lstlisting}
\item Transitive:
\begin{lstlisting}
forall x,y,z:T & x = y and y = z => x = z
\end{lstlisting}
\end{description}

The equality relation employed when evaluating an expression depends on the type that is determined for the expression statically; i.e. when type checking occurs, not during expression evaluation. 
Consider the type definition
\begin{lstlisting}
NATPAIR = nat * nat
eq e1 = e2 == e1.#1 = e2.#1;
\end{lstlisting}
and the value definitions
\begin{lstlisting}
x1:NATPAIR = mk_(1,2);
x2:NATPAIR = mk_(1,3);
x3         = mk_(1,2);
x4         = mk_(1,3);
\end{lstlisting}
The following expressions all evaluate to true.

\begin{tabular}{l c l}
{\tt x1} & {\tt=} & {\tt x2}\\
{\tt x1} & {\tt =} & {\tt mk\_(1,42)}\\
{\tt x1} & {\tt <>} & {\tt mk\_(2,2)}\\
{\tt  x1} & {\tt =} & {\tt x3}\\
{\tt x1} & {\tt =} & {\tt x4} \\
{\tt x3} & {\tt <>} & {\tt x4} \\
{\tt x3} & {\tt =} & {\tt mk\_(1,2)}\\
\end{tabular}

Note for example {\tt x1 = x2} because statically they are of type {\tt NATPAIR} whose equality relation states they are equal if their first elements are equal. 
On the other hand {\tt x3 <> x4} because statically they are of type {\tt  \keyw{nat} *  \keyw{nat}} whose implicit equality requires both the first and second elements to be equal.
{\tt x1 = x4} is true because statically {\tt x4} is interpreted as type {\tt NATPAIR} due to the explicit declaration of {\tt x1:NATPAIR}.
\end{description}

\section{Order}\label{ord}
Numeric types (section \ref{numeric}) have a primitive order relation.
An order relation can be defined explicitly for other types as part of the type definition.
The general scheme for defining an order (strict less than) relation is:
\begin{lstlisting}
Id = Type
  ord pat1 < pat2 == expr
\end{lstlisting}
or
\begin{lstlisting}
Id :: fields
  ord pat1 < pat2 == expr
\end{lstlisting}
{\tt pat1} and {\tt pat2} are patterns for two values of the type (or composite type), and {\tt expr} is a boolean expression that is true exactly when the expression represented by {\tt pat1} is less than the expression represented by {\tt pat2} in the required order relation.

If an \keyw{ord} clause is defined, three new functions are created implicitly with the signatures:
\begin{lstlisting}
ord_T : T * T +> bool
max_T : T * T +> T
min_T : T * T +> T
\end{lstlisting}
         such that

\begin{tabular}{l l}
{\tt ord\_T(t1,t2)} & $\equiv$ {\tt t1 < t2} \\
{\tt max\_T(t1,t2)} & $\equiv$ {\tt  \keyw{if} ord\_T(t1,t2)  \keyw{or} t1 = t2  \keyw{then} t2  \keyw{else} t1}\\
{\tt min\_T(t1, t2)} & $\equiv$ {\tt  \keyw{if} ord\_T(t1, t2)  \keyw{or} t1 = t2  \keyw{then} t1  \keyw{else} t2}\\
\end{tabular}

If an  \keyw{ord} clause is defined for a type, then the infix operators {\tt <}, {\tt <=}, {\tt >} and {\tt >=} can be employed with expressions of that type.

The equality relation for a type is defined (either explicitly or implicitly), and if the order relation for a type is also defined (explicitly), we have

\begin{tabular}{l l }
{\tt x <= y} & {\tt <=> x < y  \keyw{or} x = y} \\
{\tt x > y} & {\tt <=>  \keyw{not} (x = y  \keyw{or} x < y)} \\
{\tt x >= y} & {\tt <=>  x = y  \keyw{or}  \keyw{not} x < y}\\
\end{tabular}

The proof obligation for an order relation is that it be a strict partial order; that is, it is irreflexive and transitive\footnote{\url{https://en.wikipedia.org/wiki/Partially_ordered_set} gives a quick introduction to ordering relation.}.
\begin{description}
\item Irreflexive:
\begin{lstlisting}
forall x:T & not x < x 
\end{lstlisting}
\item Transitive:
\begin{lstlisting}
forall x,y,z:T & x < y and y < z => x < z
\end{lstlisting}

The conditions relating {\tt <}, {\tt <=}, {\tt >} and {\tt >=} stated above are only guaranteed to hold for an order relation that satisfies the proof obligation. 
Note a strict partial order must be asymmetric
\begin{lstlisting}
forall x,y:T & x < y => not y < x
\end{lstlisting}
However, asymmetry is derivable from irreflexivity and transitivity.
\end{description}

\begin{description}
\item [Example:] Score revisited
\begin{lstlisting}
Score :: team   : Team
         won    : nat
         drawn  : nat
         lost   : nat
         points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn
  ord mk_Score(t1,w1,-,-,p1) < mk_Score(t2,w2,-,-,p2) ==
    p1 < p2 or
    p1 = p2 and w1 < w2 or
    p1 = p2 and w1 = w2 and t1 < t2;
\end{lstlisting}
         
In this case the order is as might be presented in a league table (with greatest element at top):
\begin{itemize}
\item Most points first;
\item If equal on points, most wins first;
\item Otherwise alphabetic ordering of team name (not defined here).
\end{itemize}

Given
\begin{lstlisting}
sc1 = mk_Score (<France>, 2, 2, 0, 8);
sc2 = mk_Score (<Scotland>, 3, 0, 0, 9);
sc3 = mk_Score (<SouthAfrica>, 0, 3, 0, 3);
sc4 = mk_Score (<SaudiArabia>, 1, 0, 2, 3);
\end{lstlisting}
We have

\begin{tabular}{l l}
{\tt sc1 < sc2} & $\equiv$  \keyw{true}\\
{\tt sc1 <= sc3} & $\equiv$  \keyw{false}\\
{\tt sc2 > sc3} & $\equiv$  \keyw{true}\\
{\tt sc4 >= sc3} & $\equiv$  \keyw{true}\\
{\tt sc4 < sc3} & $\equiv$  \keyw{false}\\
{\tt ord\_Score(sc1, sc2)} & $\equiv$  \keyw{true}\\
\end{tabular}

The type argument of a polymorphic function can depend on an order relation.
For example, the following specifies a function that determines if a sequence is ordered:
\begin{lstlisting}
ascending[@a]: seq of @a -> bool
ascending(s) ==
  forall i in set {1,...,len s - 1} & s(i) <= s(i+1);
\end{lstlisting}

The specification compares for order values of the type argument {\tt @a}. There is no way to express that {\tt @a} admits an order relation so the function is partial. 
A type error would be thrown at runtime if the function was executed with a type that does not admit an order relation (such as  \keyw{bool}).
\end{description}

\chapter{Algorithm Definitions}
\label{algorithm}


In the VDM languages algorithms can be defined by both
functions and operations.  However, they do not directly correspond to
functions in traditional programming languages. What separates
functions from operations in the VDM languages is the use of
local and global variables. Operations can manipulate both the global
variables and any local variables.  Both
local and global variables will be described later. Functions are pure in
the sense that they cannot access global variables and they are not
allowed to define local variables. Thus, functions are purely
applicative while operations are imperative.

Functions and operations can be defined both explicitly (by means of
an explicit algorithm definition) or implicitly (by means of a
pre-condition and/or a post condition).  An explicit algorithm
definition for a function is called an expression while for an
operation it is called a statement.  A pre-condition is a truth-valued
expression which specifies what must hold before the
function/operation is evaluated. A pre-condition can only refer to
parameter values and global variables (if it is an operation).  A
post-condition is also a truth valued expression which specifies what
must hold after the function/operation is evaluated. A post-condition
can refer to the result identifier, the parameter values, the current
values of global variables and the old values of global variables. The
old values of global variables are the values of the variables as they
were before the operation was evaluated.  Only operations can refer to
the old values of global variables in a post-condition as functions
are not allowed access to the global variables in any way.

However, in order to be able to execute both functions and operations
by the VDM interpreters they must be defined explicitly\footnote{Implicitly
specified functions and operations cannot in general be executed
because their post-condition does not need to directly relate the
output to the input. Often it is done by specifying the properties the
output must satisfy.}. In the VDM languages it is also
possible for explicit function and operation definitions to specify an
additional pre- and a post-condition.  In the post-condition of
explicit function and operation definitions the result value must be
referred to by the reserved word \keyw{RESULT}.

\chapter{Function Definitions}\label{functiondef}

In the VDM languages we can define first order and higher order
functions. A higher order function is either a Curried function (a
function that returns a function as result), or a function that takes
functions as arguments. Furthermore, both first order and higher order
functions can be polymorphic.

In VDM++ and VDM-RT functions are automatically available in a static
form (i.e.\ without having an instance of the defining class). Thus
there is no need to use the {\bf\ttfamily static} keyword that can be
used for operations in VDM++ and VDM-RT. Functions are executed
atomically - which is consistent with them being able to read instance
variables of objects passed, and there being no sync clauses (see
Chapter \ref{ch:sync}) for functions. In general, the syntax for the
definition of a function is:

\Rule{function definitions}{
  \Lop{functions},
  \OptPt{\Ruleref{access function definition}, \lfeed
         \SeqPt{\Lit{;}},
         \Ruleref{access function definition}%
         \Ruleref{function definition},
         \OptPt{\Lit{;}}}
  }

\Rule{access function definition}{
    \OptPt{\Ruleref{access}},
      \Ruleref{function definition}
  }

\Rule{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }

\Rule{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }

\Rule{explicit function definition}{
  \Ruleref{identifier},
\lfeed
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \Lit{$==$}, \lfeed
  \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{measure body}}
  }

\Rule{implicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},\lfeed
  \Ruleref{parameter types}, \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
}

\Rule{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types},\lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{measure body}}
}

\Rule{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Rule{identifier type pair list}{
  \Ruleref{identifier type pair}, \SeqPt{\Lit{,}, \Ruleref{identifier type pair}}
}

\Rule{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Rule{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Rule{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Rule{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Rule{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{(},\Lit{)}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern},\SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{function body}{
  \Ruleref{expression} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!functions}
  }

\Rule{measure body}{
  \Ruleref{expression} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  }

Here \keyw{is not yet specified} may be used as the function body
during development of a model; whereas the \keyw{is subclass
  responsibility} indicates that implementation of this body must be
undertaken by any subclasses so that can only be used in VDM++ and
VDM-RT.

A simple example of an explicit function definition is the function
\texttt{map\_inter} which takes two compatible maps over natural
numbers and returns those maplets common to both
\begin{lstlisting}
map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
map_inter (m1,m2) ==
  (dom m1 inter dom m2) <: m1
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
\end{lstlisting}
Note that we could also use the optional post condition to allow
assertions about the result of the function:
\begin{lstlisting}
map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
map_inter (m1,m2) ==
  (dom m1 inter dom m2) <: m1
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom RESULT = dom m1 inter dom m2
\end{lstlisting}

The same function can also be defined implicitly:
\begin{lstlisting}
map_inter2 (m1,m2: map nat to nat) m: map nat to nat
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom m = dom m1 inter dom m2 and
     forall d in set dom m & m(d) = m1(d);
\end{lstlisting}
\noindent Note that implicitly functions are considered total. Thus if they are exported in VDM-SL they need to be exported using the total function type.
 
A simple example of an extended explicit function definition
is the function \texttt{map\_disj} which takes a pair of
compatible maps over natural numbers and returns the map consisting of
those maplets unique to one or other of the given maps:

\begin{lstlisting}
map_disj (m1:map nat to nat,m2:map nat to nat)
          res : map nat to nat ==
  (dom m1 inter dom m2) <-: m1 munion
  (dom m1 inter dom m2) <-: m2
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom res = (dom m1 union dom m2) \ (dom m1 inter dom m2)
     and
     forall d in set dom res & res(d) = m1(d) or res(d) = m2(d)
\end{lstlisting}
\label{mapdisj}

(Note here that an attempt to interpret the post-condition could
potentially result in a run-time error since \texttt{m1(d)} and
\texttt{m2(d)} need not both be defined simultaneously.)

The functions {\tt map\_inter} and {\tt map\_disj} can be evaluated by the
VDM interpreters, but the implicit function {\tt map\_inter2} cannot be evaluated.
However, in all three cases the pre- and post-conditions can be used
in other functions; for instance from the definition of
\texttt{map\_inter2} we get functions \texttt{\keyw{pre\_}map\_inter2}
and \texttt{\keyw{post\_}map\_inter2} with the following signatures:

\begin{lstlisting}
  pre_map_inter2 : (map nat to nat) * (map nat to nat) +> bool
  post_map_inter2 : (map nat to nat) * (map nat to nat) *
                   (map nat to nat) +> bool
\end{lstlisting}
These kinds of functions are automatically created by the VDM
interpreters and they can be used in other definitions (this technique
is called quoting). In general, for a function \texttt{f} with
signature
\begin{lstlisting}
  f : T1 * ... * Tn -> Tr
\end{lstlisting}
defining a pre-condition for the function causes creation of a
function \texttt{\keyw{pre\_}f} with signature
\begin{lstlisting}
  pre_f : T1 * ... * Tn +> bool
\end{lstlisting}
and defining a post-condition for the function causes creation of a
function \texttt{\keyw{post\_}f} with signature
\begin{lstlisting}
  post_f : T1 * ... * Tn * Tr +> bool
\end{lstlisting}

Functions can be defined using recursion (i.e. by calling themselves). When recursion is used one is recommended to add a `\keyw{measure}' clause that can be used in the proof obligations generated from the model such that termination proofs can be carried out. A measure clause has one of two forms:

\begin{enumerate}
  \item The identifier of a function whose argument type is that of the function being defined and result type is \keyw{nat}.
  \item  An expression of type \keyw{nat} that may include free instances of the argument variables in the function definition.
\end{enumerate}

A slightly more general form is described later.

Consider the definition of the factorial function:

\begin{lstlisting}
fac: nat +> nat
fac(n) ==
    if n = 0
    then 1
    else n*fac(n-1);
\end{lstlisting}

A \keyw{measure} clause (of the first type) could be added by appending

\begin{lstlisting}
measure id
\end{lstlisting}

where

\begin{lstlisting}
id: nat +> nat
id(n) == n;
\end{lstlisting}

giving

\begin{lstlisting}
fac: nat +> nat
fac(n) ==
    if n = 0
    then 1
    else n*fac(n-1)
measure id;
\end{lstlisting}

The proof obligation becomes

\begin{lstlisting}
forall n:nat &
  (not (n=0) =>
    id(n) > id(n-1));
\end{lstlisting}

Verifying the proof obligation ensures the recursive function will terminate; the value of the measure function is smaller on each recursive call, and being of type \keyw{nat} the value cannot go below 0.

The second form of measure clause employs an expression of type \keyw{nat}

\begin{lstlisting}
measure n
\end{lstlisting}

Note in this case the {\tt n} in the measure clause is the argument variable {\tt n} in the definition of {\tt fac}. The full definition is

\begin{lstlisting}
fac: nat +> nat
fac(n) ==
    if n = 0
    then 1
    else n*fac(n-1)
measure n;
\end{lstlisting}

An example on sequences

\begin{lstlisting}
dupe[@a]: seq of @a +> seq of @a
dupe(s) == cases s:
             []  -> [],
             [x] -> [x,x],
             t^u -> dupe t ^ dupe u
           end
measure len s;
\end{lstlisting}

As before the {\tt s} in the measure clause is the argument variable in the definition of {\tt dupe}. The measure function reduces because the semantics of concatenation patterns ensure that the sequence {\tt s} is split into {\tt t} and {\tt u} such that {\tt t} and {\tt u} contain at least one element each.

A measure clause is recommended for recursive functions, but not mandatory. VDM implementations typically issue a warning if a recursive function is defined without a measure clause. If one explicitly does not want to provide a measure clause and avoid a warning the \keyw{is not yet specified} expression can be used.

\begin{lstlisting}
fac: nat +> nat
fac(n) ==
    if n = 0
    then 1
    else n*fac(n-1)
measure is not yet specified;
\end{lstlisting}

In some situations a measure clause that evaluates to a single \keyw{nat} is not adequate. More generally a measure clause can be a function that returns a \keyw{nat} product, or an expression whose type is a \keyw{nat} product. Consider the Ackermann function

\begin{lstlisting}
ackermann: nat * nat +> nat
ackermann(m,n) == cases mk_(m,n):
                    mk_(0,q) -> q+1,
                    mk_(p,0) -> ackermann(p-1,1),
                    mk_(p,q) -> ackermann(p-1,ackermann(p,q-1))
                  end; 
\end{lstlisting}

Note that in the recursive calls either the first or the second argument reduces, but not both. The measure clause is

\begin{lstlisting}
measure mk_(m,n)
\end{lstlisting}

Order is lexicographic ordering on the \keyw{nat} tuple: in each recursive call either the first argument reduces, or the first argument is unchanged and the second argument reduces. Generally an arbitrary tuple can be expressed as the value in a measure clause.

\section{Polymorphic Functions}

Functions can also be polymorphic in VDM. This means that we can create
generic functions that can be used on values of several different
types. For this purpose type parameters (or type variables which are
written like normal identifiers prefixed with a {\tt @} sign) are
used. Consider the polymorphic function to create an empty
bag:\footnote{The examples for polymorphic functions are taken from
\cite{Dawes91}. Bags are modelled as maps from the elements to their
multiplicity in the bag. The multiplicity is at least 1, i.e.\ a
non-element is not part of the map, rather than being mapped to 0.}
\begin{lstlisting}
empty_bag[@elem] : () +> (map @elem to nat1)
empty_bag() ==
  { |-> }
\end{lstlisting}
Before we can use the above function, we have to instantiate the
function {\tt empty\_bag} with a type, for example integers (see also
section~\ref{app-expr}):
\begin{lstlisting}
emptyInt = empty_bag[int]
\end{lstlisting}
Now we can use the function {\tt emptyInt} to create a new bag to store
integers. More examples of polymorphic functions are:
\begin{lstlisting}
num_bag[@elem] : @elem * (map @elem to nat1) +> nat
num_bag(e, m) ==
  if e in set dom m
  then m(e)
  else 0;

plus_bag[@elem] : @elem * (map @elem to nat1) +>
                  (map @elem to nat1)
plus_bag(e, m) ==
  m ++ { e |-> num_bag[@elem](e, m) + 1 }
\end{lstlisting}
If pre- and or post-conditions are defined for polymorphic functions, the
corresponding predicate functions are also polymorphic. For instance
if \texttt{num\_bag} was defined as
\begin{lstlisting}
  num_bag[@elem] : @elem * (map @elem to nat1) +> nat
  num_bag(e, m) ==
    m(e)
  pre e in set dom m
\end{lstlisting}
then the pre-condition function would be
\begin{lstlisting}
  pre_num_bag[@elem] :@elem * (map @elem to nat1) +> bool
\end{lstlisting}

\noindent Finally, VDM makes no assumptions about the type bound to a type parameter. This binding must be made explicitly, either by making an assertion as part of the pre-condition of the function, or by making a test before the part of the function body that restricts the type parameter. For example, consider the function given below:

\begin{lstlisting}
public f[@T]: seq of @T -> seq of @T
f(s) ==
  if is_(s, seq of real) then
  	[r + 1 | r in seq s]
  else
  	reverse s;
\end{lstlisting}

Here the type parameter \texttt{@T} denotes the element type of the sequence \texttt{s} passed to the function. Note how the body of the function assumes the type parameter to be defined for the \texttt{+} operator. This only works since the \texttt{\textbf{if}}-clause explicitly states that the parameter \texttt{s} is of type \texttt{\textbf{seq of real}}. Without the \texttt{\textbf{if}}-clause use of the \texttt{+} operator would fail due to \texttt{@T} not being of a numeric type. Alternatively, the assumption could be stated using a pre-condition e.g.\ using {\texttt{\keyw{is\_real}}. This puts a restriction on the type parameter that applies to the entire body of the function, though with simple examples like this the effect is the same as explicitly declaring the type of the parameter in the function signature.

Polymorphic functions can also be recursive and in those cases it also makes sense to include a measure function. For example:

\begin{lstlisting}
dlen[@A]: seq of seq of @A -> nat
dlen(l) ==
  if l = []
  then 0
  else len hd l + dlen[@A](tl l)
measure Len;

Len[@A]: seq of seq of @A -> nat
Len(l) == len l;
\end{lstlisting}
\noindent where a proof obligation ensuring termination of this recursive function as:

\begin{lstlisting}
(forall l:seq of (seq of (@A)) & ((not (l = [])) => 
(Len[@A](l) > Len[@A](tl l))))
\end{lstlisting}

\section{Higher Order Functions}

Functions are allowed to receive other functions as arguments. A
simple example of this is the function \texttt{nat\_filter} which
takes a sequence of natural numbers, and a predicate, and returns the
subsequence that satisfies this predicate:
\begin{lstlisting}
  nat_filter : (nat -> bool) * seq of nat -> seq of nat
  nat_filter (p,ns) ==
    [n | n in seq ns & p(n)];
\end{lstlisting}
Then
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
In fact, this algorithm is not specific to natural numbers, so we may
define a polymorphic version of this function:
\begin{lstlisting}
  filter[@elem]: (@elem -> bool) * seq of @elem -> seq of @elem
  filter (p,l) ==
    [i | i in seq l & p(i)];
\end{lstlisting}
\label{filterdef}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.

\vspace{1ex}
Functions may also return functions as results. An example of this is
the function \texttt{fmap}:
\begin{lstlisting}
  fmap[@elem]: (@elem -> @elem) -> seq of @elem -> seq of @elem
  fmap (f)(l) ==
    if l = []
    then []
    else [f(hd l)] ^ (fmap[@elem] (f)(tl l));
\end{lstlisting}
So \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$
\texttt{[ 1,4,9,16,25 ]}.

\vspace{1ex}
\noindent Since the \texttt{fmap} function is recursive, it ought to have a \keyw{measure}
function defined. In the case of curried functions, the measure function's parameters
are the same as a de-curried version of the recursive function's parameters. For
the \texttt{fmap} example, this would be:
\begin{lstlisting}
  m[@elem]: (@elem -> @elem) * seq of @elem -> nat
  m(-, l) == len l;
\end{lstlisting}
Note that the measure function is also polymorphic, and must have the same type
parameters as the function it measures. The proof obligation will also be polymorphic:
\begin{lstlisting}
(forall f:(@elem -> @elem), l:seq of (@elem) &
  (not (l = []) =>
    m[@elem](f, l) > m[@elem](f, (tl l))))
\end{lstlisting}

\chapter{Expressions}\label{chap:expr}

In this chapter we will describe the different kinds of expressions
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\section{Let Expressions}\label{let-exp}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \Ruleref{let expression} \dsep
    \Ruleref{let be expression} \dsep
    \ldots
    }

  \Rule{let expression}{
    \Lop{let},
    \Ruleref{local definition}
    \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{expression}
    }

  \Rule{let be expression}{
    \Lop{let}, \Ruleref{multiple bind},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
    \Ruleref{expression}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep
    \Ruleref{function definition}
    }

  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  \noindent where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] A simple {\it let expression} has the form:
  \begin{lstlisting}
    let p1 = e1, ..., pn = en in e
  \end{lstlisting}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding pattern {\tt pi}, and
  {\tt e} is an expression, of any type, involving the pattern
  identifiers of {\tt p1, \ldots, pn}. It denotes the value of the
  expression {\tt e} in the context in which the patterns {\tt p1,
    \ldots, pn} are matched against the corresponding expressions {\tt
    e1, \ldots, en}.

  More advanced let expressions can also be made by using local
  function definitions. The semantics of doing so is simply that the
  scope of such locally defined functions is restricted to the body of
  the let expression.

  In standard VDM-SL\ the collection of definitions may be mutually
  recursive.  However, in the VDM languages this is not
  supported by the VDM interpreters.  Furthermore, the definitions must be
  ordered such that all constructs are defined before they are used.

  A {\it let-be-such-that expression} has the form:
  \begin{lstlisting}
    let mb be st e1 in e2
  \end{lstlisting}%
  where {\tt mb} is a multi-binding of one or more patterns (mostly
  just one pattern)
 to a set value (or a sequence or a type),
  {\tt e1} is a boolean expression, and {\tt e2} is an expression, of
  any type, involving the pattern identifiers of the patterns from {\tt
    mb}. The {\tt \keyw{be st} e1} part is optional. The expression
  denotes the value of the expression {\tt e2} in the context in which
  all the patterns from {\tt mb} have been matched against either an element
  in the set from {\tt mb}, or an element in the sequence from {\tt mb}, or against a value from the type in {\tt mb}%
  \footnote{Remember that only the set and sequence bindings can be executed by
    means of the VDM interpreters.}.
  If the {\tt \keyw{st} e1} expression is present, only such bindings
  where {\tt e1} evaluates to true in the matching context are used.

\item[Examples:] {\it Let expressions} are useful for improving
  readability especially by contracting complicated expressions used
  more than once. For instance, we can improve the function
  \texttt{map\_disj} from page \pageref{mapdisj}:
\begin{lstlisting}
map_disj : (map nat to nat) * (map nat to nat) ->
            map nat to nat
map_disj (m1,m2) ==
  let inter_dom = dom m1 inter dom m2
  in
    inter_dom <-: m1 munion inter_dom <-: m2
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
\end{lstlisting}
  They are also convenient for decomposing complex
  structures into their components. For instance, using the previously
  defined record type \texttt{Score} (see page \pageref{scoredef}) we can
  test whether one score is greater than another:
  \begin{lstlisting}
    let mk_Score(-,w1,-,-,p1) = sc1,
        mk_Score(-,w2,-,-,p2) = sc2
    in (p1 > p2) or (p1 = p2 and w1 > w2)
  \end{lstlisting}
  In this
  particular example we extract the second and fifth components of the
  two scores. Note that don't care
  patterns (see page \pageref{patterns}) are used to indicate that the
  remaining components are irrelevant
  for the processing done in the body of this expression.

  {\it Let-be-such-that expressions} are useful for abstracting away
  the non-essential choice of an element from a set, in particular in
  formulating recursive definitions over sets. An example of this is a
  version of the sequence filter function (see page \pageref{filterdef})
  over sets:\label{setfilterdef}
  \begin{lstlisting}
set_filter[@elem] : (@elem -> bool) -> (set of @elem) ->
                    (set of @elem)
set_filter(p)(s) ==
  if s = {}
  then {}
  else let x in set s
       in (if p(x) then {x} else {}) union
         set_filter[@elem](p)(s \ {x});
   \end{lstlisting}
   We could alternatively have defined this function using a set
  comprehension (described in section \ref{setexpr}):
  \begin{lstlisting}
    set_filter[@elem] : (@elem -> bool) -> (set of @elem) ->
                        (set of @elem)
    set_filter(p)(s) ==
      { x | x in set s & p(x)};
  \end{lstlisting}

   The last example shows how the optional ``be such that'' part
   (\keyw{be st}) can be used. This part is especially useful when it
   is known that an element with some property exists but an explicit
   expression for such an element is not known or difficult to
  write. For instance we can exploit this expression to write a
  selection sort algorithm:
   \begin{lstlisting}
   remove : nat * seq of nat -> seq of nat
   remove (x,l) ==
     let i in set inds l be st l(i) = x
     in
       l(1,...,i-1) ^ l(i+1,...,len l)
   pre x in set elems l;

   selection_sort : seq of nat -> seq of nat
   selection_sort (l) ==
     if l = []
     then []
     else let m in seq l be st
              forall x in seq l & m <= x
          in
            [m] ^ (selection_sort (remove(m,l)))
   \end{lstlisting}
\label{selectionSortdef}
   Here the first function removes a given element from the given
   list; the second function repeatedly removes the least element in
   the unsorted portion of the list, and places it at the head of the
   sorted portion of the list.
\end{description}

\section{The Define Expression} \label{define-exp}

This expression can only be used inside operations which will be
described in section~\ref{op-def}. In order to deal with global variables
inside the expression part an extra expression construct is available
inside operations.

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{def expression} \dsep
    \ldots
    }

\Rule{def expression}{
  \Lop{def},
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\item[Semantics:] A {\it define expression} has the form:
  \begin{lstlisting}
    def pb1 = e1;
        ...
        pbn = en
    in
      e
  \end{lstlisting}
  The {\it define expression} corresponds to a let expression except
  that the right hand side expressions may depend on the value of the
  local and/or
  global variable and that it may not be mutually recursive.
  It denotes the value of the expression {\tt e} in the
  context in which the patterns (or binds) {\tt pb1, \ldots, pbn} are
  matched against the corresponding expressions {\tt e1, \ldots,
    en}\footnote{If binds are used, it simply means that the values
    which can match the pattern are further constrained by the type, sequence, or
    set expression as explained in Chapter~\ref{patterns}.}.

\item[Examples:] The {\it define expression} is
  used in a pragmatic way, in order to make the reader aware of the fact that
  the value of the expression depends upon the global variable.

  This can be illustrated by a small example:
  \begin{lstlisting}
    def user = lib(copy)
    in
      if user = <OUT>
      then true
      else false
  \end{lstlisting}
  where {\tt copy} is defined in the context, {\tt lib} is global
  variable (thus {\tt lib(copy)} can be considered as looking up the
  contents of a part of the variable).

  The operation \texttt{GroupRunnerUp\_expl} in section \ref{letstmt}
  also gives an example of a define expression.
\end{description}

\section{Unary and Binary Expressions}\label{unandbin}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{unary expression} \dsep \Ruleref{binary expression} \dsep \ldots
    }

\Rule{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Rule{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

  \Rule{unary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsepl \Lop{reverse} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge}
    }

\Rule{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

  \Rule{binary expression}{
    \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}}

  \Rule{binary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[Semantics:] Unary and binary expressions are a combination of
  operands and operators denoting a value of a specific type. The
  signature of all these operators is already given in
  Chapter~\ref{typedef}, so no further explanation will be provided
  here. The map inverse unary operator is treated separately because
  it is written with postfix notation in the mathematical syntax.

\item[Examples:] Examples using these operators were given in
  Chapter~\ref{typedef}, so none will be provided here.
\end{description}

\section{Conditional Expressions}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{if expression} \dsep \Ruleref{cases expression} \dsep \ldots
    }

  \Rule{if expression}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
    \SeqPt{\Ruleref{elseif expression}}, \Lop{else}, \Ruleref{expression}
    }

  \Rule{elseif expression}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
    }

  \Rule{cases expression}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases expression alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
    }

  \Rule{cases expression alternatives}{
    \Ruleref{cases expression alternative},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
    }

  \Rule{cases expression alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
    }

  \Rule{others expression}{
    \Lop{others}, \Lit{->}, \Ruleref{expression}
    }

\item[Semantics:] {\it If expressions} and {\it cases expressions}
  allow the choice of one from a number of expressions on the basis of
  the value of a particular expression.

  The {\it if expression} has the form:
  \begin{lstlisting}
    if e1
    then e2
    else e3
  \end{lstlisting}
  where {\tt e1} is a boolean expression, while {\tt e2} and {\tt e3}
  are expressions of any type. The if expression denotes the value of
  {\tt e2} evaluated in the given context if {\tt e1} evaluates to
  true in the given context. Otherwise the if expression denotes the
  value of {\tt e3} evaluated in the given context. The use of an
  \keyw{elseif} expression is simply a shorthand for a nested if then
  else expression in the \keyw{else} part of the expression.

  The {\it cases expression} has the form
  \begin{lstlisting}
    cases e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      others             -> emplus1
    end
  \end{lstlisting}
  where {\tt e} is an expression of any type, all {\tt pij}'s are patterns
  which are matched one by one against the expression {\tt e}.  The {\tt
    ei}'s are expressions of any type, and the keyword \keyw{others} and
  the corresponding expression {\tt emplus1} are optional. The cases
  expression denotes the value of the {\tt ei} expression evaluated in the
  context in which one of the {\tt pij} patterns has been matched against
  {\tt e}. The chosen {\tt ei} is the first entry where it has been
  possible to match the expression {\tt e} against one of the patterns. If
  none of the patterns match {\tt e} an \keyw{others} clause must be
  present, and then the cases expression denotes the value of {\tt emplus1}
  evaluated in the given context.

\item[Examples:] The if expression in the VDM languages
  corresponds to what is used in most programming languages, while the
  cases expression in the VDM languages is more general than
  most programming languages. This is shown by the fact that real
  pattern matching is taking place, but also because the patterns do not
  have to be constants as in most programming languages.

  An example of the use of conditional expressions is provided by the
  specification of the mergesort algorithm:
  \begin{lstlisting}
  lmerge : seq of nat * seq of nat -> seq of nat
  lmerge (s1,s2) ==
    if s1 = []
    then s2
    elseif s2 = []
    then s1
    elseif (hd s1) < (hd s2)
    then [hd s1] ^ (lmerge (tl s1, s2))
    else [hd s2] ^ (lmerge (s1, tl s2));

  mergesort : seq of nat -> seq of nat
  mergesort (l) ==
    cases l:
      []      -> [],
      [x]     -> [x],
      l1 ^ l2 -> lmerge (mergesort(l1), mergesort(l2))
    end
  \end{lstlisting}
The pattern matching provided by cases expressions is useful for
  manipulating members of type unions. For instance, using the type
  definition \texttt{Expr} from page \pageref{exprdef} we have:
  \begin{lstlisting}
print_Expr : Expr -> seq1 of char
print_Expr (e) ==
  cases e:
    mk_Const(-) -> "Const of" ^ (print_Const(e)),
    mk_Var(id,-) -> "Var of" ^ id,
    mk_Infix(mk_(e1,op,e2)) -> "Infix of" ^ print_Expr(e1)^","
                                    ^ print_Op(op) ^ ","
                                    ^ print_Expr(e2),
    mk_Cond(t,c,a) -> "Cond of" ^ print_Expr(t) ^ ","
                               ^ print_Expr(c) ^ ","
                               ^ print_Expr(a)
  end;

print_Const : Const -> seq1 of char
print_Const(mk_Const(c)) ==
  if is_nat(c)
  then "nat"
  else -- must be bool
       "bool";
  \end{lstlisting}
\label{printExprDef}
  The function \texttt{print\_Op} would be defined similarly.
\end{description}

\section{Quantified Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{quantified expression}
    \dsep \ldots
    }

  \Rule{quantified expression}{
    \Ruleref{all expression} \dsep
    \Ruleref{exists expression} \dsep
    \Ruleref{exists unique expression}
    }

  \Rule{all expression}{
    \Lop{forall}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{exists expression}{
      \Lop{exists}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{exists unique expression}{
    \Lop{exists1}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] There are three forms of quantified expressions:
  {\it universal} (written as \keyw{forall}), {\it existential} (written
  as \keyw{exists}), and {\it unique existential} (written as
  \keyw{exists1}). Each yields a boolean value \keyw{true} or \keyw{false}, as
  explained in the following.

  The {\it universal quantification} has the form:
  \begin{lstlisting}
    forall mbd1, mbd2, !\ldots!, mbdn & e
  \end{lstlisting}
  where each {\tt mbdi} is a multiple bind {\tt pi \keyw{in set} s}, { \tt pi \keyw{in seq} s}, or
  if it is a type bind {\tt pi : type}, and {\tt e} is a boolean
  expression involving the pattern identifiers of the {\tt mbdi}'s. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of every choice of bindings from {\tt mbd1, mbd2, \ldots,
    mbdn} and \keyw{false} otherwise.

  The {\it existential quantification} has the form:
  \begin{lstlisting}
    exists mbd1, mbd2, !\ldots!, mbdn & e
  \end{lstlisting}
  where the {\tt mbdi}'s and the {\tt e} are as for a universal
  quantification. It has the value \keyw{true} if {\tt e} is \keyw{true} when
  evaluated in the context of at least one choice of bindings from
  {\tt mbd1, mbd2, \ldots, mbdn}, and \keyw{false} otherwise.

  The {\it unique existential quantification} has the form:
  \begin{lstlisting}
    exists1 bd & e
  \end{lstlisting}
  where {\tt bd} is either a set bind, a sequence bind, or a type bind and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of exactly one choice of bindings, and \keyw{false} otherwise.

  All quantified expressions have the lowest possible precedence. This
  means that the longest possible constituent expression is taken. The
  expression is continued to the right as far as it is syntactically
  possible.


\item[Examples:]
  An example of an existential quantification is given in the function
  shown below, \texttt{QualificationOk}. This function, taken from the
  specification of a nuclear tracking system in \cite{Fitzgerald&98},
  checks whether a set of experts has a required qualification.
  \begin{lstlisting}
  types

  ExpertId = token;
  Expert :: expertid : ExpertId
            quali : set of Qualification
  inv ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: set of Expert * Qualification -> bool
  QualificationOK(exs,reqquali) ==
    exists ex in set exs & reqquali in set ex.quali
  \end{lstlisting}
  The function \texttt{min} gives us an example of a universal
  quantification:
  \begin{lstlisting}
  min(s: set of nat) x: nat
  pre s <> {}
  post forall y in set s & x <= y
  \end{lstlisting}
  We can use unique existential quantification to state the functional
  property satisfied by all maps \texttt{m}:
  \begin{lstlisting}
  forall d in set dom m &
    exists1 r in set rng m & m(d) = r
  \end{lstlisting}


\end{description}

\section{The Iota Expression}\label{iotaexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{iota expression} \dsep
    \ldots
    }

  \Rule{iota expression}{
    \Lop{iota}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] An {\it iota expression} has the form:
  \begin{lstlisting}
    iota bd & e
  \end{lstlisting}
  where {\tt bd} is either a set bind, a sequence bind, or a type bind, and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}.
  The \keyw{iota} operator can only be used if a unique value exists
  which matches the bind and makes the body expression {\tt e} yield
  \keyw{true} (i.e.\ {\tt \keyw{exists1} bd \& e} must be \keyw{true}). The
  semantics of the iota expression is such that it returns the unique
  value which satisfies the body expression ({\tt e}).

\item[Examples:]
  Using the values \texttt{sc1,...,sc4} defined by
  \begin{lstlisting}
    sc1 = mk_Score (<France>, 3, 0, 0, 9);
    sc2 = mk_Score (<Denmark>, 1, 1, 1, 4);
    sc3 = mk_Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = mk_Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{lstlisting}
  we have

  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \&
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \&
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent Notice that the last example cannot be executed and that
  the last two expressions are undefined - in the former case because
  there is more than value satisfying the expression, and in the
  latter because no value satisfies the expression.
\end{description}

\section{Set Expressions}\label{setexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{set enumeration} \dsep \Ruleref{set comprehension} \dsep
    \Ruleref{set range expression} \dsep \ldots
    }

  \Rule{set enumeration}{
    \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
    }

  \Rule{expression list}{
    \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
    }

  \Rule{set comprehension}{
    \Lit{\{}, \Ruleref{expression}, \Lit{$|$}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

  \Rule{set range expression}{
    \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{\}}
    }

\item[Semantics:] A {\it Set enumeration} has the form:
  \begin{lstlisting}
    {e1, e2, e3, !\ldots!, en}
  \end{lstlisting}
  where {\tt e1} up to {\tt en} are general expressions. It constructs
  a set of the values of the enumerated expressions. The empty set
  is written as \verb+{}+.

  The {\it set comprehension} expression has the form:
  \begin{lstlisting}
    {e | mbd1, mbd2, !\ldots!, mbdn & P}
  \end{lstlisting}
  It constructs a set by evaluating the expression {\tt e} on all the
  bindings for which the predicate {\tt P} evaluates to \keyw{true}. A
  multiple binding can contain set bindings, sequence bindings, and type bindings.
  Thus {\tt mbdn} will look like {\tt pat1 \keyw{in set} s1, pat2 : tp1, pat3 \keyw{in seq} q1,
    \ldots \keyw{in set} s2}, where {\tt pati} is a pattern (normally
  simply an identifier), {\tt s1} and {\tt s2} are sets
  constructed by expressions, and {\tt q1} is a sequence constructed by an expression (whereas {\tt tp1} is used to illustrate
  that type binds can also be used). Notice however that type binds
  can only be executed by the VDM interpreters in case the types can
  be statically declared as finite.

  The {\it set range expression} is a special case of a set
  comprehension. It has the form
  \begin{lstlisting}
    {e1, !\ldots!, e2}
  \end{lstlisting}
  where {\tt e1} and {\tt e2} are numeric expressions. The set range
  expression denotes the set of integers from {\tt e1} to {\tt e2}
  inclusive. If {\tt e2} is smaller than {\tt e1} the set range
  expression denotes the empty set.

\item[Examples:]
  Using  the values \texttt{Europe=\{<France>,<England>,<Denmark>,%
  <Spain>\}} and \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (where
  \texttt{sc1,...,sc4} are as defined in the preceding example) we have

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{8cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{8cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\section{Sequence Expressions} \label{seqexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{sequence enumeration} \dsep \Ruleref{sequence comprehension} \dsep
    \Ruleref{subsequence} \dsep \ldots
    }

  \Rule{sequence enumeration}{
    \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
    }

  \Rule{sequence comprehension}{
    \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{]}
    }

  \Rule{subsequence}{
    \Ruleref{expression}, \lfeed
    \Lit{(}, \Ruleref{expression},
    \Lit{,}, \Lit{\Range},
    \Lit{,},
    \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] A {\it sequence enumeration} has the form:
  \begin{lstlisting}
    [e1, e2, !\ldots!, en]
  \end{lstlisting}
  where {\tt e1} through {\tt en} are general expressions. It constructs a
  sequence of the enumerated elements. The empty sequence is written
  as {\tt []}.

  A {\it sequence comprehension} over sequences has the form:
  \begin{lstlisting}
    [e | pat in seq S & P]
  \end{lstlisting}
  where the expression \texttt{e} will use the identifiers from the
  pattern \texttt{pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one
  pattern identifier must be present in the pattern). \texttt{S} is a
  sequence of values. It constructs a sequence by evaluating the
  expression \texttt{e} on all the bindings for which the predicate
  \texttt{P} evaluates to true, preserving the order of elements in
  \texttt{S}.

  A {\it sequence comprehension} over sets has the form:
  \begin{lstlisting}
    [e | pat in set S & P]
  \end{lstlisting}
  where the expression {\tt e} will use the identifiers from the
  pattern {\tt pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one pattern
  identifier must be present in the pattern). {\tt S} is
  a set of values.  The bindings of the
  pattern identifier must be to a type that admits an order relation, which dictates
  the ordering of the elements in
  the resulting sequence. It constructs a sequence by evaluating the
  expression {\tt e} on all the (ordered) bindings for which the predicate {\tt P}
  evaluates to \keyw{true}.
Note it is not the result sequence that is ordered, but the sequence of values of the pattern identifier.

  A {\it subsequence} of a sequence {\tt l} is a sequence formed from
  consecutive elements of {\tt l}; from index {\tt n1} up to and including
  index {\tt n2}. It has the form:
  \begin{lstlisting}
    l(n1, ..., n2)
  \end{lstlisting}
  where {\tt n1} and {\tt n2} are positive integer expressions.
  If the lower bound {\tt n1} is smaller than
  1 (the first index in a non-empty sequence) the subsequence
  expression will start from the first element of the sequence.
  If the upper bound {\tt n2} is larger
  than the length of the sequence (the largest index which can be used
  for a non-empty sequence) the subsequence expression will end at the
  last element of the sequence.

%  A {\it sequence modifier} has the form:
%  \begin{lstlisting}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{lstlisting}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[Examples:] Given that \texttt{GroupA} is equal to the sequence
  \begin{lstlisting}
    [ mk_Score(<Brazil>,2,0,1,6),
      mk_Score(<Norway>,1,2,0,5),
      mk_Score(<Morocco>,1,1,1,4),
      mk_Score(<Scotland>,0,1,2,1) ]
  \end{lstlisting}
\label{GroupAdef}
then:

  \begin{tabular}{lcl}
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a.team \\
            | a \keyw{in seq} GroupA \\
            \& a.won <> 0]}
    &$\equiv$ &
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a \\
            | a \keyw{in seq} GroupA\\
            \& a.won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)}
    &$\equiv$ &
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a \\
            | a \keyw{in seq} GroupA \\
            \& a.points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\section{Map Expressions} \label{mapexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{map enumeration} \dsep \Ruleref{map comprehension} \dsep \ldots
    }

  \Rule{map enumeration}{
    \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    }

  \Rule{maplet}{
    \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
    }

  \Rule{map comprehension}{
    \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

\item[Semantics:] A {\it map enumeration} has the form:
  \begin{lstlisting}
    {d1 |-> r1, d2 |-> r2, !\ldots!, dn |-> rn}
  \end{lstlisting}
  where all the domain expressions {\tt di} and range expressions {\tt ri}
  are general expressions and all {\tt di}'s must be different unless they point to the same value. The empty map
  is written as {\tt \{|->\}}.

  A {\it map comprehension} has the form:
  \begin{lstlisting}
    {ed |-> er | mbd1, !\ldots!, mbdn & P}
  \end{lstlisting}
  where constructs {\tt mbd1, \ldots, mbdn} are multiple bindings of
  variables from the expressions {\tt ed} and {\tt er} to sets (or types).
  The {\it map comprehension} constructs a mapping by evaluating the
  expressions {\tt ed} and {\tt er} on all the possible bindings for which
  the predicate {\tt P} evaluates to \keyw{true}.

\item[Examples:] Given that \texttt{GroupG} is equal to the map
  \begin{lstlisting}
    { <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) }
  \end{lstlisting}
\label{GroupGdef}
  then:

  \begin{tabular}{lcl}
  \parbox[t]{9cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{8em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{9cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\section{Tuple Constructor Expressions} \label{tupexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{tuple constructor} \dsep \ldots
    }

  \Rule{tuple constructor}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
    }

\item[Semantics:] The {\it tuple constructor expression}  has the form:
  \begin{lstlisting}
    mk_(e1, e2, !\ldots!, en)
  \end{lstlisting}
  where {\tt ei} is a general expression. It can only be used by the
  equality and inequality operators.

\item[Examples:] Using the map \texttt{GroupG} defined in the preceding
example, we have:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG}
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\section{Record Expressions} \label{recexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{record constructor} \dsep
    \Ruleref{record modifier} \dsep \ldots
    }

  \Rule{record constructor}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(},
    \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{record modifier}{
    \Lop{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,},
    \Ruleref{record modification}, \lfeed \SeqPt{\Lit{,}, \Ruleref{record modification}}
    \Lit{)}
    }

  \Rule{record modification}{
    \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
    }

\item[Semantics:] The {\it record constructor} has the form:
  \begin{lstlisting}
    mk_T(e1, e2, !\ldots!, en)
  \end{lstlisting}
  where the type of the expressions {\tt (e1, e2, \ldots, en)} matches the
  type of the corresponding entrances in the composite type {\tt T}. Note that the reason why a \emph{name} (and not an \emph{identifier}) is used here is to take into account that one would like to be able to refer also to a class or a module where the record type is defined (see Chapter~\ref{top-level}) this would look like {\tt mk\_MC`T(e1, e2,} \ldots{\tt , en)} where {\tt MC} will be the name of a \emph{module} or a \emph{class}.

  The {\it record modification} has the form:
  \begin{lstlisting}
    mu (e, id1 |-> e1, id2 |-> e2, !\ldots!, idn |-> en)
  \end{lstlisting}
  where the evaluation of the expression {\tt e} returns the record value
  to be modified. All the identifiers {\tt idi} must be distinct named
  entrances in the record type of {\tt e}.

\item[Examples:] If \texttt{sc} is the value \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} then
  \begin{lstlisting}
    mu (sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    !\MYEQUIV! mk_Score(<France>,3,1,0,10)
  \end{lstlisting}
  Further examples are demonstrated in the function \texttt{win}. This
  function takes two teams and a set of scores. From the set of scores
  it locates the scores corresponding to the given teams (\texttt{wsc}
  and \texttt{lsc} for the winning and losing team respectively), then
  updates these using the \keyw{mu} operator. The set of teams is then
  updated with the new scores replacing the original ones.
  \begin{lstlisting}
  win : Team * Team * set of Score -> set of Score
  win (wt,lt,gp) ==
    let wsc = iota sc in set gp & sc.team = wt,
        lsc = iota sc in set gp & sc.team = lt
    in
      let new_wsc = mu (wsc, won |-> wsc.won + 1,
                             points |-> wsc.points + 3),
          new_lsc = mu (lsc, lost |-> lsc.lost + 1)
      in
        (gp \ {wsc,lsc}) union {new_wsc, new_lsc}
  pre forall sc1, sc2 in set gp &
          ((sc1 <> sc2) <=> (sc1.team <> sc2.team))
          and {wt,lt} subset {sc.team | sc in set gp}
  \end{lstlisting}

\end{description}

\section{Apply Expressions}\label{app-expr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{apply} \dsep
    \Ruleref{field select} \dsep
    \Ruleref{tuple select} \dsep
    \Ruleref{function type instantiation} \dsep
    \ldots
    }

  \Rule{apply}{
    \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{field select}{
    \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
    }

  \Rule{tuple select}{
    \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
    }

  \Rule{function type instantiation}{
    \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
    }

\item[Semantics:] The {\it field select expression} can be used for records
  and it has already been explained in section~\ref{records} so no further
  explanation will be given here.

  The {\it apply} is used for looking up in a map, indexing in a
  sequence, and finally for calling a function. In section~\ref{maps} it
  has already been shown what it means to look up in a map. Similarly in
  section~\ref{sequences} it is illustrated how indexing in a sequence is
  performed. Function calls are using a call by value semantics meaning that the values are passed as arguments. The only exception to this is in the VDM++ and VDM-RT dialects where object references are passed as call by reference but since the functions cannot adjust any instance variable this make no semantic difference.

  In the VDM languages an operation can also be called
  here. This is not allowed in standard VDM-SL and because this kind of
  operation call can modify the state such usage should be done with
  care in complex expressions. Note however that such operation calls
  are not allowed to throw exceptions.

  With such operation calls the order of evaluation can become
  important. Therefore the type checker will allow the user to enable
  or disable operation calls inside expressions.

  The tuple select expression is used to extract a particular
  component from a tuple. The meaning of the expression is if
  \texttt{e} evaluates to some tuple
  \keyw{mk\_}\texttt{(v1,...,vN)} and \texttt{M} is an integer in the
  range \verb+{1,...,N}+ then \texttt{e.\#M} yields \texttt{vM}. If
  \texttt{M} lies outside \verb+{1,...,N}+ the expression is undefined.

  The {\it function type instantiation\/} is used for instantiating
  polymorphic functions with the proper types. It has the form:
  \begin{lstlisting}
    pf [ t1, ..., tn ]
  \end{lstlisting}
  where {\tt pf} is the name of a polymorphic function, and {\tt t1,
    \ldots, tn} are types. The resulting function uses the types {\tt
    t1, \ldots, tn} instead of the variable type names given in the
  function definition.

\item[Examples:] Recall that \texttt{GroupA} is a sequence (see page
  \pageref{GroupAdef}), \texttt{GroupG} is a map (see page \pageref{GroupGdef})
  and \texttt{selection\_sort} is a function (see page \pageref{selectionSortdef}):

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ &
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

  As an example of the use of polymorphic functions and function type
  instantiation, we use the example functions from
  section~\ref{functiondef}:
  \begin{lstlisting}
    let emptyInt = empty_bag[int]
    in
      plus_bag[int](-1, emptyInt())

  !\MYEQUIV!

    { -1 |-> 1 }
  \end{lstlisting}

\end{description}

\section{The New Expression (VDM++ and VDM-RT)}
\label{sec:creation}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{new expression}
    }
  \Rule{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\item[Semantics:] The {\it new expression} has the form:

  \begin{lstlisting}
    new classname(e1, e2, ..., en)
  \end{lstlisting}
  An object can be created (also called {\em instantiated}) from its
  class description using a {\it new expression}. The effect of a
  {\it new expression} is that a `new', unique object as described in
  class {\tt classname} is created. The value of the {\it new
  expression} is a reference to the new object.

  If the {\it new expression} is invoked with no parameters, an
  object is created in which all instance variables take their
  ``default'' values (i.e.\ the values defined by their initialisation
  conditions). With parameters, the {\it new expression} represents a
  \emph{constructor}~(see Section~\ref{constructors}) and creates
  customised instances (i.e.\ where the instance variables may take
  values which are different from their default values).


\item[Examples:] Suppose we have a class called \texttt{Queue} and
  that default instances of \texttt{Queue} are empty. Suppose also
  that this class contains a constructor (which will also be called
  \texttt{Queue}) which takes a single parameter which is a list of
  values representing an arbitrary starting queue. Then we can
  create default  instances of \texttt{Queue} in which the actual
  queue is empty using the expression
\begin{lstlisting}
  new Queue()
\end{lstlisting}
and an instance of \texttt{Queue} in which the actual
  queue is, say, \texttt{e1, e2, e3} using the expression
\begin{lstlisting}
  new Queue([e1, e2, e3])
\end{lstlisting}

Using the class \texttt{Tree} defined on page \pageref{TreeDef} we create
new \texttt{Tree} instances to construct \texttt{node}s:
\begin{lstlisting}
mk_node(new Tree(), x, new Tree())
\end{lstlisting}


\end{description}

\section{The Self Expression (VDM++ and VDM-RT)}
\label{sec:self}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{self expression}
    }
  \Rule{self expression}{
    \Lop{self}
  }

\item[Semantics:] The {\it self expression} has the form:

  \begin{lstlisting}
    self
  \end{lstlisting}
  The self expression returns a reference to the object currently
    being executed. It can be used to simplify the name space in
    chains of inheritance.

\item[Examples:] Using the class \texttt{Tree} defined on page
\pageref{TreeDef} we can specify a subclass called \texttt{BST} which
stores data using the binary search tree approach.
We can then specify an operation which performs a binary search tree
insertion:
\begin{lstlisting}
    Insert : int ==> ()
    Insert (x) ==
      (dcl curr_node : Tree := self;

       while not curr_node.isEmpty() do
         if curr_node.rootval() < x
         then curr_node := curr_node.rightBranch()
         else curr_node := curr_node.leftBranch();
       curr_node.addRoot(x);
       )
\end{lstlisting}
This operation uses a self expression to find the root at which to
being traversal prior to insertion. Further examples are given in
section \ref{call-stmt}.
\end{description}

\section{The Threadid Expression  (VDM++ and VDM-RT)}
\label{sec:threadid}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{threadid expression}
    }
  \Rule{threadid expression}{
    \Lop{threadid}
  }

\item[Semantics:] The {\it threadid expression} has the form:

  \begin{lstlisting}
    threadid
  \end{lstlisting}
  The threadid expression returns a natural number which uniquely
  identifies the thread in which the expression is executed. Note that
  periodic threads gets a new threadid at the start of each new period.

\item[Examples:]
Using {\bf\ttfamily threadid}'s it is possible to provide a VDM++ base class that
implements a Java-style wait-notify in VDM++ using permission
predicates. Any object that should be available for the wait-notify
mechanism must derive from this base class.
\begin{lstlisting}
class WaitNotify

  instance variables
    waitset : set of nat := {};

  operations
    protected wait: () ==> ()
    wait() ==
      let p = threadid
      in (
        AddToWaitSet( p );
        Awake();
       );

    AddToWaitSet : nat ==> ()
    AddToWaitSet( p ) ==
      waitset := waitset union { p };

    Awake: () ==> ()
    Awake() ==
      skip;

    protected notify: () ==> ()
    notify() ==
      if waitset <> {}
      then let arbitrary_process in set waitset
           in waitset := waitset \ {arbitrary_process};

    protected notifyAll: () ==> ()
    notifyAll() ==
         waitset := {};

  sync
    mutex(notifyAll, AddToWaitSet, notify);
    per Awake => threadid not in set waitset;

end WaitNotify
\end{lstlisting}
In this example the {\bf\ttfamily threadid} expression is used in two places:
\begin{itemize}
\item In the \texttt{Wait} operation for threads to register interest
  in this object.
\item In the permission predicate for \texttt{Awake}. An interested
  thread should call \texttt{Awake} following registration using
  \texttt{Wait}. It will then be blocked until its threadid is removed
  from the waitset following another thread's call to \texttt{notify}.
\end{itemize}

%Note also that one needs to be careful about the use of the wait-notify
%mechanism when having periodic threads (because they change their
%{\bf\ttfamily threadid}
%for each new period).
\end{description}

\section{The Lambda Expression}\label{lambda}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{lambda expression} \dsep \ldots
    }

  \Rule{lambda expression}{
    \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
    }

\Rule{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it lambda expression} is of the form:
  \begin{lstlisting}
    lambda pat1 : T1, !\ldots!, patn : Tn & e
  \end{lstlisting}
  where the {\tt pati} are patterns, the {\tt Ti} are type expressions, and
  {\tt e} is the body expression. The scope of the pattern identifiers in
  the patterns {\tt pati} is the body expression. A lambda expression
  cannot be polymorphic, but apart from that, it corresponds semantically
  to an explicit function definition as explained in
  chapter~\ref{functiondef}. A function defined by a lambda expression can
  be Curried by using a new nested lambda expression in the body. 
  When lambda expressions are bound to an identifier they can also
  define a recursive function.

\item[Examples:] An increment function can be defined by means of a lambda
  expression like:
  \begin{lstlisting}
    Inc = lambda n : nat & n + 1
  \end{lstlisting}
  and an addition function can be Curried by:
  \begin{lstlisting}
    Add = lambda a : nat & lambda b : nat & a + b
  \end{lstlisting}
  which will return a new lambda expression if it is applied to only one
  argument:
  \begin{lstlisting}
    Add(5) !\(\equiv\)! lambda b : nat & 5 + b
  \end{lstlisting}
  Lambda expression can be useful when used in conjunction with higher-order
  functions. For instance using the function \texttt{set\_filter}
  defined on page \pageref{setfilterdef}:
  \begin{lstlisting}
  set_filter[nat](lambda n:nat & n mod 2 = 0)({1,...,10})
  !\MYEQUIV! {2,4,6,8,10}
  \end{lstlisting}
\end{description}


\section{Narrow Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{narrow expression} \dsep
    \ldots
    }

  \Rule{narrow expression}{
    \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)}
    }

    \item[Semantics:] The {\it narrow expression} converts the given {\tt expression} value into the given {\tt type},
returning a value of that type.
It is legal to downcast a class to one of its subclasses, and it is legal to narrow an expression of a union type
to one of its subtypes. However, a conversions between two completely unrelated types is a type error. Note that a
narrow expression does not guarantee that its argument will be of the correct type at runtime, but using narrow gives
extra type information to the specification.

    \item[Examples:] In following examples, the Test() and Test'() operations should give the same results,
    but there is a type error in Test() which is resolved in Test' using a narrow expression.

      \begin{lstlisting}
class S
end S

class C1 is subclass of S

instance variables
public a : nat := 1;

end C1

class C2 is subclass of S

instance variables
public b : nat := 2;

end C2

class A

operations
public
Test: () ==>  seq of nat
Test() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> e.a,
                (isofclass(C2, e)) -> e.b
               end | i in set inds list ];

public
Test': () ==>  seq of nat
Test'() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> narrow_(e, C1).a,
                (isofclass(C2, e)) -> narrow_(e, C2).b
               end | i in set inds list ];
end A
      \end{lstlisting}

      \begin{lstlisting}
class A

types
public C1 :: a : nat;
public C2 :: b : nat;
public S = C1 | C2;

operations
public
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

public
Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
end A
      \end{lstlisting}

\end{description}


\section{Is Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{general is expression} \dsep
    \ldots
    }

  \Rule{general is expression}{
    \Ruleref{is expression} \dsep
    \Ruleref{type judgement}
    }


  \Rule{is expression}{
    \Lop{is\_}, (\Ruleref{name} \dsepl \Ruleref{basic type}), \Lit{(}, \Ruleref{expression}, \Lit{)} 
    }

  \Rule{type judgement}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\item[Semantics:] The {\it is expression} can be used with values
     that are either basic or record values (tagged values belonging
     to some composite type). The is expression yields true if the
     given value belongs to the basic type indicated or if the value
     has the indicated  tag. Otherwise it yields false.

     A type judgement is a more general form which can be used for
     expressions whose types cannot be statically determined. The
     expression \texttt{\keyw{is}\_(e,t)} is equal to true if and only
     if \texttt{e} is of type \texttt{t}.

\item[Examples:] Using the record type \texttt{Score} defined on page
  \pageref{scoredef} we have:

  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
% Ueki mod start (Kagemai#54)
%    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,8))}
%      & $\equiv$ & \keyw{false}\\
% Ueki mod end
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

  An example of a type judgement:
  \begin{lstlisting}
    Domain : map nat to nat | seq of (nat*nat) -> set of nat
    Domain(m) ==
      if is_(m, map nat to nat)
      then dom m
      else {d | mk_(d,-) in set elems m}
  \end{lstlisting}
     In addition there are examples on page \pageref{exprIsExs}.
\end{description}

\section{Base Class Membership (VDM++ and VDM-RT)}\index{base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofbaseclass expression} \dsep
    \ldots
    }

  \Rule{isofbaseclass expression}{
    \Lop{isofbaseclass},
    \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\item[Semantic:] The function {\keyw{isofbaseclass}} when applied to an
  object reference \texttt{expression} and a class name \texttt{name}
  yields the boolean value {\bf\ttfamily true} if and only if \texttt{name} is a
  root superclass in the inheritance chain of the object referenced to
  by {\texttt expression}, and {\bf\ttfamily false} otherwise.

\item[Examples:] \label{treeExDef}
  Suppose that \texttt{BinarySearchTree} is a subclass of
  \texttt{Tree}, \texttt{Tree} is not a subclass of any other class and
  \texttt{Queue} is not related by inheritance to either \texttt{Tree}
  or \texttt{BinarySearchTree}. Let \texttt{t} be an instance of
  \texttt{Tree}, \texttt{b} is an instance of \texttt{BinarySearchTree}
  and \texttt{q} is an instance of \texttt{Queue}. Then:

  \begin{tabular}{lcl}
    \keyw{isofbaseclass}\texttt{(Tree, t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(BinarySearchTree, b)} & $\equiv$ & \keyw{false}\\
    \keyw{isofbaseclass}\texttt{(Queue, q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, q)} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\section{Class Membership}\index{class membership expression}
\begin{description}
\item[Syntax]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofclass expression} \dsep
    \ldots
    }
  \Rule{isofclass expression}{
    \Lop{isofclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The function \keyw{isofclass} when applied to an
  object reference {expression} and a class name \texttt{name}
  yields the boolean value {\bf\ttfamily true} if and only if \texttt{expression}
  refers to an object of class \texttt{name} or to an object of any of
  the subclasses of \texttt{name}, and {\bf\ttfamily false} otherwise.

\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, we have:

  \begin{tabular}{lcl}
    \keyw{isofclass}\texttt{(Tree,t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,q)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(Queue,q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,t)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,b)} & $\equiv$ & \keyw{true}
  \end{tabular}

\end{description}

\section{Same Base Class Membership (VDM++ and VDM-RT)}%
\index{same base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{samebaseclass expression} \dsep
    \ldots
    }
  \Rule{samebaseclass expression}{\Lop{samebaseclass}, \lfeed
  \Lit{(},
        \Ruleref{expression}, \Lit{,}, \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] The function \keyw{samebaseclass} when applied to
  object references \texttt{expression1} and \texttt{expression2} yields
  the boolean value {\bf\ttfamily true} if and only if the objects denoted by
  \texttt{expression1} and \texttt{expression2} are instances of classes
  that can be derived from the same root superclass, and {\bf\ttfamily false}
  otherwise.

\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, suppose that
\texttt{AVLTree} is another subclass of \texttt{Tree},
\texttt{BalancedBST} is a subclass of \texttt{BinarySearchTree}, \texttt{a}
is an instance of \texttt{AVLTree} and \texttt{bb} is an instance of
\texttt{BalancedBST} :

  \begin{tabular}{lcl}
  \keyw{samebaseclass}\texttt{(a,b)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(a,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(b,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(t,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(q,a)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{Same Class Membership (VDM++ and VDM-RT)}%
\index{same class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{sameclass expression} \dsep
    \ldots
    }

  \Rule{sameclass expression}{\Lop{sameclass}, \lfeed
  \Lit{(}, \Ruleref{expression}, \Lit{,},
        \Ruleref{expression}, \Lit{)}
   }

\item[Semantics:] The function \keyw{sameclass} when applied to object
  references \texttt{expression1} and \texttt{expression2} yields the
  boolean value {\bf\ttfamily true} if and only if the objects denoted by
  \texttt{expression1} and \texttt{expression2} are instances of the same
  class, and {\bf\ttfamily false} otherwise.

\item[Examples:]
Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} from section \ref{treeExDef}, and assuming
\texttt{b'} is another instance of \texttt{BinarySearchTree} we have:

  \begin{tabular}{lcl}
  \keyw{sameclass}\texttt{(b,t)} & $\equiv$ & \keyw{false}\\
  \keyw{sameclass}\texttt{(b,b')} & $\equiv$ & \keyw{true}\\
  \keyw{sameclass}\texttt{(q,t)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{History Expressions (VDM++ and VDM-RT)}\index{history expressions}
\label{sec:historyexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{act expression} \dsep
    \Ruleref{fin expression} \dsep
    \Ruleref{active expression} \dsep
    \Ruleref{req expression} \dsep
    \Ruleref{waiting expression} \dsep
    \ldots
  }
  \Rule{act expression}{
    \Lop{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{fin expression}{
    \Lop{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{active expression}{
    \Lop{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{req expression}{
    \Lop{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{waiting expression}{
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }

\item[Semantics:] History expressions can only be used in
permission predicates (see section \ref{sec:permissionpred}). History
expressions may contain one or more of the following expressions:

\begin{itemize}
\item {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}. The number of times
  that {\em operation name} operation has been activated.
\item {\bf\ttfamily \#fin}{\tt (}{\em operation name}{\tt )}. The number of times that
  the {\em operation name} operation has been completed.
\item {\bf\ttfamily \#active}{\tt (}{\em operation name}{\tt )}. The number of {\em operation
  name} operations that are currently active. \\
 Thus: {\bf\ttfamily
  \#active}{\tt (}{\em
    operation name}{\tt )} $=$ {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}
  $-$ {\bf\ttfamily \#fin}{\tt (}{\em operation name}{\tt )}.
\item {\bf\ttfamily \#req}{\tt (}{\em operation name}{\tt )}. The number of requests
  that has been issued for the {\em operation name} operation.
\item {\bf\ttfamily \#waiting}{\tt (}{\em operation name}{\tt )}. The number of
  outstanding requests for the {\em operation name} operation. \\
Thus:
  {\bf\ttfamily
    \#waiting}{\tt (}{\em operation name}{\tt )} $=$ {\bf\ttfamily
    \#req}{\tt (}{\em operation
    name}{\tt )} $-$ {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}.
\end{itemize}
For all of these operators, the name list version
\texttt{\#}\textit{history op(op1,$\ldots$,opN)} is simply shorthand
for \texttt{\#}\textit{history op(op1)} \texttt{+} $\mathtt{\cdots}$
\texttt{+\#}\textit{history op(opN)}.

\item[Examples:]Suppose at a point in the execution of a particular
thread, three operations, \texttt{A}, \texttt{B} and \texttt{C} may be
executed. A sequence of requests, activations and completions occur
during this thread. This is shown graphically in figure \ref{historyfig}.

\insertfig{history}{14cm}{History Expressions}{\label{historyfig}}

Here we use the notation \textit{rA} to indicate a request for an
execution of operation \texttt{A}, \textit{aA} indicates an activation
of \texttt{A}, \textit{fA} indicates completion of an execution of
operation \texttt{A}, and likewise for operations \texttt{B} and
\texttt{C}. The respective history expressions have the following
values after the interval [\textbf{S},\textbf{T}]:
\end{description}

\begin{center}\small
\begin{tabular}{llll}
\texttt{{\bf\ttfamily \#act}(A) = 1} & \texttt{{\bf\ttfamily \#act}(B) = 1} & \texttt{{\bf\ttfamily \#act}(C) = 1}
& \texttt{{\bf\ttfamily \#act}(A,B,C) = 3}\\
\texttt{{\bf\ttfamily \#fin}(A) = 1} & \texttt{{\bf\ttfamily \#fin}(B) = 1} & \texttt{{\bf\ttfamily \#fin}(C) = 0}
& \texttt{{\bf\ttfamily \#fin}(A,B,C) = 2}\\
\texttt{{\bf\ttfamily \#active}(A) = 0} & \texttt{{\bf\ttfamily \#active}(B) = 0} &
\texttt{{\bf\ttfamily \#active}(C) = 1} & \texttt{{\bf\ttfamily \#active}(A,B,C) = 1}\\
\texttt{{\bf\ttfamily \#req}(A) = 2} & \texttt{{\bf\ttfamily \#req}(B) = 1} & \texttt{{\bf\ttfamily \#req}(C) = 3}
& \texttt{{\bf\ttfamily \#req}(A,B,C) = 6}\\
\texttt{{\bf\ttfamily \#waiting}(A) = 1} & \texttt{{\bf\ttfamily \#waiting}(B) = 0} &
\texttt{{\bf\ttfamily \#waiting}(C) = 2} & \texttt{{\bf\ttfamily \#waiting}(A,B,C) = 3}\\
\end{tabular}
\end{center}


\section{The Time Expression (VDM-RT)}\index{time expression}\label{sec:time}

\begin{description}
\item[Syntax:]
 \Rule{time expression}{\Lop{time}}

\item[Semantics:] This is simply an easy way to refer to the current time on
     a given CPU. The time is provided as a natural number, with a resolution of 1~nsec.
\item[Examples:] If for example one would like to log when a certain operation takes place one can create an operation such as \texttt{logEnvToSys} below.
\begin{lstlisting}
  public logEnvToSys: nat ==> ()
  logEnvToSys (pev) == e2s := e2s munion {pev |-> time};
\end{lstlisting}
\end{description}


\section{Literals and Names}

\begin{description}
\item[Syntax:]
  \Rule{expression}{    \ldots \dsep
    \Ruleref{name} \dsep
    \Ruleref{old name} \dsep
    \Ruleref{symbolic literal} \dsep
    \ldots
    }

  \Rule{name}{
    \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
    }

  \Rule{name list}{
    \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
    }

  \Rule{old name}{
    \Ruleref{identifier}, \Lit{\char'176}
    }

\item[Semantics:] {\it Names\/} and {\it old names\/} are used to access
  definitions of functions, operations, values and state components. A {\it
    name\/} has the form:
  \begin{lstlisting}
    id1`id2
  \end{lstlisting}
  where {\tt id1} and {\tt id2} are simple identifiers. If a name consists
  of only one identifier, the identifier is defined within scope, i.e.\ it
  is defined either locally as a pattern identifier or variable,
  or globally within the current module as a function, operation,
  value or global variable.
  Otherwise, the identifier {\tt id1} indicates the
module/class name
where the
  construct is defined (see also
  section~\ref{modules} and
  section~\ref{sec:classdep}
and appendix \ref{ap:lexis}.)

  An {\it old name\/} is used to access the old value of global
  variables in the post condition of an operation definition (see
  chapter~\ref{op-def}) and in the post condition of specification
  statements (see section~\ref{se:specification}).  It has the form:

  \begin{lstlisting}
    id~
  \end{lstlisting}
  where {\tt id} is a state component.

  {\it Symbolic literals\/} are constant values of some basic type.

\item[Examples:] {\it Names} and {\it symbolic literals\/} are used
  throughout all examples in this document (see appendix~\ref{Symbols}).

  For an example of the use of {\it old names}, consider the VDM-SL
  state defined as:
  \begin{lstlisting}
state sigma of
  numbers : seq of nat
  index   : nat
inv mk_sigma(numbers, index) ==
   index not in set elems numbers
init s == s = mk_sigma([], 1)
end
  \end{lstlisting}
  For an example of the use of {\it old names}, consider the
  VDM++/VDM-RT instance variables defined as:
  \begin{lstlisting}
    instance variables
      numbers: seq of nat := [];
      index  : nat := 1;
    inv index not in set elems numbers;
  \end{lstlisting}

  We can define an operation that increases the variable {\tt index} in
  an implicit manner:
  \begin{lstlisting}
    IncIndex()
    ext wr index : nat
    post index = index~ + 1
  \end{lstlisting}
  The operation {\tt IncIndex} manipulates the variable {\tt index},
  indicated with the \keyw{ext wr} clause. In the post condition, the new
  value of {\tt index} is equal to the old value of {\tt index} plus
  \texttt{1}. (See more about operations in chapter~\ref{op-def}).

  For a simple example of
module/class
  names, suppose that a function called
  \texttt{build\_rel} is defined (and exported) in a
module/class
  called
  \texttt{CGRel} as follows:
\begin{lstlisting}
  types

    Cg = <A> | <B> | <C> | <D> | <E> | <F> |
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = map Cg to set of Cg

  functions

    build_rel : set of (Cg * Cg) -> CompatRel
    build_rel (s) == {|->}
\end{lstlisting}
In another
module/class
  we can access this function by in VDM-SL
first importing the module \texttt{CGRel} then by
  using the following call
  \begin{lstlisting}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{lstlisting}
Note that in VDM++ and VDM-RT the \texttt{build\_rel} function can
additionally have
an access modifier allowing access to it outside the defining class.
\end{description}

\section{The Undefined Expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{undefined expression}
    }

  \Rule{undefined expression}{
    \Lop{undefined}
    }

\item[Semantics:] The {\it undefined expression} is used to state
  explicitly that the result of an expression is undefined. This could
  for instance be used if it has not been decided what the result of
  evaluating the else-branch of an if-then-else expression should be.
  When an {\it undefined expression} is evaluated the
  VDM interpreters will terminate the execution
  and report that an undefined expression was evaluated.

  Pragmatically use of undefined expressions differs from
  pre-conditions: use of a pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the function is called; if an undefined expression is used it is the
  called function's responsibility to deal with error handling.

\item[Examples:] We can check that the type invariant holds before building 
  \texttt{Score} values:
  \begin{lstlisting}
  build_score : Team * nat * nat * nat * nat -> Score
  build_score (t,w,d,l,p) ==
    if 3 * w + d = p
    then mk_Score(t,w,d,l,p)
    else undefined
  \end{lstlisting}
\end{description}

\section{The Precondition Expression}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{precondition expression}
    }
  \Rule{precondition expression}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{expression list}, \Lit{)}
    }

\item[Semantics:]
  Assuming \texttt{e} is of function type the expression
  \keyw{pre\_}\texttt{(e,e1,...,en)} is true if and only if the
  pre-condition of \texttt{e} is true for arguments \texttt{e1,...,em}
  where \texttt{m} is the arity of the pre-condition of \texttt{e}. If
  \texttt{e} is not a function or \texttt{m} $>$ \texttt{n} then the
  result is {\bf\ttfamily true}. If \texttt{e} has no pre-condition then the
  expression equals true.
\item[Examples:]
  Consider the functions \texttt{f} and \texttt{g} defined below
  \begin{lstlisting}
  f : nat * nat -> nat
  f(m,n) == m div n
  pre n <> 0;

  g (n: nat) sqrt: nat
  pre n >= 0
  post sqrt * sqrt <= n and
       (sqrt+1) * (sqrt+1) > n
  \end{lstlisting}
  Then the expression
  \begin{lstlisting}
  pre_(let h in set {f,g,lambda mk_(x,y): nat * nat & x div y}
       in h, 1,0,-1)
  \end{lstlisting}
  is equal to
  \begin{itemize}
  \item false if \texttt{h} is bound to \texttt{f} since this equates
        to \texttt{\keyw{pre}\_f(1,0)};
  \item true if \texttt{h} is bound to \texttt{g} since this equates
        to \texttt{\keyw{pre}\_g(1)};
  \item true if \texttt{h} is bound to
        \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} since there is no
        pre-condition defined for this function.
  \end{itemize}
  Note that however \texttt{h} is bound, the last argument
  (\texttt{-1}) is never used.

When a function is defined to be total, that totality is with respect to the pre-condition.
Consider an alternative definition of `{\tt f}'

\begin{lstlisting}
f: nat * nat +> nat
f(m,n) == m div n
pre n <> 0; 
\end{lstlisting}

The definition states the function is total for all values of type \keyw{nat}{\tt *}\keyw{nat} where the second element of the pair is non-zero.
Therefore, even though the function is not defined for values such as {\tt mk\_(4,0)} it is still a total function.
On the other hand, the definition
\begin{lstlisting}
f: nat * nat +> nat
f(m,n) == m div n;
\end{lstlisting}
is incorrect because it is not defined for values such as {\tt mk\_(4,0)} hence not total.  


\end{description}


\chapter{Patterns}\label{patterns}

\begin{description}
\item[Syntax:]
  \Rule{pattern bind}{
    \Ruleref{pattern} \dsepl
    \Ruleref{bind}
    }

  \Rule{pattern}{
    \Ruleref{pattern identifier} \dsep
    \Ruleref{match value} \dsep
    \Ruleref{set enum pattern} \dsep
    \Ruleref{set union pattern} \dsep
    \Ruleref{seq enum pattern} \dsep
    \Ruleref{seq conc pattern} \dsep
    \Ruleref{map enumeration pattern} \dsep
    \Ruleref{map munion pattern} \dsep
    \Ruleref{tuple pattern} \dsep
    \Ruleref{record pattern} \dsep
    \Ruleref{object pattern}
    }

  \Rule{pattern identifier}{
    \Ruleref{identifier} \dsepl \Lit{-}
    }

  \Rule{match value}{
    \Ruleref{symbolic literal} \dsep \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{set enum pattern}{
    \Lit{\{}, [\Ruleref{pattern list}], \Lit{\}}
    }

  \Rule{set union pattern}{
    \Ruleref{pattern}, \Lit{\keyw{union}}, \Ruleref{pattern}
    }

  \Rule{seq enum pattern}{
    \Lit{[}, [\Ruleref{pattern list}], \Lit{]}
    }

  \Rule{seq conc pattern}{
    \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
    }

  \Rule{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    }

  \Rule{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

  \Rule{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

   \Rule{map munion pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

  \Rule{tuple pattern}{
    \Lop{mk\_(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
    }

  \Rule{record pattern}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, [\Ruleref{pattern list}], \Lit{)}
    }


  \Rule{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}\nmk
    }
 \ntext{\Ruleref{object pattern} is only be used in VDM++ and VDM-RT. The
 	\Ruleref{object pattern} is explained in \ref{sec:object_pattern}}

  \Rule{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Rule{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

  \Rule{pattern list}{
    \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
    }

\item[Semantics:] A pattern is always used in a context where it is matched
  to a value of a particular type. Matching consists of checking that the
  pattern can be matched to the value, and binding any pattern identifiers
  in the pattern to the corresponding values, i.e.\ making the identifiers
  denote those values throughout their scope. In some cases where a pattern
  can be used, a bind can be used as well (see next chapter). If a bind is
  used it simply means that additional information (a type or a set
  expression) is used to constrain the possible values which can match the
  given pattern.

  Matching is defined as follows
  \begin{enumerate}
  \item A {\it pattern identifier} fits any type and can be matched to any
    value. If it is an identifier, that identifier is bound to the value;
    if it is the don't-care symbol \Lit{-}, no binding occurs.

  \item A {\it match value} can only be matched against the value of
    itself; no binding occurs. If a match value is not a literal like e.g.
    {\tt 7} or {\tt <RED>} it must be an expression enclosed in parentheses in order to
    discriminate it to a pattern identifier.

  \item A {\it set enumeration pattern} fits only set values. The patterns
    are matched to distinct elements of a set; all elements must be
    matched.

  \item A {\it set union pattern} fits only set values. The two patterns
    are matched to a partition of two subsets of a set. In the VDM interpreters
    the two subsets will always be chosen such that they are non-empty
    and disjoint.

  \item A {\it sequence enumeration pattern} fits only sequence values.
    Each pattern is matched against its corresponding element in the
    sequence value; the length of the sequence value and the number of
    patterns must be equal.

  \item A {\it sequence concatenation pattern} fits only sequence values.
    The two patterns are matched against two subsequences which together
    can be concatenated to form the original sequence value. In the
    VDM interpreters the two subsequences will always be chosen so that they
    are non-empty.

  \item A {\it map enumeration pattern} fits only map values.

  \item A {\it maplet pattern list} are matched to distinct elements of a map;
   all elements must be matched.

  \item A {\it map munion pattern} fits only map values.
   The two patterns are matched to a partition of two sub maps of a map.
   In the VDM interpreters the two sub maps will always be chosen such that they are non-empty and disjoint.

  \item A {\it tuple pattern} fits only tuples with the same number of
    elements. Each of the patterns are matched against the corresponding
    element in the tuple value.

  \item A {\it record pattern} fits only record values with the same tag.
    Each of the patterns are matched against the field of the record value.
    All the fields of the record must be matched.

  \item An {\it object pattern} is explained in section~\ref{sec:object_pattern}
  \end{enumerate}

\item[Examples:] The simplest kind of pattern is the pattern
identifier. An example of this is given in the following let
expression:
\begin{lstlisting}
  let top = GroupA(1)
  in top.sc
\end{lstlisting}
Here the identifier \texttt{top} is bound to the head of the sequence
\texttt{GroupA} and the identifier may then be used in the body of the
let expression.

In the following examples we use match values:
\begin{lstlisting}
  let a = <France>
  in cases GroupA(1).team:
       <Brazil> -> "Brazil are winners",
       (a)      -> "France are winners",
       others   -> "Neither France nor Brazil are winners"
     end;
\end{lstlisting}
Match values can only match against their own values, so here if the
team at the head of \texttt{GroupA} is \texttt{<Brazil>} then the
first clause is matched; if the team at the head of \texttt{GroupA} is
\texttt{<France>} then the second clause is matched. Otherwise the
\keyw{others} clause is matched. Note here that the use of brackets
around \texttt{a} forces \texttt{a} to be considered as a match value.

Set enumerations match patterns to elements of a set. For instance in:
\begin{lstlisting}
  let {sc1, sc2, sc3, sc4} = elems GroupA
  in
    sc1.points + sc2.points + sc3.points + sc4.points;
\end{lstlisting}
the identifiers \texttt{sc1}, \texttt{sc2}, \texttt{sc3} and
\texttt{sc4} are bound to the four elements of \texttt{GroupA}. Note
that the choice of binding is loose -- for instance
\texttt{sc1} may be bound to any element of \texttt{\keyw{elems}
GroupA}. In this case if \texttt{\keyw{elems} GroupA} does not contain
precisely four elements, then the expression is not well-formed.

A set union pattern can be used to decompose a set for recursive
function calls. An example of this is the function \texttt{set2seq}
which converts a set into a sequence (with arbitrary order):
\begin{lstlisting}
set2seq[@elem] : set of @elem -> seq of @elem
set2seq(s) ==
  cases s:
    {}          -> [],
    {x}         -> [x],
    s1 union s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
  end
\end{lstlisting}
In the third cases alternative we see the use of a set union pattern. This
binds \texttt{s1} and \texttt{s2} to arbitrary subsets of \texttt{s}
such that they partition \texttt{s}. The VDM interpreters always
ensure a disjoint partition.

Sequence enumeration patterns can be used to extract specific elements
from a sequence. An example of this is the function \texttt{promoted}
which extracts the first two elements of a sequence of scores and
returns the corresponding pair of teams:
\begin{lstlisting}
promoted : seq of Score -> Team * Team
promoted([sc1,sc2]^-) == mk_(sc1.team,sc2.team);
\end{lstlisting}
Here \texttt{sc1} is bound to the head of the argument sequence, and
\texttt{sc2} is bound to the second element of the sequence. If
\texttt{promoted} is called with a sequence with fewer than two
elements then a runtime error occurs. Note that as we are not
interested in the remaining elements of the list we use a don't care
pattern for the remainder.

The preceding example also demonstrated the use of sequence
concatenation patterns. Another example of this is the function
\texttt{quicksort} which implements a standard quicksort algorithm:
\begin{lstlisting}
quicksort : seq of nat -> seq of nat
quicksort (l) ==
  cases l:
    [] -> [],
    [x] -> [x],
    [x,y] -> if x < y then [x,y] else [y,x],
    -^[x]^- ->
          quicksort([l(i) | i in set inds l & l(i) < x])
                  ^ [l(i) | i in set inds l & l(i) = x] ^
          quicksort([l(i) | i in set inds l & l(i) > x])
  end
\end{lstlisting}
Here, in the second cases clause a sequence concatenation pattern is
used to decompose \texttt{l} into an arbitrary pivot element and two
subsequences. The pivot is used to partition the list into those
values less than the pivot and those values greater, and these two
partitions are recursively sorted.


Maplet pattern match patterns to elements of a maplet.
\begin{lstlisting}
let {a |-> b} = {1 |-> 2} in mk_(a,b) = mk_(1,2)
\end{lstlisting}

Maplet pattern list match patterns to elements of each maplet in a map.
\begin{lstlisting}
let {1 |-> a,a |-> b,b |-> c} = {1 |-> 4,2 |-> 3,4 |-> 2} in
c = 3
\end{lstlisting}

Map munion pattern can be used to decompose a map for recursive function calls. The following \texttt{map2seq} function converts a map to a seq of maplet:
\begin{lstlisting}
public map2seq[@T1, @T2] :
    map @T1 to @T2 -> seq of (map @T1 to @T2)
map2seq(m) ==
  cases m:
    ({|->})	-> [],
    {- |-> -}	-> [m],
    m1 munion m2 ->
        map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
 end;
\end{lstlisting}
Here, in the third cases clause a map munion pattern is used to decompose \texttt{m}
into two maps.

Tuple patterns can be used to bind tuple components to
identifiers. For instance since the function \texttt{promoted} defined
above returns a pair, the following value definition binds the winning
team of \texttt{GroupA} to the identifier \texttt{Awinner}:
\begin{lstlisting}
  values

    mk_(Awinner,-) = promoted(GroupA);
\end{lstlisting}

Record patterns are useful when several fields of a record are used in
the same expression. For instance the following expression constructs
a map from team names to points score:
\begin{lstlisting}
  { t |-> w * 3 + l | mk_Score(t,w,l,-,-) in set elems GroupA}
\end{lstlisting}
The function \texttt{print\_Expr} on page \pageref{printExprDef} also gives
several examples of record patterns.
\end{description}


\section{Object Pattern (VDM++ and VDM-RT)}\label{sec:object_pattern}

\begin{description}

\item[Syntax:]
  \Rule{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}
    }

  \Rule{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Rule{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

\item[Semantics:] An object pattern matches object references. An object is matched to the class identified by the class name led by the prefix \textbf{\texttt{obj\_}}. If the class of the object is class \texttt{identifier} or any of its subclasses, separate instance variables named in an object pattern are matched against the object from left to right.  It is not necessary to enumerate all the instance variables of a referenced class in an object pattern.

Object patterns may appear only where access to the instance variables named in the pattern would be permitted. So private instance variables can only be matched within operations of the same class. This also implies an object pattern may not appear in function definitions, preconditions, postconditions or invariants. The type checker will validate accessibility of each instance variable in the pattern. The value of referenced instance variables is not guaranteed to remain unchanged during matching.

\item[Examples:] Using an object pattern, an object can be matched by the values of its instance variables. The following simple example evaluates to \texttt{<STUDENT>} if and only if the object reference person points at an instance of the class Student or any of its subclasses, otherwise \texttt{<NOT\_STUDENT>}:
\begin{lstlisting}
cases person:
   obj_Student() -> <STUDENT>,
   others -> <NOT_STUDENT>
end
\end{lstlisting}

The above object pattern would match any instance of the Student class, or any subclass, for example an Undergraduate if such a subclass existed. The following example matches the instance variable name against \texttt{"John"}:

\begin{lstlisting}
cases person:
   obj_Student(name |-> "John") -> <JOHN>,
   others -> <NOT_A_STUDENT_OR_NOT_JOHN>
end
\end{lstlisting}
An object pattern can also bind the value of instance variable. For example, the following expression binds \texttt{n} to the \texttt{name} instance variable of  \texttt{person} if person is an instance of the class Student.

\begin{lstlisting}
cases person:
   obj_Student(name |-> n) -> n,
   others -> ""
end
\end{lstlisting}
An object pattern may contain another object pattern. The following expression gives the name and department concatenated by \texttt{"@"} for Students, and add the title for Professors.
\begin{lstlisting}
cases person:
   obj_Student
      (name |-> n, dept |-> obj_Department(name->dname))
                 -> n^"@"^dname,
   obj_Professor(name |-> n) -> "Prof. "^n,
   others -> ""
end
\end{lstlisting}
An object pattern may appear in conjunction with other kinds of patterns. The following operation takes a sequence of \texttt{Professor} objects and returns titled names sorted into initials. The first pattern of the cases expression consists of a list concatenation pattern. The first element of the list is matched against an object pattern whose instance variable {\tt name} is also matched against another sequence concatenation pattern of the initial character {\tt initial} and the  {\tt remaining}:

\begin{lstlisting}
professorDict: seq of Professor
                        ==> map char to set of seq of char
professorDict(ps) == return cases ps:
  [obj_Professor(name |-> [initial]^remaining)]^rest ->
    let
      dict = professorDict(rest),
      name = "Prof. "^[initial]^remaining,
      names = if initial in set dom dict
                     then dict(initial)
                     else {}
    in
  dict ++ {initial |-> names union {name}},
  [-]^rest -> professorDict(rest),[] -> {|->}
  end;
\end{lstlisting}  

For example, the call \texttt{professorDict([new Professor("Smith"), \\new Professor("Scott"), new Professor("Adams")])} evaluates to:
\begin{lstlisting}
{'A' |-> {"Prof. Adams"},
 'S' |-> {"Prof. Scott", "Prof. Smith"}}.
\end{lstlisting}


\end{description}

\chapter{Bindings}\label{bind}

\begin{description}
\item[Syntax:]
  \Rule{bind}{
    \Ruleref{set bind} \dsepl \Ruleref{seq bind} \dsepl \Ruleref{type bind}
    }

  \Rule{set bind}{
    \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{seq bind}{
    \Ruleref{pattern}, \Lop{in seq}, \Ruleref{expression}
    }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{multiple bind}{
    \Ruleref{multiple set bind} \dsep
    \Ruleref{multiple seq bind} \dsep
    \Ruleref{multiple type bind}
    }

  \Rule{multiple set bind}{
    \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{multiple seq bind}{
    \Ruleref{pattern list}, \Lop{in seq}, \Ruleref{expression}
    }

  \Rule{multiple type bind}{
    \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it bind} matches a pattern to a value. In a {\it
    set bind} the value is chosen from the set defined by the set
    expression of the bind. In a {\it seq bind} the value is chosen from the sequence defined by the sequence expression of the bind. In a {\it type bind} the value is chosen
    from the type defined by the type expression.  {\it Multiple bind}
    is the same as {\it bind} except that several patterns are bound
    to the same set, sequence or type.  Notice that type binds {\bf can} only be
    executed by the VDM interpreters in case the type can be deduced
    to be finite statically.  This would require the VDM interpreters
    to search through infinite domains like the natural numbers.

\item[Examples:] Bindings are mainly used in quantified expressions and
  comprehensions which can be seen from these examples:
  \begin{lstlisting}
forall i, j in set inds list & i < j => list(i) <= list(j)

{ y | y in set S & y > 2 }

{ y | y: nat & y > 3 }

occurs : seq1 of char * seq1 of char -> bool
occurs (substr,str) ==
  exists i,j in set inds str & substr = str(i,...,j);
  \end{lstlisting}
\end{description}

\chapter{Value (Constant) Definitions} \label{valuedef}

The VDM languages supports the definition of constant
values. A value definition corresponds to a constant definition in
traditional programming languages.

\begin{description}
\item[Syntax:]
  \Rule{value definitions}{
    \Lop{values},
    \OptPt{\Ruleref{access value definition}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{access value definition}},
           \OptPt{\Lit{;}}}
    }

%  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       \OptPt{\Ruleref{access}},
         \Ruleref{value definition}
    }%}{}


  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

\item[Semantics:] The value definition has the form:
  \begin{lstlisting}
    values
      access pat1 = e1;
      !\ldots!
      access patn = en
  \end{lstlisting}
where the {\tt access} part only can be used in VDM++ and VDM-RT.

  The global values (defined in a value definition) can be referenced
  at all levels in a VDM specification.  However,
  in order to be able to execute a specification these
  values must be defined before they are used in the sequence of value
  definitions. This ``declaration before use'' principle is only used
  by the VDM interpreters for value definitions.
  Thus for instance functions can be used before they are declared. In
  standard VDM-SL there are not any restrictions on the order of the
  definitions at all. It is possible to provide a type restriction as
  well, and this can be useful in order to obtain more exact type
  information.

Details of the VDM++ and VDM-RT access specifiers
can be found in section \ref{ch:interface}.

\item[Examples:] The example below, taken from \cite{Fitzgerald&98}
  assigns token values to identifiers
  \texttt{p1} and \texttt{eid2}, an \texttt{Expert} record value to
  \texttt{e3} and an \texttt{Alarm} record value to \texttt{a1}.
\begin{lstlisting}
types

Period = token;
ExpertId = token;
Expert :: expertid : ExpertId
          quali : set of Qualification
inv ex == ex.quali <> {};
Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
Alarm :: alarmtext : seq of char
         quali : Qualification

values

public p1: Period = mk_token("Monday day");
private eid2 : ExpertId = mk_token(145);
protected e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{lstlisting}
  As this example shows, a value can depend on other values which are
  defined previous to itself. The access modifiers \keyw{private},
  \keyw{protected} and \keyw{public} can only be used in VDM++ and VDM-RT.
  A top-level VDM-SL specification can consist of
  specifications from a number of files or modules (see
  section~\ref{modules}).  It is good practice not to let a value depend
  on values defined in other modules as the ordering is important.
\end{description}

\chapter{Declaration of Modifiable State Components}\label{chap:state}

Syntactically the definition of state components that can be modified
using VDM operations differ in VDM-SL compared with VDM++ and
VDM-RT. Since VDM-SL is module based the state definition is similar
to a monolitic record like construct. On the other hand VDM++ and
VDM-RT are object-oriented and thus state components needs to be more
flexible in order to enable inheritence of such definitions and thus
they are defined in terms of instance variables. In the two sections
in this chapter the two different ways of defining states is presented.

\section{Instance Variables (VDM++ and VDM-RT)}
\label{sec:ivars}

Both an object instantiated from a class description and the class
itself can have an internal state, also called the \emph{instance
  variables} of the object or class. In the case of objects, we also
refer to this state as the global state of the object.

\begin{description}
\item[Syntax:]
  \Rule{instance variable definitions}{
    \Lop{instance}, \Lop{variables}, \lfeed
    \OptPt{\Ruleref{instance variable definition}, \lfeed
           \SeqPt{\Lit{;},
               \Ruleref{instance variable definition}
                 }
          }
  }


  \Rule{instance variable definition}{
    \Ruleref{access assignment definition} \dsep
    \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}}  \dsepl \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Rule{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
  \Ruleref{expression}}
  }
\Rule{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Rule{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

\item[Semantics:] The section describing the internal state is
preceded by the keyword {\bf\ttfamily instance variables}.  A list of instance
variable definitions and/or invariant definitions follows.  Each
instance variable definition consists of an instance variable name
with its corresponding type indication and may also include an
initial value and access and \keyw{static} specifiers. Details of the
access and \keyw{static} specifiers can be found in section
\ref{ch:interface}.

It is possible to restrict the values of the instance variables by
means of invariant definitions. Each invariant definition, involving
one or more instance variables, may be defined over the values of the
instance variables of objects of a class. All instance variables in
the class including those inherited from superclasses are visible in
the invariant expression. Each invariant definition must be a
boolean expression that limits the values of the instance variables to
those where the expression is true. All invariant expressions must be
true during the entire lifetime of each object of the class.

The overall invariant expression of a class is all the invariant
definitions of the class and its superclasses combined by logical
\keyw{and} in the order that they are defined in 1) the superclasses
and 2) the class itself.

%If a class contains one or more invariant definitions, an operation named
%{\tt inv\_classname} is implicitly constructed in the class.%
%\footnote{Not yet supported by the interpreter.}
% *****Check this for next version
%This operation is private, has no parameters and returns a boolean
%corresponding to the execution of the invariant expression.

\item[Example:]

The following examples show instance variable definitions. The first
class specifies one instance variable:
  \begin{lstlisting}
class GroupPhase

types

GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>;
Team = ... -- as on page !\pageref{scoredef}!
Score::team : Team
       won    : nat
       drawn  : nat
       lost   : nat
       points : nat;

instance variables
gps : map GroupName to set of Score;
inv forall gp in set rng gps &
      (card gp = 4 and
       forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)

end GroupPhase
  \end{lstlisting}
\end{description}

\section{The State Definition (VDM-SL)}\label{statedef}

If global variables are desired in a VDM-SL specification, it is possible to make
a state definition. The components of the state definition can be
considered the collection of global variables which can be referenced
inside operations. A state in a module is initialised before any of the
operation definitions (using that state) in a module can be used by
the VDM interpreters.

\begin{description}
\item[Syntax:]
  \Rule{state definition}{
    \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
    \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{initialisation}{
    \Lop{init}, \Ruleref{invariant initial function}
    }

  \Rule{invariant initial function}{
    \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}}

\item[Semantics:] The state definition has the form:
  \begin{lstlisting}
    state ident of
      id1 : type1
      !\ldots!
      idn : typen
    inv  pat1 == invpred
    init pat2 == initpred
    end
  \end{lstlisting}
  A state identifier {\tt idn} is declared of a specific type {\tt typen}.
  The invariant {\tt invpred} is a boolean expression denoting a
  property which must hold for the state {\tt ident} at all
  times. {\tt initpred} denotes a condition which must hold initially.
  It should be noticed that in order to use the
  VDM interpreters, it is
  necessary to have an initialisation predicate (if any of the
  operations using the state are to be executed). In addition the body of
  this initialisation predicate must be a binary equality expression with
  the name (which also must be used as the pattern) of the entire state on
  the left-hand side of the equality and the right-hand side must evaluate
  to a record value of the correct type. This enables the VDM interpreters
  to evaluate the {\tt initpred} condition. A simple example of an
  initialisation predicate is shown below:

  \begin{lstlisting}
  state St of
    x: nat
    y: nat
    l: seq1 of nat
  init s == s = mk_St(0,0,[1])
  end
  \end{lstlisting}

  In the specification of both the invariant and the initial value the
  state must be manipulated as a whole, and this is done by referring to it
  as a record tagged with the state name (see the example). When a field in
  the state is manipulated in some operation, the field must however be
  referenced directly by the field name without pre-fixing it with the
  state name.

\item[Examples:] In the following example we create one state variable:
  \begin{lstlisting}
types

GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

state GroupPhase of
  gps : map GroupName to set of Score
inv mk_GroupPhase(gps) ==
  forall gp in set rng gps &
    (card gp = 4 and
    forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)
init gp ==
  gp = mk_GroupPhase({<A> |-> init_sc({<Brazil>, <Norway>,
                                      <Morocco>, <Scotland>}),
                      ...})
end

functions

init_sc : set of Team -> set of Score
init_sc (ts) ==
  { mk_Score (t,0,0,0,0) | t in set ts }
  \end{lstlisting}
  In the invariant we state that each group has four teams, and no team
  plays more than three games. Initially no team has played any games.

\end{description}

\chapter{Operation Definitions} \label{op-def}

Operations have already been mentioned in chapter~\ref{algorithm}. The
general form is described here and for VDM++ and VDM-RT special
  operations called \emph{constructors} which are used for
  constructing instances of a class are described in
  section~\ref{constructors}. Note that the \keyw{async} keyword can
only be used in the VDM-RT dialect.

\begin{description}
\item[Syntax:]
  \Rule{operation definitions}{
    \Lop{operations},
    \OptPt{\Ruleref{access operation definition}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{access operation definition}} ,  \OptPt{\Lit{;}
    }}}

\Rule{access operation definition}{
    \SeqPt{
        \Lop{pure} \dsep
        \Lop{async} \dsep
        \Ruleref{access} \dsep
        \Lop{static}}, \lfeed
    \Ruleref{operation definition}
    }


\Rule{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }

\Rule{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
  }

\Rule{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Rule{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Rule{extended explicit operation definition}{
  \Ruleref{identifier}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}

\Rule{operation type}{
  \Ruleref{discretionary type}, \Lit{{\tt ==>}}, \Ruleref{discretionary type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{()}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{operation body}{
  \Ruleref{statement} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!operations}
  }

\Rule{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Rule{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Rule{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{name list}{
  \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
  }

\Rule{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Rule{error list}{
  \Ruleref{error}, \SeqPt{\Ruleref{error}}
  }

\Rule{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\item[Semantics:] Operations in VDM are by default synchronous but if
  the keyword ``\keyw{async}'' is used in VDM-RT in front of an
  operation definition it means that that operation will be treated as
  an asynchronous operation. This means that the operation cannot have
  a return type and the thread calling an asynchronous operation will
  continue its own execution after having requested the invocation of
  the asynchronous operation. Note that constructors cannot be
  declared asynchronous.

  % Pure operations
  If an operation is declared ``\keyw{pure}'' it means that it is
  executed atomically when it is called from a functional context
  (from functions, invariants, pre or post-conditions). Otherwise
  calling a pure operation is no different to calling a normal
  operation, except that a pure operation has various constraints. The
  constraints are as follows:

  \begin{itemize}
  \item A pure operation cannot update state
  \item A pure operation cannot call an impure operation
  \item A pure operation cannot have permission predicates
  \item An operation overriding a pure operation must also be pure
  \item History counters cannot be used for pure operations
  \item A mutex cannot refer to a pure operation
  \item A pure operation must return a value
  \item A pure operation cannot be declared \keyw{async} since an
    asynchronous operation is required to have \keyw{void} as return
    type.
  \item The body of a thread cannot be a pure operation
  \item It is not allowed to call \keyw{exit} in a pure operation
  \end{itemize}
  
  In both VDM++ and VDM-RT the details of the
  access and \keyw{static} specifiers can be found in section
  \ref{ch:interface}. Note that a static operation may not call
  non-static operations, and self expressions cannot be
  used in the definition of a static operation.

The following example of an explicit operation updates the VDM-SL
state \texttt{GroupPhase} and the VDM++ instance variables of class
\texttt{GroupPhase} when one team beats another.
\begin{lstlisting}
Win : Team * Team ==> ()
Win (wt,lt) ==
  let gp in set dom gps be st
       {wt,lt} subset {sc.team | sc in set gps(gp)}
  in gps := gps ++ { gp |->
                      {if sc.team = wt
                       then mu(sc, won |-> sc.won + 1,
                                   points |-> sc.points + 3)
                       elseif sc.team = lt
                       then mu(sc, lost |-> sc.lost + 1)
                       else sc
                  | sc in set gps(gp)}}
pre exists gp in set dom gps &
       {wt,lt} subset {sc.team | sc in set gps(gp)};
\end{lstlisting}
\label{winDef}
An explicit operation consists of a statement (or several composed
using a block statement), as described in chapter~\ref{sec:stmt}. The
statement may access any state/instance
variables it wishes, reading and writing to them as it sees fit.

An implicit operation is specified using an optional pre-condition,
and a mandatory post-condition. For example we could specify the
\texttt{Win} operation implicitly:
\begin{lstlisting}
Win (wt,lt: Team)
ext wr gps : map GroupName to set of Score
pre exists gp in set dom gps &
        {wt,lt} subset {sc.team | sc in set gps(gp)}
post exists gp in set dom gps &
       {wt,lt} subset {sc.team | sc in set gps(gp)}
       and gps = gps~ ++
                     { gp |->
                       {if sc.team = wt
                        then mu(sc, won |-> sc.won + 1,
                                   points |-> sc.points + 3)
                        elseif sc.team = lt
                        then mu(sc, lost |-> sc.lost + 1)
                        else sc
                   | sc in set gps(gp)}};
\end{lstlisting}

The externals field lists the state/instance
variables that the
operation will manipulate. The
state/instance
variables listed after the reserved
word \keyw{rd} can only be read whereas the operation can both read and
write the variables listed after \keyw{wr}.

In VDM-SL the presence of such pre- and post-conditions the VDM interpreters will also
create new functions as with the pre- and post-conditions of operation
definitions.  However, if a specification contains a global state, the
state is also part of the newly created functions. Thus, functions
with the following signatures are created for operations with pre-
and/or post-conditions\footnote{However, you should remember that
these pre and post condition predicates for an operation are simply
boolean functions and the state components are thus not changed by
calling such a predicate.}:
\begin{lstlisting}
  pre_Op : InType * State +> bool

  post_Op : InType * OutType * State * State +> bool
\end{lstlisting}
with the following exceptions:
\begin{itemize}
\item If the operation does not take any arguments, the {\tt InType} part
  of the signature is left out in both the {\tt \keyw{pre\_}Op} and {\tt
    \keyw{post\_}Op} signatures.

\item If the operation does not return a value, the {\tt OutType} part is
  left out in the {\tt \keyw{post\_}Op} signature.

\item If the specification does not define a state, the {\tt State} part(s)
  of both signatures are left out.
\end{itemize}

In the {\tt \keyw{post\_}Op} signature, the first {\tt State} part is for
the old state, whereas the second {\tt State} part is for the
state after the operation call.

For instance, consider the following specifications:

\begin{lstlisting}
module A

definitions

state St of
  n : nat
end

operations

Op1 (a : nat) b :nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end A
\end{lstlisting}

\begin{lstlisting}
module B

definitions

operations

Op1 (a : nat) b : nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end B
\end{lstlisting}

For \textbf{module A} we could then quote the pre and post conditions
defined in this specification as illustrated below

\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))
  & \texttt{a} bound to 1 in state \texttt{St} with \texttt{n}  bound to 2 \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & \texttt{a} bound to 1, \texttt{b} bound to 2, state before with
    \texttt{n} bound to 1, state after with \texttt{n} bound to 2 \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & \texttt{b} bound to 2, state before with \texttt{n} bound to 1, state
    after with \texttt{n} bound to 2 \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & state before with \texttt{n} bound to 1, state after with
    \texttt{n} bound to 2 \\
\hline
\end{tabular}

For \textbf{module B} we can quote the pre and post conditions defined
in this specification as illustrated below

\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} bound to 1 \\
\keyw{post}\_Op1(1,2)  & \texttt{a} bound to 1, \texttt{b} bound to 2\\
\keyw{post}\_Op2(2)    & \texttt{b} bound to 2\\
\keyw{post}\_Op3()     & No binding at all\\
\hline
\end{tabular}

\vspace{2ex}


The exceptions clause can be used to describe how an operation should
deal with error situations. The rationale for having the exception
clause is to give the user the ability to separate the exceptional
cases from the normal cases. The specification using exceptions does
not give any commitment as to how exceptions are to be signalled, but
it gives the means to show under which circumstances an error
situation can occur and what the consequences are for the result of
calling the operation.

The exception clause has the form:
\begin{lstlisting}
errs COND1: c1 -> r1
     !\ldots!
     CONDn: cn -> rn
\end{lstlisting}
The condition names {\tt COND1}, \ldots, {\tt CONDn} are identifiers
that describe the kind of error which can be raised\footnote{Notice
that these names are purely of mnemonic value, i.e.\ semantically they
are not important.}. The condition expressions {\tt c1}, \ldots, {\tt
cn} can be considered as pre-conditions for the different kinds of
errors. Thus, in these expressions the identifiers from the arguments
list and the variables from the externals list can be used (they have
the same scope as the pre-condition). The result expressions {\tt r1},
\ldots, {\tt rn} can correspondingly be considered as post-conditions
for the different kinds of errors. In these expressions the result
identifier and old values of global variables (which can be written
to) can also be used. Thus, the scope corresponds to the scope of the
post-condition.

An operation definition making use of an \keyw{errs} clause
essentially gets an effective pre-condition which is a disjunction of
the original pre-condition and all the condition expressions {\tt c1},
\ldots, {\tt cn}. The effective post-condition in these cases becomes
a disjunction of the conjuncts ({\tt orig\_pre \keyw{and} orig\_post)} and
the {\tt c1 \keyw{and} r1}, \ldots, {\tt cn \keyw{and} rn}.

Superficially there appears to be some redundancy between exceptions
and pre-conditions here. However there is a conceptual distinction
between them that dictates which should be used and when. The
pre-condition specifies what callers  to the operation must ensure for
correct behaviour; the exception clauses indicate that the operation
being specified takes responsibility for error handling when an
exception condition is satisfied. Hence normally exception clauses and
pre-conditions do not overlap.

The next VDM-SL example of an operation uses the following state definition:
\begin{lstlisting}
  state qsys of
    q : Queue
  end
\end{lstlisting}

The next VDM++/VDM-RT example of an operation uses the following
instance variable definition:
\begin{lstlisting}
  instance variables
    q : Queue
\end{lstlisting}

This example shows how exceptions with an implicit definition can be used:
\begin{lstlisting}
  DEQUEUE() e: [Elem]
  ext wr q : Queue
  post q~ = [e] ^ q
  errs QUEUE_EMPTY: q = [] -> q = q~ and e = nil
\end{lstlisting}

This is a dequeue operation which uses a global variable {\tt q} of
type {\tt Queue} to get an element {\tt e} of type {\tt Elem} out of
the queue. The exceptional case here is that the queue in
which the exception clause specifies how the operation should
behave is empty.

Note that the VDM interpreters for VDM-SL models create a function here:
\begin{lstlisting}
  post_DEQUEUE: [Elem] * qsys * qsys +> bool
\end{lstlisting}

\end{description}


\section{Constructors (VDM++ and VDM-RT)}\label{constructors}

Constructors are operations that have the same name as the class in
which they are defined and which create new instances of that
class. Their return type must therefore be the same class
name, and if a return value is specified this should be \keyw{self}
though this can optionally be omitted. Finally, since a constructor is used for initialising a new instance of a class, it is not permitted to declare a constructor \keyw{static}.

Multiple constructors can be defined in a single class using
operation overloading as described in section~\ref{sec:classdep}.


\chapter{Statements}\label{sec:stmt}

In this chapter the different kind of statements will be described
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\section{Let Statements}\label{letstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \Ruleref{let statement} \dsep
    \Ruleref{let be statement} \dsep
    \ldots
    }

  \Rule{let statement}{
    \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{statement}
    }

  \Rule{let be statement}{
    \Lop{let}, \Ruleref{multiple bind}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep \Ruleref{function definition}
    }

  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  where the ``function definition'' component is described in
  chapter~\ref{functiondef}.

\item[Semantics:] The {\it let statement} and the {\it let-be-such-that
    statement} are similar to the corresponding {\it let} and {\it
    let-be-such-that expressions} except that the {\it in} part is a
  statement instead of an expression. Thus it can be explained as follows:

  A simple {\it let statement} has the form:
  \begin{lstlisting}
    let p1 = e1, !\ldots!, pn = en in s
  \end{lstlisting}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding patterns {\tt pi}, and {\tt s}
  is a statement, of any type, involving the pattern identifiers of {\tt
    p1, \ldots, pn}. It denotes the evaluation of the statement {\tt s} in
  the context in which the patterns {\tt p1, \ldots, pn} are matched
  against the corresponding expressions {\tt e1, \ldots, en}.

  More advanced let statements can also be made by using local function
  definitions. The semantics of doing that is simply that the scope of such
  locally defined functions is restricted to the body of the let statement.

  A {\it let-be-such-that statement} has the form
  \begin{lstlisting}
    let mb be st e in s
  \end{lstlisting}
  where {\tt mb} is a multi-binding of one or more patterns (mostly
  just one pattern) to a set value (or a type), {\tt
    e} is a boolean expression, and {\tt s} is a statement, involving the
  pattern identifiers of the patterns from {\tt mb}. The {\tt \keyw{be st} e}
  part is optional. The expression denotes the evaluation of the statement
  {\tt s} in the context where all the patterns from {\tt mb} has been matched
  against an element in the set (or type) from {\tt mb}\footnote{Remember
    that only the set and sequence bindings can be executed by means of the
    VDM interpreters.}.
  If the \keyw{be st}
  expression {\tt e} is present, only such bindings where {\tt e} evaluates
  to true in the matching context are used.

\item[Examples:] An example of a \keyw{let be st} statement is provided in the
  operation \texttt{GroupWinner}
from the class \texttt{GroupPhase}
  which returns the winning team in a given group:
  \begin{lstlisting}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    let sc in set gps(gp) be st
        forall sc' in set} gps(gp) \ {sc} &
          (sc.points > sc'.points) or
          (sc.points = sc'.points and sc.won > sc'.won)
    in
      return sc.team
  \end{lstlisting}
  The companion operation \texttt{GroupRunnerUp} gives an example of a simple
  let statement as well:
  \begin{lstlisting}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    def t = GroupWinner(gp)
    in let sct = iota sc in set gps(gp) & sc.team = t
       in
         let sc in set gps(gp) \ {sct} be st
             forall sc' in set gps(gp) \ {sc,sct} &
             (sc.points > sc'.points) or
             (sc.points = sc'.points and sc.won > sc'.won)
         in
           return sc.team
  \end{lstlisting}
  Note the use of the {\bf\ttfamily def} statement (section~\ref{defstmt})
  here; this is used rather than a {\bf\ttfamily let} statement since the
  right-hand side is an operation call, and therefore is not an
  expression.

\end{description}

\section{The Define Statement}\label{defstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{def statement} \dsep \ldots
    }

  \Rule{def statement}{
    \Lop{def},
    \Ruleref{equals definition}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{equals definition}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{equals definition}{
    \Ruleref{pattern bind}, \Lit{=},
    \Ruleref{expression}}

\item[Semantics:] A {\it define statement} has the form:
  \begin{lstlisting}
    def pb1 = e1;
        !\ldots!
        pbn = en
    in
      s
  \end{lstlisting}
  The {\it define statement} corresponds to a {\it define expression}
  except that it is also allowed to use operation calls on the right-hand
  sides. Thus, operations that change the state can also be used here, and
  if there are more than one definition they are evaluated in the order in
  which they are presented.  It denotes the evaluation of the statement
  {\tt s} in the context in which the patterns (or binds) {\tt pb1, \ldots,
    pbn} are matched against the values returned by the corresponding
  expressions or operation calls {\tt e1, \ldots, en}\footnote{If binds are
    used it simply means that the values which can match the pattern are
    further constrained by the type or set expression as it is explained in
    section~\ref{patterns}.}.

\item[Examples:] Given the following sequences:
  \begin{lstlisting}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{lstlisting}
  The operation \texttt{SecondRound}, in VDM++ from class \texttt{GroupPhase}
  returns the sequence of pairs
  representing the second round games gives an example of a \keyw{def}
  statement:
  \begin{lstlisting}
SecondRound : () ==> seq of (Team * Team)
SecondRound () ==
  def winners = { gp |-> GroupWinner(gp)
                | gp in set dom gps };
      runners_up = { gp |-> GroupRunnerUp(gp)
                   | gp in set dom gps}
  in
    return ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i)))
            | i in set {1,...,8}])
  \end{lstlisting}

\end{description}

\section{The Block Statement} \label{dcl-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{block statement} \dsep \ldots
    }

  \Rule{block statement}{
    \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
    \Ruleref{statement}, \SeqPt{\Lit{;}, \Ruleref{statement}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl statement}{
    \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
    }

  \Rule{assignment definition}{
    \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression}}}

\item[Semantics:] The {\it block statement} corresponds to block statements
  from traditional high-level imperative
programming languages.  It enables the use of
  locally defined variables (by means of the declare statement) which can
  be modified inside the body of the block statement. It simply denotes the
  ordered execution of what the individual statements prescribe. The first
  statement in the sequence that returns a value causes the evaluation of
  the sequence statement to terminate. This value is returned as the
  value of the block statement. If none of the statements in the block
  returns a value, the evaluation of the block statement is terminated when
  the last statement in the block has been evaluated. When the block
  statement is left the values of the local variables are discharged. Thus,
  the scope of these variables is simply inside the block statement.

\item[Examples:] In the context of a VDM-SL
state definition
  \begin{lstlisting}
  state St of
    x: nat
    y: nat
    l: seq1 of nat
  end
  \end{lstlisting}
or in the context of a VDM++ instance variables
  \begin{lstlisting}
  instance variables
    x: nat;
    y: nat;
    l: seq1 of nat;
  \end{lstlisting}
\label{stdef}
  the operation \texttt{Swap} uses a block statement to swap the values of 
  variables \texttt{x} and \texttt{y}:
  \begin{lstlisting}
  Swap : () ==> ()
  Swap () ==
    (dcl temp: nat := x;
     x := y;
     y := temp
    )
  \end{lstlisting}
\end{description}

\section{The Assignment Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{general assign statement} \dsep
    \ldots
    }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
%}%
%{}

\Rule{assign statement}{
  \Ruleref{state designator}, \Lit{:=},
    \Ruleref{expression}
  }

  \Rule{state designator}{
    \Ruleref{name} \dsep
    \Ruleref{field reference} \dsep
    \Ruleref{map or sequence reference}
    }

  \Rule{field reference}{
    \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
    }


   \Rule{map or sequence reference}{
     \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
     }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{multiple assign statement}{
    \Lop{atomic},
    \Lit{(},
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{assign statement}},
    \Lit{)}
    }
%  }%
%{}

\item[Semantics:] The {\it assignment statement} corresponds to a
  generalisation of assignment statements from traditional high level
  programming languages. It is used to change the value of the global or
  local state. Thus, the assignment statement has side-effects on the
  state. However, in order to be able to simply change a part of the state,
  the left-hand side of the assignment can be a state designator. A state
  designator is either simply the name of a variable, a reference to
  a field of a variable, a map reference of a variable, or a sequence
  reference of a variable. In this way it is possible to change the value
  of a small component of the state. For example, if a state component is a
  map, it is possible to change a single entry in the map.

  An assignment statement has the form:
  \begin{lstlisting}
    sd := ec
  \end{lstlisting}
  where {\tt sd} is a state designator, and {\tt ec} is either an
  expression or a call of an operation. The assignment statement denotes the
  change to the given state component described at the right-hand side
  (expression or operation call). If the right-hand side is a state
  changing operation then that operation is executed (with the
  corresponding side effect) before the assignment is made.


  Multiple assignment is also possible. This has the form:
  \begin{lstlisting}
    atomic (sd1 := ec1;
            ...;
            sdN := ecN
           )
  \end{lstlisting}
  All of the expressions or operation calls on the right hand sides
  are executed or evaluated, and then the results are bound to the
  corresponding state designators. The right-hand sides are executed
  in the order given in the statement, and normal invariant processing
  and thread switching and statement durations can occur. But once all
  of the right-hand values have been obtained, they are assigned to the
  left-hand variables in one atomic step, which occurs without invariant
  checking, thread switching or extra duration. Given the types \texttt{T1,...,TN} of the respective state designators \texttt{sd1,...,sdN} it is as if the
  \keyw{atomic} statement is evaluated as follows:
  \begin{lstlisting}
    let t1 : T1 = ec1,
        ...
        tN : TN = ecN in
    (
        -- turn off invariants, threading and durations
        sd1 := t1;
        ...
        sdN := tN;
        -- turn on invariants, threading and durations
        -- and check that invariants hold.
    );
  \end{lstlisting}


\item[Examples:] The operation in the previous example (\texttt{Swap})
  illustrated normal assignment. The operation \texttt{Win\_sd}, a
  refinement of \texttt{Win} on page~\pageref{winDef} illustrates the use of
  state designators to assign to a specific map key:
  \begin{lstlisting}
Win_sd : Team * Team ==> ()
Win_sd (wt,lt) ==
  let gp in set dom gps be st
      {wt,lt} subset {sc.team | sc in set gps(gp)}
  in
    gps(gp) := { if sc.team = wt
                 then mu(sc, won |-> sc.won + 1,
                             points |-> sc.points + 3)
                 elseif sc.team = lt
                 then mu(sc, lost |-> sc.lost + 1)
                 else} sc
               | sc in set gps(gp)}
pre exists gp in set dom gps &
               {wt,lt} subset {sc.team | sc in set gps(gp)}
  \end{lstlisting}
  The operation \texttt{SelectionSort} is a state based version of the
  function \texttt{selection\_sort} on page \pageref{selectionSortdef}. It 
  demonstrates the use of state designators to modify the contents of a
  specific sequence index, using the VDM-SL
state \texttt{St} or the VDM++
instance variables
 defined on page~\pageref{stdef}.
  \begin{lstlisting}
functions

min_index : seq1 of nat -> nat
min_index(l) ==
  if len l = 1
  then 1
  else let mi = min_index(tl l)
       in if l(mi+1) < hd l
          then mi+1
          else 1

operations

SelectionSort : nat ==> ()
SelectionSort (i) ==
  if i < len l
  then (dcl temp: nat;
        dcl mi : nat := min_index(l(i,...,len l)) + i - 1;
        temp := l(mi);
        l(mi) := l(i);
        l(i) := temp;
        SelectionSort(i+1)
       );
  \end{lstlisting}

  The following VDM++ example illustrates multiple assignment.
  \begin{lstlisting}
class C

instance variables
size : nat;
l : seq of nat;
inv size = len l

operations
add1 : nat ==> ()
add1 (x) ==
( l := [x] ^ l;
  size := size + 1);

add2 : nat ==> ()
add2 (x) ==
  atomic (l := [x] ^ l;
          size := size + 1)

end C
  \end{lstlisting}
Here, in \texttt{add1} the invariant on the class's instance variables
is broken, whereas in \texttt{add2} using the multiple assignment, the
invariant is preserved.

\end{description}

\section{Conditional Statements}\label{condstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{if statement} \dsep
    \Ruleref{cases statement} \dsep \ldots
    }

  \Rule{if statement}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
    \SeqPt{\Ruleref{elseif statement}}, \OptPt{\Lop{else}, \Ruleref{statement}}
    }

  \Rule{elseif statement}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
    }

  \Rule{cases statement}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases statement alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
    }

  \Rule{cases statement alternatives}{
    \Ruleref{cases statement alternative}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
    }

  \Rule{cases statement alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
    }

  \Rule{others statement}{
    \Lop{others}, \Lit{->}, \Ruleref{statement}
    }

\item[Semantics:] The semantics of the {\it if statement} corresponds to
  the {\it if expression} described in section~\ref{if-exp} except for the
  alternatives which are statements (and that the \keyw{else} part is
  optional)\footnote{If the \keyw{else} part is omitted
  semantically it is like using \keyw{else skip}.}.

  The semantics for the {\it cases statement} corresponds
  to the {\it cases expression} described in section~\ref{cases-exp} except
  for the alternatives which are statements.

\item[Examples:] Assuming functions \texttt{clear\_winner} and
  \texttt{winner\_by\_more\_wins} and operation \texttt{RandomElement}
  with the following signatures:
  \begin{lstlisting}
    clear_winner : set of Score -> bool
    winner_by_more_wins : set of Score -> bool
    RandomElement : set of Team ==> Team
  \end{lstlisting}
  then the operation \texttt{GroupWinner\_if} demonstrates the use of a
  nested if statement (the iota expression is presented on page
  \pageref{iotaexpr}):
  \begin{lstlisting}
GroupWinner_if : GroupName ==> Team
GroupWinner_if (gp) ==
  if clear_winner(gps(gp))
  -- return unique score in gps(gp) which has more points
  -- than any other score
  then return ((iota sc in set gps(gp) &
                 forall sc' in set gps(gp) \ {sc} &
                   sc.points > sc'.points).team)
  elseif winner_by_more_wins(gps(gp))
  -- return unique score in gps(gp) with maximal points
  -- & has won more than other scores with maximal points
  then return ((iota sc in set gps(gp) &
            forall sc' in set gps(gp) \ {sc} &
              (sc.points > sc'.points) or
              (sc.points = sc'.points and
               sc.won > sc'.won)).team)
  -- no outright winner, so choose random score
  -- from joint top scores
  else RandomElement ( {sc.team | sc in set gps(gp) &
                          forall sc' in set gps(gp) &
                          sc'.points <= sc.points} );
  \end{lstlisting}
  Alternatively, we could use a cases statement with match value patterns for
  this operation:
  \begin{lstlisting}
GroupWinner_cases : GroupName ==> Team
GroupWinner_cases (gp) ==
  cases true:
    (clear_winner(gps(gp))) ->
         return ((iota sc in set gps(gp) &
                   forall sc' in set gps(gp) \ {sc} &
                    sc.points > sc'.points).team),
    (winner_by_more_wins(gps(gp))) ->
         return ((iota sc in set gps(gp) &
                   forall sc' in set gps(gp) \ {sc} &
                     (sc.points > sc'.points) or
                     (sc.points = sc'.points and
                        sc.won > sc'.won)).team),
    others -> RandomElement ( {sc.team | sc in set gps(gp) &
                                forall sc' in set gps(gp) &
                                 sc'.points <= sc.points} )
  end
  \end{lstlisting}

\end{description}

\section{For-Loop Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{sequence for loop} \dsep
    \Ruleref{set for loop} \dsep
    \Ruleref{index for loop} \dsep \ldots
    }

  \Rule{sequence for loop}{
    \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
    \Ruleref{expression}, \lfeed
    \Lop{do}, \Ruleref{statement}
    }\index{for loop}

  \Rule{set for loop}{
    \Lop{for}, \Lop{all}, \Ruleref{pattern},
    \Lit{\keyw{in set}}, \Ruleref{expression},\lfeed
    \Lop{do}, \Ruleref{statement}
    }

  \Rule{index for loop}{
    \Lop{for}, \Ruleref{identifier}, \Lit{$=$}, \Ruleref{expression},
    \Lop{to}, \Ruleref{expression}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{expression}}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] There are three kinds of {\it for-loop statements}. The
  for-loop using an index is known from most high-level programming
  languages. In addition, there are two for-loops for traversing sets and
  sequences. These are especially useful if access to all
  elements from a set (or sequence) is needed one by one.

  An {\it index for-loop statement} has the form:
  \begin{lstlisting}
    for id = e1 to e2 by e3 do
    s
  \end{lstlisting}
  where {\tt id} is an identifier, {\tt e1} and {\tt e2} are integer
  expressions indicating the lower and upper bounds for the loop, {\tt e3}
  is an integer expression indicating the step size, and {\tt s} is a
  statement where the identifier {\tt id} can be used. It denotes the
  evaluation of the statement {\tt s} as a sequence statement where the
  current context is extended with a binding of {\tt id}. Thus, the first
  time {\tt s} is evaluated {\tt id} is bound to the value returned from
  the evaluation of the lower bound {\tt e1} and so forth until the upper
  bound is reached i.e.\ until \texttt{s} $>$ \texttt{e2}. Note that
  {\tt e1, e2} and {\tt e3} are evaluated before entering the loop.

  A {\it set for-loop statement\/} has the form:
  \begin{lstlisting}
    for all e in set S do
    s
  \end{lstlisting}
  where {\tt S} is a set expression. The statement {\tt s} is evaluated in
  the current environment extended with a binding of e to subsequent values
  from the set {\tt S}.

  A {\it sequence for-loop statement\/} has the form:
  \begin{lstlisting}
    for e in l do
    s
  \end{lstlisting}
  where {\tt l} is a sequence expression. The statement {\tt s} is
  evaluated in the current environment extended with a binding of e to
  subsequent values from the sequence {\tt l}.

\item[Examples:] The operation \texttt{Remove} demonstrates the use of a
  \textit{sequence-for} loop to remove all occurences of a given number from a
  sequence of numbers:
  \begin{lstlisting}
  Remove : (seq of nat) * nat ==> seq of nat
  Remove (k,z) ==
  (dcl nk : seq of nat := [];
   for elem in k do
     if elem <> z
     then nk := nk^[elem];
   return nk
  );
  \end{lstlisting}
\label{removeDef}
  A \textit{set-for} loop can be exploited to return the set of winners of 
  all groups:
  \begin{lstlisting}
  GroupWinners: () ==> set of Team
  GroupWinners () ==
  (dcl winners : set of Team := {};
   for all gp in set dom gps do
     (dcl winner: Team := GroupWinner(gp);
      winners := winners union {winner}
     );
   return winners
   );
  \end{lstlisting}
  An example of a \textit{index-for} loop is the classic bubblesort
  algorithm:
  \begin{lstlisting}
  BubbleSort : seq of nat ==> seq of nat
  BubbleSort (k) ==
    (dcl sorted_list : seq of nat := k;
     for i = len k to 1 by -1 do
       for j = 1 to i-1 do
         if sorted_list(j) > sorted_list(j+1)
         then (dcl temp:nat := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     return sorted_list
     )
\end{lstlisting}
\end{description}

\section{The While-Loop Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{while loop} \dsep \ldots
    }

  \Rule{while loop}{
    \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] The semantics for the {\it while statement} corresponds
  to the while statement from traditional programming languages. The form
  of a {\it while loop\/} is:
  \begin{lstlisting}
    while e do
      s
  \end{lstlisting}
  where {\tt e} is a boolean expression and {\tt s} a statement. As long as
  the expression {\tt e} evaluates to \keyw{true} the body statement {\tt
    s} is evaluated.

\item[Examples:] The {\it while loop} can be illustrated by the following
  example which uses Newton's method to approximate the square root of
  a real number \texttt{r} within relative error \texttt{e}.
  \begin{lstlisting}
  SquareRoot : real * real ==> real
  SquareRoot (r,e) ==
    (dcl x:real := 1,
         nextx: real := r;
     while abs (x - nextx) >= e * x do
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     return nextx
    );
  \end{lstlisting}
\label{squarerootDef}
\end{description}

\section{The Nondeterministic Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{nondeterministic statement} \dsep \ldots
    }

  \Rule{nondeterministic statement}{
    \Lit{||}, \Lit{(}, \Ruleref{statement},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
    }

\item[Semantics:] The {\it nondeterministic statement} has the form:
  \begin{lstlisting}
    || (stmt1, stmt2, !\ldots!, stmtn)
  \end{lstlisting}
  and it represents the execution of the component statements {\tt
    stmti} in an arbitrary (non-deterministic)
  order. However, it
  should be noted that the component statements are not executed
  simultaneously. Notice that the VDM interpreters will use an
  underdetermined\footnote{Even though the
    user of the VDM interpreters does not know
    the order in which these statements are executed they are always
    executed in the same order unless the seed option is used.} semantics even though this construct
  is called a non-deterministic statement.

\item[Examples:] Using the VDM-SL
state definition
  \begin{lstlisting}
  state St of
    x:nat
    y:nat
    l:seq1 of nat
  end
  \end{lstlisting}
or the VDM++ instance variables
  \begin{lstlisting}
  instance variables
    x:nat;
    y:nat;
    l:seq1 of nat;
  \end{lstlisting}
  we can use the non-deterministic statement to effect a bubble sort:
  \begin{lstlisting}
  Sort: () ==> ()
  Sort () ==
    while x < y do
      ||(BubbleMin(), BubbleMax());
  \end{lstlisting}
\label{sortDef}
  Here \texttt{BubbleMin} ``bubbles'' the minimum value in the
  subsequence \texttt{l(x,...,y)} to the head of the subsequence and
  \texttt{BubbleMax} ``bubbles'' the maximum value in the subsequence
  \texttt{l(x,...,y)} to the last index in the
  subsequence. \texttt{BubbleMin} works by first iterating through the
  subsequence to find the index of the minimum value. The contents of
  this index are then swapped with the contents of the head of the
  list, \texttt{l(x)}.
  \begin{lstlisting}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (dcl z:nat := x;
     dcl m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     for i = x to y do
       if l(i) < m
       then ( m := l(i);
              z := i);
     -- move min val to index x
     (dcl temp:nat;
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{lstlisting}
\texttt{BubbleMax} operates in a similar fashion. It iterates through the
  subsequence to find the index of the maximum value, then swaps the
  contents of this index with the contents of the last element of the
  subsequence.
\begin{lstlisting}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (dcl z:nat := x;
     dcl m:nat := l(z);
     -- find max val in l(x..y)
     for i = x to y do
       if l(i) > m
       then ( m := l(i);
              z := i);
     -- move max val to index y
     (dcl temp:nat;
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{lstlisting}
\end{description}

\section{The Call Statement}
\label{call-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{call statement} \dsep \ldots
    }
For VDM-SL call statements are defined as:

  \Rule{call statement}{
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }
For VDM++ and VDM-RT call statements are defined as:

  \Rule{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},
    name, \lfeed
    \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)},
    }
  \Rule{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
   \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Rule{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Rule{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\item[Semantics:] In VDM-SL the {\it call statement} has the form:
  \begin{lstlisting}
opname(param1, param2, !\ldots!, paramn)
  \end{lstlisting}

In VDM++ and VDM-RT the {\it call statement} can additionally have the form:
  \begin{lstlisting}
object.opname(param1, param2, !\ldots!, paramn)
  \end{lstlisting}

  The {\it call statement} calls an operation, {\tt opname}, %
(in a VDM++ and VDM-RT context it can also be on a specific object, {\tt object}),
and returns the result of
  evaluating the operation. Because operations can manipulate global
  variables a {\it call statement} does not necessarily have to return
  a value as function call do.

  In VDM++ and VDM-RT if an {\emph{object designator}} is specified
  it must yield an object reference to an object of a class in which
  the operation {\tt opname} is defined, and then the operation must
  be specified as public. If no \emph{object designator} is specified
  the operation will be called in the current object. If the operation
  is defined in a superclass, it must have been defined as public or
  protected.

\item[Examples:] \mbox{}
  In VDM-SL the operation {\tt ResetStack} given below does not
  have any parameter and does not return a value whereas the operation {\tt
    PopStack} returns the top element of the stack.
  \begin{lstlisting}
    ResetStack();
    ...
    top := PopStack();
  \end{lstlisting}
  where {\tt PopStack} could be defined as:
  \begin{lstlisting}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack
  \end{lstlisting}
  where {\tt stack} is a global variable.

  In VDM++ and VDM-RT this {\tt Stack} example can be made like:

  \begin{lstlisting}
  class Stack

  instance variables
    stack: seq of Elem := [];

  operations

    public Reset: () ==> ()
    Reset() ==
      stack := [];

    public Pop: () ==> Elem
    Pop() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack

  end Stack
  \end{lstlisting}

  In the example the operation {\tt Reset} does not have any parameters
  and does not return a value whereas the operation {\tt Pop} returns
  the top element of the stack. The stack could be used as follows:
  \begin{lstlisting}
    ( dcl stack := new Stack();
      stack.Reset();
      ....
      top := stack.Pop();
    )
  \end{lstlisting}

  Inside class {\tt Stack} the operations can be called as shown below:
  \begin{lstlisting}
    Reset();
    ....
    top := Pop();
  \end{lstlisting}

  Or using the \keyw{self}\index{self expressions} reference:
  \begin{lstlisting}
    self.Reset();
    top := self.Pop();
  \end{lstlisting}
\end{description}

\section{The Return Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{return statement} \dsep \ldots
    }

  \Rule{return statement}{
    \Lop{return}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The {\it return statement} returns the value of an
  expression inside an operation. The value is evaluated in the given
  context. If an operation does not return a value, the expression must be
  omitted. A {\it return statement\/} has the form:
  \begin{lstlisting}
    return e
  \end{lstlisting}
  or
  \begin{lstlisting}
    return
  \end{lstlisting}
  where expression {\tt e} is the return value of the operation.

\item[Examples:] In the following example {\tt OpCall} is an operation call
  whereas {\tt FunCall} is a function call. As the {\it if statement\/}
  only accepts statements in the two branches {\tt FunCall} is
  ``converted'' to a statement by using the {\it return statement}.
  \begin{lstlisting}
    if test
    then OpCall()
    else return FunCall()
  \end{lstlisting}
  For instance in VDM++, we can extend the \texttt{stack} class from the
  previous section with an operation which examines the top of the
  stack:
\begin{lstlisting}
public Top : () ==> Elem
Top() ==
  return (hd stack)
pre stack <> [];
\end{lstlisting}
\end{description}

\section{Exception Handling Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{always statement} \dsep
    \Ruleref{trap statement} \dsep
    \Ruleref{recursive trap statement} \dsep
    \Ruleref{exit statement} \dsep \ldots
    }

  \Rule{always statement}{
    \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{trap statement}{
    \Lop{trap}, \Ruleref{pattern bind}, \Lop{with},
    \Ruleref{statement}, \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{recursive trap statement}{
    \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{traps}{
    \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement} },
    \Lit{\}}
    }

  \Rule{exit statement}{
    \Lop{exit}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The exception handling statements are used to control
  exception errors in a specification. This means that we have to be
  able to signal an exception within a specification. This can be done with
  the {\it exit statement}, and has the form:
  \begin{lstlisting}
    exit e
  \end{lstlisting}
  or
  \begin{lstlisting}
    exit
  \end{lstlisting}
  where {\tt e} is an expression which is optional. The expression {\tt e}
  can be used to signal what kind of exception is raised.

  The {\it always statement\/} has the form:
  \begin{lstlisting}
    always s1 in
    s2
  \end{lstlisting}
  where {\tt s1} and {\tt s2} are statements. First statement {\tt s2} is
  evaluated, and regardless of any exceptions raised, statement {\tt s1} is
  also evaluated. The result value of the complete {\it always statement\/}
  is determined by the evaluation of statement {\tt s1}: if this raises an
  exception, this value is returned, otherwise the result of the evaluation
  of statement {\tt s2} is returned.

  The {\it trap statement\/} only evaluates the handler statement,
{\tt s1}, when certain conditions are fulfilled. It has the form:
\begin{lstlisting}
    trap pat with s1 in s2
\end{lstlisting}
where {\tt pat} is a pattern or bind used to select certain
exceptions, {\tt s1} and {\tt s2} are statements. First, we evaluate
statement {\tt s2}, and if no exception is raised, the result value of
the complete {\it trap statement\/} is the result of the evaluation of
{\tt s2}. If an exception is raised, the value of {\tt s2} is matched
against the pattern {\tt pat}. If there is no matching, the exception
is returned as result of the complete {\it trap statement}, otherwise,
statement {\tt s1} is evaluated and the result of this evaluation is
also the result of the complete {\it trap statement}.

  The {\it recursive trap statement\/} has the form:
  \begin{lstlisting}
    tixe {
      pat1 |-> s1,
      ...
      patn |-> sn
    } in s
  \end{lstlisting}
  where {\tt pat1, \ldots, patn} are patterns or binds, {\tt s, s1, \ldots,
    sn} are statements. First, statement {\tt s} is evaluated, and if no
  exception is raised, the result is returned as the result of the complete
  {\it recursive trap statement}. Otherwise, the value is matched in order
  against each of the patterns {\tt pati}. When a match cannot be found,
  the exception is returned as the result of the {\it recursive trap
    statement}. If a match is found, the corresponding statement {\tt
    si} is evaluated. If this does not raise an exception, the result value
  of the evaluation of {\tt si} is returned as the result of the {\it
    recursive trap statement}. Otherwise, the matching starts again, now
  with the new exception value (the result of the evaluation of {\tt si}).

\item[Examples:] In many programs, we need to allocate memory for a
  single operation. After the operation is completed, the memory is not
  needed anymore. This can be done with the {\it always statement}:
  \begin{lstlisting}
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    )
  \end{lstlisting}
  In the above example, we cannot act upon a possible exception raised
  within the body statement of the {\it always statement}. By using the
  {\it trap statement\/} we can catch these exceptions:
  \begin{lstlisting}
    trap pat with ErrorAction(pat) in
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    )
  \end{lstlisting}
  Now all exceptions raised within the {\it always statement\/} are
  captured by the {\it trap statement}. If we want to distinguish between
  several exception values, we can use either nested {\it trap
    statements\/} or the {\it recursive trap statement}:
  \begin{lstlisting}
    DoCommand : () ==> int
    DoCommand () ==
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    );

    Example : () ==> int
    Example () ==
    tixe
    { <NOMEM> |-> return -1,
      <BUSY>  |-> DoCommand(),
      err     |-> return -2 }
    in
      DoCommand()
  \end{lstlisting}
  In operation {\tt DoCommand} we use the {\it always statement\/} in the
  allocation of memory, and all exceptions raised are captured by the {\it
    recursive trap statement\/} in operation {\tt Example}. An exception
  with value {\tt <NOMEM>} results in a return value of {\tt -1} and no
  exception raised. If the value of the exception is {\tt <BUSY>} we try to
  perform the operation {\tt DoCommand} again. If this raises an exception,
  this is also handled by the {\it recursive trap statement}. All other
  exceptions result in the return of the value {\tt -2}.
\end{description}

\section{The Error Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{error statement} \dsep
    \ldots
    }

  \Rule{error statement}{
    \Lop{error}
    }

\item[Semantics:] The {\it error statement} corresponds to the
undefined expression. It is used to state explicitly that the result
of a statement is undefined and because of this an error has occurred.
When an {\it error statement} is evaluated the
VDM interpreters will
terminate the execution of the specification and report that an {\it
error statement} was evaluated.

  Pragmatically use of error statements differs from
  pre-conditions as was the case with undefined expressions: use of a
  pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the operation is called; if an error statement is used it is the
  called operation's responsibility to deal with error handling.


\item[Examples:] The operation \texttt{SquareRoot} on page
  \pageref{squarerootDef} does not exclude
  the possibility that the number to be square rooted might be
  negative. If we do not wish this to be a pre-condition we can
remedy this in the operation \texttt{SquareRootErr}:
  \begin{lstlisting}
  SquareRootErr : real * real ==> real
  SquareRootErr (r,e) ==
    if r < 0
    then error
    else
      (dcl x:real := 1;
       dcl nextx:real := r;
       while abs (x - nextx) >= e * x do
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       return nextx
      )
  \end{lstlisting}
\end{description}

\section{The Identity Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{identity statement}
    }

  \Rule{identity statement}{
    \Lop{skip}
    }

\item[Semantics:] The {\it identity statement\/} is used to signal that no
  evaluation takes place.

\item[Examples:] In the operation \texttt{Remove} in section
  \ref{removeDef} the behaviour of the operation within the
  \keyw{for} loop if \texttt{elem=z} is not explicitly
  stated. \texttt{Remove2} below does this.
  \begin{lstlisting}
  Remove2 : (seq of nat) * nat ==> seq of nat
  Remove2 (k,z) ==
    (dcl nk : seq of nat := [];
     for elem in k do
       if elem <> z
       then nk := nk^[elem]
       else skip;
     return nk
    );
  \end{lstlisting}
  Here, we explicitly included the \keyw{else}-branch to illustrate the
  {\it identity statement}, however, in most cases the \keyw{else}-branch
  will not be included and the {\it identity statement\/} is implicitly
  assumed.

\end{description}

\section{Start and Start List Statements (VDM++ and VDM-RT)}\label{sec:start}
\label{sc:startstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{start statement} \dsep
    \Ruleref{start list statement}
    }

  \Rule{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

  \Rule{start list statement}{
    \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The {\it start} and {\it start list} statements have
the form:
  \begin{lstlisting}
    start(aRef)
    startlist(aRef_s)
  \end{lstlisting}

If a class description includes a thread (see
chapter~\ref{ch:thread}), each object created from this class will
have the ability to operate as a stand-alone virtual machine, or in
other terms: the object has its own processing capability.  In this
situation, a {\it new expression} creates the `process' leaving it in
a waiting state.  For such objects VDM++ and VDM-RT has a mechanism to change
the waiting state into an active state\footnote{When an object is in
an active state, its behaviour can be described using a thread (see
chapter~\ref{ch:thread}).}  in terms of a predefined operation, which
can be invoked through a {\it start statement}.

The explicit separation of object creation and start provides the
possibility to complete the initialisation of a (concurrent) system
{\it before} the objects start exhibiting their described behaviour,
in this way avoiding problems that may arise when objects are referred
to that are not yet created and/or connected.

A syntactic variant of the start statement is available to start up a
number of active objects in arbitrary order: the {\it start list
statement}. The parameter {\tt aRef\_s} to \keyw{startlist} must be a
set of object references to objects instantiated from classes
containing a thread.

\item[Examples:]
Consider the specification of an operating system. A component of this
would be the daemons and other processes started up during the boot
sequence. From this perspective, the following definitions are
relevant:
\begin{lstlisting}
  types

    runLevel = nat;

    Process = Kerneld | Ftpd | Syslogd | Lpd | Httpd

  instance variables
    pInit : map runLevel to set of Process
\end{lstlisting}
where \texttt{Kerneld} is an object reference type specified
elsewhere, and similarly for the other processes listed.

We can then model the boot sequence as an operation:
\begin{lstlisting}
bootSequence : runLevel ==> ()
bootSequence(rl) ==
  for all p in set pInit(rl) do
    start(p);
\end{lstlisting}
Alternatively we could use the \keyw{startlist} statement here:
\begin{lstlisting}
bootSequenceList : runLevel ==> ()
bootSequenceList(rl) ==
  startlist(pInit(rl))
\end{lstlisting}
\end{description}

\section{Stop and Stop List Statements (VDM++ and VDM-RT)}\label{sec:stop}
\label{sc:stopstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{stop statement} \dsep
    \Ruleref{stop list statement}
    }

  \Rule{stop statement}{
    \Lop{stop}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

  \Rule{stop list statement}{
    \Lop{stoplist}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The {\it stop} and {\it stop list} statements have the following form:
  \begin{lstlisting}
    stop(aRef)
    stoplist(aRef_s)
  \end{lstlisting}
\end{description}

The stop statement can be used to terminate a thread or to prevent a periodic thread from being invoked again, whereby a thread is identified by the object reference \emph{aRef}. The stop list statement is available to stop a number of active objects, in arbitrary order. The parameter {\tt aRef\_s} to \keyw{stoplist} must be a set of object references. A few additional remarks can be made:

\begin{enumerate}
\item \Lop{self} can be passed as an argument to \texttt{stop} or \texttt{stoplist}, effectively killing the current thread
\item Note that \emph{thread identifiers} can \emph{not} be passed as an argument
\item in contrast to \texttt{start} and \texttt{startlist}, \texttt{stop} and \texttt{stoplist} will block until the thread(s), identified by their object identifiers that are passed as an argument, are dead; if \Lop{self} is part of the set, it will be stopped last
\item passing the object identifier of a task that has never been started or is already dead, will yield a run-time error
\item  objects can be restarted by calling \texttt{start} and \texttt{startlist} again, which will create a fresh and unique \emph{thread identifier} for each thread.
\item it is only possible to stop threads that are running on the same CPU
\end{enumerate}

\section{The Specification Statement} \label{se:specification}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{specification statement}
    }
  \Rule{specification statement}{
    \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }

\item[Semantics:]

The specification statement can be used to describe a desired effect a
statement in terms of a pre- and a post-condition. Thus, it captures
the abstraction of a statement, permitting it to have an abstract
(implicit) specification without being forced to an operation
definition. The specification statement is equivalent with the body of
an implicitly defined operation (see chapter~\ref{op-def}). Thus
specification statements can not be executed.

\item[Examples:] We can use a specification statement to specify a
  bubble maximum part of a bubble sort:
\begin{lstlisting}
Sort2 : () ==> ()
Sort2 () ==
  while x < y do
    || (BubbleMin(),
        [ext wr l : seq1 of nat
             wr y : nat
             rd x : nat
         pre x < y
         post y < y~ and
              permutation(l~(x,...,y~),l(x,...,y~)) and
              forall i in set {x,...,y} & l(i) < l(y~)]
       )
\end{lstlisting}
  (\texttt{permutation} is an auxiliary function taking two sequences
  which returns true iff one sequence is a permutation of the other.)


\end{description}

\section{The Duration Statement (VDM-RT)}
\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{duration statement}
  }
  \Rule{duration statement}{
    \Lop{duration}, \Lit{(}, \Ruleref{expression}, \Lit{)},
    \Ruleref{statement}
  }

\item[Semantics:]
The duration statement is a runtime directive to the VDM
interpreters telling it that when incrementing the internal clock for the
enclosed statement, the value (an expression that must yield a natural number as its return type, otherwise causing a run-time error)
given in the duration statement should
be used instead of the increment which would normally be computed for that
statement. Thus the duration statement provides a mechanism to
override the VDM interpreter's default execution time computation. Note that the execution
of the expression is done in zero time and cannot cause thread switches.


\item[Example:] First a simple example:
\begin{lstlisting}
  while n < 10 do
    duration(10) n := n + 1;
\end{lstlisting}
In this example, assuming that this loop is not executed in the
context of an enclosing duration statement, on each iteration of the
loop the VDM interpreters will increment its internal clock by 10 time
units (nanoseconds),
rather than computing the amount of time required to execute the
statement \texttt{n := n + 1}.

If duration statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{lstlisting}
  duration(30)
  ( n := 1;
    while n < 10 do
      duration(10) n := n + 1;
  )
\end{lstlisting}
The outer duration statement takes precedence, so assuming this is not
executed in the context of an enclosing duration statement, the
VDM interpreters would increment its internal clock by 30 time units when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{lstlisting}
op1 : nat ==> nat
op1(m) ==
  duration (20) return m + 1;

op2 : () ==> nat
op2() ==
( dcl n : nat := 3;
  duration(10)  n := op1(1);
  return n)
\end{lstlisting}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the duration statement in \texttt{op1} will be overridden by
the duration statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement
\texttt{n := op1(1);} the internal clock is incremented by 10 time units
only.

\begin{lstlisting}
  ( n := 1; while n < 10 do duration(n) n := n + 1 )
\end{lstlisting}

The final example demonstrates the use of a general expression as the argument to the duration statement, whereby the consecutive executions of the body of the while loop take more time as $n$ increases.

\end{description}

\section{The Cycles Statement (VDM-RT)}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{cycles statement}
  }
  \Rule{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{expression}, \Lit{)},
    \Ruleref{statement}
  }

\item[Semantics:]
The cycles statement is a runtime directive to the VDM interpreters
telling it that when incrementing the internal clock for the enclosed
statement, the value (an expression that must yield a natural number as its return type, otherwise causing a run-time error)
given in the cycles statement should be used as
an indication of how many clock cycles that the enclosed statement
should be incremented by instead of the increment which would normally
be computed for that statement. Thus the cycles statement provides a
mechanism to override the VDM interpreter's default execution time
computation similar to the duration statement but in a way that is
relative to the speed of the \texttt{CPU} that the computation is carried
out on. Note that the execution
of the expression is done in zero time and cannot cause thread switches.

\item[Example:] First a simple example:
\begin{lstlisting}
  while n < 10 do
    cycles(1000) n := n + 1;
\end{lstlisting}
In this example, assuming that this loop is not executed in the
context of an enclosing cycles statement, on each iteration of the
loop the VDM interpreters will increment its internal clock by the time it will
take to process 1000 instructions on the given \texttt{CPU} (relative
to its capacity), rather than computing the amount of time required to
execute the statement \texttt{n := n + 1}.

If cycles statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{lstlisting}
  cycles(3000)(
        n := 1;
        while n < 10 do
           cycles(1000) n := n + 1;
        )
\end{lstlisting}
The outer cycles statement takes precedence, so assuming this is not
executed in the context of an enclosing cycles statement, the
interpreter would increment its internal clock by the time it takes to
process 3000 instructions on the given \texttt{CPU} when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{lstlisting}
      op1 : nat ==> nat
      op1(m) ==
        cycles (2000) return m + 1;

      op2 : () ==> nat
      op2() ==
      (dcl n : nat := 3;
       cycles(1000)  n := op1(1);
       return n)
\end{lstlisting}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the cycles statement in \texttt{op1} will be overridden by
the cycles statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement
\texttt{n := op1(1);} the internal clock is incremented by the time
it takes to process 1000 instructions on the given \texttt{CPU}
only.

\begin{lstlisting}
  ( n := 1; while n < 10 do cycles(n) n := n + 1 )
\end{lstlisting}

The final example demonstrates the use of a general expression as the argument to the cycles statement, whereby the consecutive executions of the body of the while loop take more time as $n$ increases.

\end{description}


\chapter{Top-level Specification in VDM}
\label{top-level}

The top-level specification structure differs significantly between
the VDM-SL approach and the VDM++ and VDM-RT approach. In VDM-SL the
ISO standard prescribes a flat-language but here a modular extension
is also enabled using imports and exports primitives. In VDM++ and
VDM-RT structuring is done using object-oriented classes that can
inherit constructs between them controlled by access modifiers. These
two different approaches are explained in the two sections in this
chapter.

\section{Top-level Specification in VDM-SL}\label{modules}

In the previous chapters all the  VDM-SL constructs such as types,
expressions, statements, functions and operations have been described. A
number of these constructs can constitute a top-level  VDM-SL
specification. A top-level specification can be created in two ways:
\begin{enumerate}
\item The specification is split into a number of modules which are
  specified separately, but can depend on each other.
\item The specification is specified in a flat manner, i.e.\ no modules are
  used (note that in VDM-10 it is possible to have access to standard
  modules also from a flat VDM-SL specification).
\end{enumerate}
Thus, a complete specification, or document, has the following syntax.

\begin{description}
\item[Syntax:]
\Rule{document}{
  \Ruleref{module}, \SeqPt{\Ruleref{module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\end{description}

\subsection{A Flat Specification}\label{flat}

As said, a flat specification does not use modules. This means that all
constructs can be used throughout the specification. In the flat case, a
document has a syntax of:

\Rule{document}{\ldots \dsep
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{traces definitions}
  }

Thus, a flat specification is made up of several {\it definition\/} blocks.
However, only one state definition is allowed. The following is an example
of a flat top-level specification:

\begin{lstlisting}
values

  st1 = mk_St([3,2,-9,11,5,3])

state St of
  list:seq1 of nat
end

functions

  min_index : seq1 of nat -> nat
  min_index(plist) ==
    if len plist = 1
    then 1
    else let mi = min_index(tl plist)
         in
           if plist(mi+1) < hd plist
           then mi+1
           else 1

operations

  SelectionSort : nat ==> ()
  SelectionSort (i) ==
    if i < len list
    then (dcl temp: nat;
          dcl mi : nat := min_index(l(i,...,len list)) + i - 1;

          temp := list(mi);
          list(mi) := list(i);
          list(i) := temp;
          SelectionSort(i+1)
         )
\end{lstlisting}

\subsection{A Structured Specification}

As an extension to the standard VDM-SL language, it is possible to
structure an  VDM-SL specification using modules. In this section,
the use of modules to create the top-level specification will be described.
With the structuring facilities offered by  VDM-SL it is possible to:
\begin{itemize}
\item Export constructs from a module.
\item Import constructs from a module.
\item Rename constructs upon import.
\item Define a state in a module.
\end{itemize}

%In addition to these kinds of ordinary modules it is possible to use
%so-called ``Dynamic Link Modules'' (see section~\ref{sec:DLmodules}).

\subsubsection{The Layout of a Module}

Before the actual facilities are described, the general layout of a
module is described. A module consists of three parts: a {\it module
declaration}, an {\it interface section}, and a {\it definitions
section}. It is possible to leave out the definitions part in the
early development of a module specification.

In the module declaration, the module is named. The name must be a
unique module name within the complete specification. The second
part, the interface section, defines the relation of a module with other
modules and consists of two sections. These sections are:
\begin{itemize}

\item An {\it imports section}. In the imports section, all the
  constructs that are going to be used from other modules are
  described. If constructs are going to be renamed it has to be done
  in the imports section.

\item An {\it exports section}. Here all the constructs that are going
  to be used in other modules are defined.
  If no exports section is present the
  module cannot be used from any other modules.
\end{itemize}
The third part of a module declaration, the
definitions section, contains all the definitions of the module.
Thus, in general, the syntax of a module is:


\begin{description}
\item[Syntax:]
\Rule{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

  \Rule{module body}{
    \Lop{definitions}, \Ruleref{definition block}, \SeqPt{definition block}
  }
\end{description}

%To illustrate the use of modules, the example flat top-level
%specification are rewritten with some minor modifications.  Some
%unimportant parts of the flat specification are left out for clarity.
Note that the identifier after \keyw{module} and \keyw{end} should be identical.

\subsubsection{The Exports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{export definition}{
    \Lop{exports}, \Ruleref{export module signature}
    }

  \Rule{export module signature}{
    \Lop{all} \dsep
    \Ruleref{export signature}, \lfeed
    \SeqPt{\Ruleref{export signature}}
    }

  \Rule{export signature}{
    \Ruleref{export types signature} \dsep
    \Ruleref{export values signature} \dsep
    \Ruleref{export functions signature} \dsep
    \Ruleref{export operations signature}
%    \dsep
%    state signature
    }

  \Rule{export types signature}{
    \Lop{types}, \Ruleref{type export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
    }

  \Rule{type export}{
    \OptPt{\Lop{struct}}, \Ruleref{name}
    }

  \Rule{export values signature}{
    \Lop{values}, \Ruleref{value signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
    }

  \Rule{value signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{type}
    }

  \Rule{export functions signature}{
    \Lop{functions}, \Ruleref{function signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
    }

  \Rule{function signature}{
    \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
    \Ruleref{function type}
    }

  \Rule{export operations signature}{
    \Lop{operations}, \Ruleref{operation signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
    }

  \Rule{operation signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
    }

%  \Rule{state signature}{
%    \Lop{state}, name, \SeqPt{\Lit{,}, name}
%    }

\item[Semantics:] The exports section must be used to make constructs
  visible to other modules. Some or all of the defined
  constructs from a module can be exported. In the latter case, the keyword
  \keyw{all} is used. However, imported constructs are not exported
  from the module. If only part
  of the constructs are exported, the visible constructs with
  the appropriate signatures are stated.

  Normally, if a construct is visible to another module,
  that construct can be considered
   to be defined inside the module. However, with types and
  operations there are some exceptions:
  \begin{description}
  \item[Types:] If a type {\tt T} is defined in module {\tt A} and
    this type is also going to be used in module {\tt B}, the type
    from module {\tt A} has to be exported. This can be done in two ways:
    \begin{enumerate}
    \item The name of the type is exported.
    \item The structure of the type is exported.
    \end{enumerate}
    If only the name of the type is exported, the other module cannot create
    values of type {\tt T}. This means that the exporting module ({\tt A})
    must provide functions and/or operations to directly create and manipulate
    values of type {\tt T} by means of the constructors related to the
    representation of {\tt T}.

    If we export the structure of the type by using the keyword
    \keyw{struct}, the other module can create and manipulate values of
    type {\tt T} (it can also use the \keyw{mk\_} keyword and the
    \keyw{is\_} keyword for this type if it is a record type).

    If the type also defines an invariant, the invariant predicate function
    is only exported if the structure of the type is exported.

  \item[Operations:] In a module, a state that is global for
    the module can be defined. All operations within the module can
    manipulate that state. If operations are exported from a module, they
     manipulate the state in the exporting module,
      i.e.\ the state in the module where they are defined.
  \end{description}

  If an exported function or an operation defines a pre- and/or
  post-condition, the corresponding predicate functions (see
  chapter~\ref{functiondef}) are also exported.

\item[Examples:] Consider a model of a bank account. An account is
characterised by the name of the holder, the account number, the
bank branch at which the account is maintained, the balance, and an
encrypted PIN code for the ATM card. We might model this as follows:
\begin{lstlisting}
module BankAccount

exports types digit; account
        functions digval: digit -> nat;
                  deposit: account * real -> account;
                  withdrawal: account * real -> account;
                  isPin: account * nat -> bool;
                  requestWithdrawal: account * nat -> bool
definitions

types

  digit = nat
  inv d == d < 10;

  account::  holder : seq1 of char
             number : seq1 of digit
             branchcode : seq1 of digit
             balance: real
             epin: nat
  inv mk_account(holder, number, branchcode,-,-) ==
    len number = 8 and len branchcode = 6

functions

    digval : digit -> nat
    digval(d) == d;

    deposit: account * real -> account
    deposit(acc,r) ==
      mu(acc,balance |-> acc.balance + r);

    withdrawal : account * real -> account
    withdrawal (acc,r) ==
      mu(acc,balance |-> acc.balance - r);

    isPin : account * nat -> bool
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * nat -> bool
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

end BankAccount
\end{lstlisting}
In this module we export two types and five functions. Note that since
we have enumerated the entities we are exporting, but have not
exported \texttt{digit} or \texttt{account} using the \keyw{struct}
keyword, the internals of \texttt{account} values may not be accessed
by other modules, neither may the invariant for \texttt{digit}. If
such access is necessary, the types should be exported with the
\keyw{struct} keyword, or all constructs in the module should be
exported using the \keyw{exports all} clause.

The module \texttt{Keypad} given below models the keypad interface of
an ATM machine. The state variable maintains a buffer of data typed at
the keypad by the user.

\begin{lstlisting}
module Keypad

imports
from BankAccount types digit

exports all

definitions

state buffer of
  data : seq of BankAccount`digit
end

operations

    DataAvailable : () ==> bool
    DataAvailable () ==
      return(data <> []);

    ReadData : () ==> seq of BankAccount`digit
    ReadData () ==
      return (data);

    WriteData : seq of BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

end Keypad
\end{lstlisting}
In this module all constructs are exported. Since the only entities
defined are the state and operations on it, this means that all of the
operations may be accessed by an importing module. The state is not
accessible to importing modules, but remains private to this
module. However the state constructor
\texttt{\keyw{mk\_}Keypad`buffer} is accessible.


\end{description}

\subsubsection{The Imports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{import definition list}{
    \Lop{imports}, \Ruleref{import definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{import definition}}
    }

  \Rule{import definition}{
    \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
    }

  \Rule{import module signature}{
    \Lop{all} \dsep
    \Ruleref{import signature}, \lfeed
    \SeqPt{\Ruleref{import signature}}
    }

  \Rule{import signature}{
    \Ruleref{import types signature} \dsep
    \Ruleref{import values signature} \dsep
    \Ruleref{import functions signature} \dsep
    \Ruleref{import operations signature}
%    \dsep
%    state signature
    }

  \Rule{import types signature}{
    \Lop{types}, \Ruleref{type import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
    }

  \Rule{type import}{
    \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
    \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import values signature}{
    \Lop{values}, \Ruleref{value import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
    }

  \Rule{value import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import functions signature}{
    \Lop{functions}, \Ruleref{function import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
    }

  \Rule{function import}{
    \Ruleref{name}, \OptPt{\OptPt{\Ruleref{type variable list}},
    \Lit{:}, \Ruleref{function type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import operations signature}{
    \Lop{operations}, \Ruleref{operation import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
    }

  \Rule{operation import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

\item[Semantics:] The imports section is used to state what constructs are
  used from other modules with the restriction that only visible constructs
  can be imported. If all the visible constructs from a
  module are going to be used, the keyword \keyw{all} is used, unless one or
  more constructs are going to be renamed. With renaming, an imported
  construct is given a new name
  which can be used instead of the original name preceded by the
  exporting module name. In general this has the form:
  \begin{lstlisting}
    name renamed new_name
  \end{lstlisting}
  where {\tt name} is the name of the imported construct, and {\tt
    new\_name} is the new name for the construct. This way,
  more meaningful names can be given to constructs. Note that in the importing
  module it is not possible to refer to {\tt DefModule`name} (where
  {\tt DefModule} is the name of the defining module) any longer but only to
  {\tt newname}.

  It is possible to include type information in the imports section,
such that
  this information will only be used by the static semantics check of the
  complete module. If no type information is given, the static semantics
  can also find this information in the exporting module.

 A module that imports a type may only access the internal structure of that type if it was exported with the \keyw{struct} keyword; this includes invoking the type constructor and using the selector functions. If the type was exported without the \keyw{struct} keyword then the importing module may refer to the type, and call functions from the imported module that create elements of the type, but it cannot invoke the type constructor, or use the selector functions.

When a composite type is exported with struct then its constructor is referred to, in the importing module, by \keyw{mk\_}{\tt ExportingMod`RecordName}. If the composite type is renamed on import, to {\tt ImportedRecName} say, then the constructor is referred to by \keyw{mk\_}{\tt ImportedRecName}.

\item[Examples:] We can model an ATM card as consisting of a
card number and an expiry date. This requires the \texttt{digit} type
defined in the module \texttt{BankAccount}. It also uses the function
\texttt{digval} from the same module.
\begin{lstlisting}
module ATMCard

imports
from BankAccount types digit
                 functions digval renamed atmc_digval

exports all

definitions

types

    digit = BankAccount`digit

    atmc:: cardnumber : seq1 of digit
           expiry : digit * digit * digit * digit
    inv mk_atmc(cardnumber, mk_(m1,m2,-,-)) ==
        let m = atmc_digval(m1) * 10 + atmc_digval(m2) 
        in m > 0 and m <= 12 and len cardnumber >= 8

functions

    getCardnumber : atmc -> seq1 of digit
    getCardnumber (atmc) ==
      atmc.cardnumber

end ATMCard
\end{lstlisting}
Here the invariant on the type \texttt{atmc} states that expiry dates
must represent valid dates, and card numbers must be at least 8 digits
long. Note that since \texttt{digit} is not exported with the
\keyw{struct} keyword from the module \texttt{BankAccount}, we cannot
access the invariant for \texttt{digit} in module
\texttt{ATMCard}. This notwithstanding, all values of type
\texttt{digit} manipulated in \texttt{ATMCard} must satisfy the
invariant.

\end{description}

\section{Top-level Specification in VDM++ and VDM-RT}

In the previous chapters VDM constructs such as types,
expressions, statements, functions and operations have been
described. A number of these constructs can constitute the definitions
inside a class definition. A top-level specification, or document, is
composed of one or more class definitions. Note that only in VDM-RT it
is possible to have a \keyw{system} class.

\begin{description}
\item[Syntax:]
\Rule{document}{
   (\Ruleref{class}
   \dsepl\ \Ruleref{system})
   ,\SeqPt{\Ruleref{class}
   \dsepl\ \Ruleref{system}
         }
  }
\end{description}

\section{System (VDM-RT) }\label{sec:system}

In order to be able to describe distributed systems VDM-RT includes
a notion of a system that describes how different parts of the system
modelled are deployed to different Core Processing Units (CPUs) and
communication busses connecting the CPUs together. Syntactically the
system is described exactly like ordinary classes described below in
Section~\ref{sec:classdep}, except that the keyword ``\keyw{system}''
instead of the keyword ``\keyw{class}'' is used.

\begin{description}
\item[Syntax:]
\Rule{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions}
}

\item[Semantics:] Each system description has the following parts:
\begin{itemize}
\item A system header with the system name.
\item An optional {\em system body}.
\item A system tail.
\end{itemize}

The system name as given in the system header is the defining occurrence
of the name of the class. A system name is globally visible, i.e.\ visible
in all other classes/systems in the specification.

The system name in the class header must be the same as the system
name in the system tail.  Furthermore, defining system names must be unique
throughout the specification.

The special thing about the system is that it can make use of special
implicitly defined classes called \texttt{CPU} and \texttt{BUS}. It is
not possible to create instances of the system, but instances made of
\texttt{CPU} and \texttt{BUS} will be created at initialisation time.
Note that \texttt{CPU} and \texttt{BUS} cannot be used outside the
system definition.

The instances of \texttt{CPU} and \texttt{BUS} must be made as instance
variables and the definition must use constructors. The constructor for the
\texttt{CPU} class takes two parameters: the first one indicates the
primary scheduling policy used for the \texttt{CPU} whereas the second
parameter provides the capacity of the \texttt{CPU} (indicated as number of 
instructions Per Second or Hz -- NB. the (time unit) step size of time is 1 nanosecond).
The constructor for the \texttt{BUS}
class takes three parameters. The first one indicates the kind of bus, the
second one the capacity of the bus (its band width in bytes per second) and finally the third
parameter gives a set of \texttt{CPU} instances connected together by the
given \texttt{BUS} instance.

The currently supported primary scheduling policies for the \texttt{CPU}
are:
\begin{description}
\item[\texttt{<FP>}:] Fixed Priority
\item[\texttt{<FCFS>}:] First Come First Served
\end{description}

The currently supported primary scheduling policy for the \texttt{BUS}
is:
\begin{description}
%\item[\texttt{<TDMA>}:] Time Division Multiple Access
\item[\texttt{<FCFS>}:] First Come First Served
%\item[\texttt{<CSMACD>}:] Carrier Sense Multiple Access with Collision
%                          Detection
\end{description}

The \texttt{CPU} class has member operations called \texttt{deploy} and
\texttt{setPriority}. The \texttt{deploy} operation takes one
significant parameter
which must be an object that is declared as a static instance variable
inside the system\footnote{It is also allowed to take a string as a
second parameter for future extensions but that is ignored at the
moment.}. The semantics of the deploy operation is that execution
of all functionality inside this object will take place on the CPU that it
has been deployed to. The \texttt{setPriority} operation takes two
parameters where the first must be the name of a public operation that
has been deployed to the CPU and the second parameter is a natural number.
The semantics of the \texttt{setPriority} operation is that the given
operation is assigned the given priority (the second parameter). This will
be used when fixed priority scheduling is used on the given CPU. Per
default operations that are not explicitly assigned a priority using
the \texttt{setPriority} operation are assigned a default priority of 1.

The system ``class'' is limited in the way that it can only contain:
\begin{description}
\item[Instance variables:] The only instances that can be declared in the 
system ``class'' is of the special classes \texttt{CPU} and \texttt{BUS} 
as well as static instances of the different system components that one
wishes to allocate to different CPU's.
\item[Constructor:] The actual deployment of instances to CPU's and setting
of priorities for the different operations is set inside the
constructor which is the only operation that can be placed in the
system ``class''. The only kind of statement that can be used inside
this constructor is a block statement with a sequence of invocations
of the special \texttt{deploy} and \texttt{setPriority} operations.
\end{description}

In addition there are limitations with respect to the use of static
declarations for instances that are deployed to different
CPU's. Basically the user should ensure that only one instance is
deployed to a CPU if the class the instance comes from contains any
static operations or functions. In case a static instance variable is
used it is accessed directly (without any communication over the
busses), so this in essence not proper from a distribution
standpoint. Thus, all instance variables of instances to be deployed
should only be accessed through the use of operations.

\item[Example:] The system class could for example be defined as:
\begin{lstlisting}
system Simple

instance variables
  static public a : A := new A();
  static public b : B := new B();
  -- define the first CPU with fixed priority scheduling
  -- and 22E6 Hz
  CPU1 : CPU := new CPU (<FP>, 22E6);

  static public c : C := new C();
  -- define the second CPU with fixed priority scheduling
  -- and 11E6 Hz
  CPU2 : CPU := new CPU (<FP>, 11E6);

  -- create a communication bus that links the three
  -- CPU's together
  BUS1 : BUS := new BUS (<CSMACD>, 72E3, {CPU1, CPU2})

operations
  public Simple: () ==> Simple
  Simple () ==
    ( -- deploy a on CPU1
      CPU1.deploy(a);
      -- deploy b on CPU1
      CPU1.deploy(b);
      -- deploy c on CPU2
      CPU2.deploy(c,"CT");
      -- "CT" is a label here which is ignored
    );

end Simple
\end{lstlisting}
\noindent where \texttt{A}, \texttt{B} and \texttt{C} all are defined
as classes.
\end{description}

\subsection{Classes}
\label{sec:classdep}

Compared to the standard VDM-SL\ language, VDM++ and VDM-RT have been
extended with classes. In this section, the use of classes to create
and structure a top-level specification will be described. With the
object oriented facilities offered by VDM++ and VDM-RT it is possible to:

\begin{itemize}
\item Define classes and create objects.
\item Define associations and create links between objects.
\item Make generalisation and specialisation through inheritance.
\item Describe the functional behaviour of the objects using functions
  and operations.
\item Describe the dynamic behaviour of the system through threads and
  synchronisation constraints.
\end{itemize}

Before the actual facilities are described, the general layout of a
class is described.

\begin{description}
\item[Syntax:]
\Rule{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
%  time variable definitions \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions} \dsep
  \Ruleref{traces definitions}
}

\item[Semantics:] Each class description has the following parts:
\begin{itemize}
\item A class header with the class name and an optional
  {\em inheritance clause}.
\item An optional {\em class body}.
\item A class tail.
\end{itemize}

The class name as given in the class header is the defining occurrence
of the name of the class. A class name is globally visible, i.e. visible
in all other classes in the specification.

The class name in the class header must be the same as the class
name in the class tail.  Furthermore, defining class names must be unique
throughout the specification.

The (optional) class body may consist of:
\begin{itemize}
\item A set of {\it value definitions} (constants).
\item A set of {\it type definitions}.
\item A set of {\it function definitions}.
\item A set of {\it instance variable definitions} describing
  the internal state of an object instantiated from the
  class. State invariant expressions are encouraged but are not mandatory.
%\item A set of {\em time variable definitions} describing
%  the internal state of an object as a function of time.
\item A set of {\it operation definitions} that can act on the internal state.
\item A set of the {\it synchronization definitions}, specified either
  in terms of permission predicates or using mutex constraints.
% or in terms of traces.
%  Each trace represents an allowed sequence of invocations of the
%  functions and operations by other objects.
\item A set of {\it thread definitions} that describe the thread of control
  for active objects.
\item A set of {\it traces} that are used to indicate the sequences of
operation calls for which test cases are desired to be produced automatically.
\end{itemize}

In general, all constructs defined within a class must have a unique
name, e.g.\ it is not allowed to define an operation and a type with
the same name. However, it is possible to {\it overload} function and
operation names (i.e.\ it is possible to have two or more functions
with the same name and two or more operations with the same name)
subject to the restriction that the types of their input parameters
should not overlap. That is,  it should be possible using static type
checking alone to determine uniquely and unambiguously which
function/operation definition corresponds to each function/operation
call. Note that this applies not only to functions and operations
defined in the local interface of a class but also to those inherited
from superclasses. Thus, for example, in a design involving multiple
inheritance a class C may inherit a function from a class A and a
function with the same name from a class B and all calls involving
this function name must be resolvable in class C.
\end{description}

\subsection{Inheritance}\label{ch:inherit}

The concept of inheritance is essential to object orientation.  When
one defines a class as a subclass of an already existing class, the
definition of the subclass introduces an extended class, which is
composed of the definitions of the superclass together with the
definitions of the newly defined subclass.

Through inheritance, a subclass inherits from the superclass:
\begin{itemize}
\item Its instance variables. %and time variables.
  This also includes
  all invariants and their restrictions on the allowed modifications of
  the state.
\item Its operation and function definitions.
\item Its value and type definitions.
\item Its synchronization definitions as described in
  section \ref{ch:sync-inh}.
\item Its thread definitions as described in
  chapter~\ref{ch:thread}.
\end{itemize}

A name conflict occurs when two constructs of the same kind and with the
same name are inherited from different superclasses.
Name conflicts must be explicitly resolved through {\it name qualification},
i.e. prefixing the construct with the name of the superclass and a
\texttt{`}-sign (back-quote).

\begin{description}
\item[Example:] In the first example, we see that inheritance can be
exploited to allow a class definition to be used as an abstract
interface which subclasses must implement:
  \begin{lstlisting}
class Sort

  instance variables
    protected data : seq of int

  operations

    initial_data : seq of int ==> ()
    initial_data (list) ==
      data := list;

    sort_ascending : () ==> ()
    sort_ascending () == is subclass responsibility;
end Sort

class SelectionSort is subclass of Sort

  functions

    min_index : seq1 of nat -> nat
    min_index(list) ==
      if len list = 1
      then 1
      else let mi = min_index(tl list)
           in
             if list(mi+1) < hd list
             then mi+1
             else 1

  operations

    sort_ascending : () ==> ()
    sort_ascending () == selectSort(1);

    selectSort : nat ==> ()
    selectSort (i) ==
      if i < len data
      then (dcl temp: nat;
            dcl mi: nat := min_index(data(i,...,len data)) +
                          i - 1;

           temp := data(mi);
           data(mi) := data(i);
           data(i) := temp;
           selectSort(i+1)
           )

end SelectionSort
\end{lstlisting}
Here the class \texttt{Sort} defines an abstract interface to be
implemented by different sorting algorithms. One implementation is
provided by the \texttt{SelectionSort} class.

The next example clarifies how name space clashes are resolved.
  \begin{lstlisting}
    class A
    instance variables}
      i: int := 1;
      j: int := 2;
    end A

    class B is subclass of A
    end B

    class C is subclass of A
    instance variables
      i: int := 3;
    end C

    class D is subclass of B,C
    operations
      GetValues: () ==> seq of int
      GetValues() ==
        return [
            A`i, -- equal to 1
            B`i, -- equal to 1 (A`i)
            C`i, -- equal to 3
            j   -- equal to 2 (A`j)
          ]
     end D
  \end{lstlisting}
\end{description}

In the example objects of class {\tt D} have 3 instance variables:
{\tt A`i}, {\tt A`j} and {\tt C`j}. Note that objects of class {\tt D}
will have only one copy of the instance variables defined in class {\tt
A} even though this class is a common super class of both class {\tt
B} and {\tt C}. Thus, in class {\tt D} the names {\tt B`j}, {\tt C`j},
{\tt D`j} and {\tt j} are all referring to the same variable, {\tt
A`j}. It should also be noticed that the variable name {\tt i} is
ambiguous in class {\tt D} as it refers to different variables in
class {\tt B} and class {\tt C}.

\subsection{Interface and Availability of Class Members}\label{ch:interface}

In VDM++ and VDM-RT definitions inside a class are distinguished between:

\begin{description}
\item[Class attribute:] an attribute of a class for which there
  exists exactly one incarnation no matter how many instances
  (possibly zero) of the class may eventually be created. Class
  attributes in VDM++ and VDM-RT correspond to \keyw{static} class members in
  languages like C++ and Java. Class (static) attributes can be
  referenced by prefixing the name of the attribute with the name of
  the class followed by a \texttt{`}-sign (back-quote), so that, for
  example, {\tt ClassName`val} refers to the value {\tt val} defined in
  class {\tt ClassName}.

\item[Instance attribute:] an attribute for which there exists one
  incarnation for each instance of the class. Thus, an instance
  attribute is only available in an object and each object has its own
  copy of its instance attributes. Instance (non-static) attributes
  can be referenced by prefixing the name of the attribute with the name of
  the object followed by a dot, so that, for example, {\tt
    object.op()} invokes the operation {\tt op} in the object denoted
  by {\tt object} (provided that \texttt{op} is visible to
  \texttt{object}).
\end{description}

Functions, operations, instance variables and constants\footnote{In
  practice, constants will generally be static -- a non-static
  constant would represent a constant whose value may vary from one
  instance of the class to another which would be more naturally
  represented by an instance variable.} in a class may
be either class attributes or instance attributes. This is indicated
by the keyword \keyw{static}: if the declaration is preceded by the
keyword \keyw{static} then it represents a class attribute, otherwise
it denotes an instance attribute.

Other class components are by default always either class attributes
or instance attributes as follows:

\begin{itemize}
\item Type definitions are always class attributes.
%  Thus, they can be quoted directly in a class. E.g.\ {\tt
%    ClassName`val} refers to the value {\tt val} defined in
%  class {\tt ClassName}.
% \item Function and operation definitions are instance
%   attributes.  Thus, they are quoted in objects. E.g.\ {\tt
%   object.op()} invokes the operation {\tt op} in the object denoted by
%   {\tt object} (provided that \texttt{op} is visible to \texttt{object}).
% \item Instance variables %and time variables
%   are instance
%   attributes. Thus, each object has its own copy
%   of the instance %and time
%   variables.
\item Thread definitions are always instance attributes. Thus, each active
  object has its own thread(s).
\item Synchronization definitions are always instance attributes. Thus, each
  object has its own ``history'' when it has been created.
\end{itemize}

In addition, the interface or accessibility of a class member may be
explicitly defined using an access specifier: one of \keyw{public},
\keyw{private} or \keyw{protected}. The meaning of these specifiers
is:
\begin{description}
\item[\keyw{public}:] Any class may use such members
\item[\keyw{protected}:] Only subclasses of the current class may use
  such members
\item[\keyw{private}:] No other class may use such members - they may
  only be used in the class in which they are specified.
\end{description}

The default access to any class member is \keyw{private}. That is,
if no access specifier is given for a member it is private.

This is summarized in table \ref{table:access}. A few provisos apply
here:
\begin{itemize}
\item Granting access to instance variables (i.e.\ through
a \keyw{public} or \keyw{protected} access specifier) gives
both read and write access to these instance variables.
% ***** Change this in the future if o.v := expr is possible
\item Public instance variables may be read (but not written) using
  the dot (for object instance variables) or back-quote (for class
  instance variables) notation e.g.\ a public instance variable
  \texttt{v} of an object \texttt{o} may be accessed as \texttt{o.v}.
\item Access specifiers may only be used with type, value, function,
  operation and instance variable definitions; they cannot be used
  with thread or synchronization definitions.
\item It is not possible to convert a class attribute into an instance
  attribute, or vice-versa.
\item For inherited classes, the interface to the subclass is the same
  as the interface to its superclasses extended with the new
  definitions within the subclass.
\item Access to an inherited member cannot be made more restrictive
  e.g.\ a public instance variable in a superclass cannot be
  redeclared as a private instance variable in a subclass.
\end{itemize}

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|c|}\hline
                 & \keyw{public} & \keyw{protected} & \keyw{private}\\ \hline
Within the class & $\surd$       & $\surd$          & $\surd$ \\
In a subclass    & $\surd$       & $\surd$          & $\times$\\
In an arbitrary
external class   & $\surd$       & $\times$         & $\times$ \\
\hline
\end{tabular}
\end{center}
\caption{Summary of Access Specifier Semantics}\label{table:access}
\end{table}
\begin{description}
\item[Example] In the example below use of the different access
  specifiers is demonstrated, as well as the default access to class
  members. Explanation is given in the comments within the definitions.
\begin{lstlisting}
class A

types
public Atype = <A> | <B> | <C>

values
public Avalue = 10;

functions
public compare : nat -> Atype
compare(x) ==
  if x < Avalue
  then <A>
  elseif x = Avalue
  then <B>
  else <C>

instance variables
public v1: nat;
private v2: bool := false;
protected v3: real := 3.14;

operations
protected AInit : nat * bool * real ==> ()
AInit(n,b,r) ==
  (v1 := n;
   v2 := b;
   v3 := r)
end A

class B is subclass of A

instance variables
v4 : Atype --inherited from A

operations

BInit: () ==> ()
BInit() ==
  (AInit(1,true,2.718); --OK: can access protected members
                        --in superclass
   v4 := compare(v1);   --OK since v1 is public
   v3 := 3.5;           --OK since v3 protected and this
                        --is a subclass of A
   v2 := false          --illegal since v2 is private to A
  )

end B

class C

instance variables
a: A := new A();
b: B := new B();

operations

CInit: () ==> A`Atype--types are class attributes
CInit() ==
  (a.AInit(3,false,1.1);
                     --illegal since AInit is protected
   b.BInit();        --illegal since BInit is (by default)
                     --private
   let - = a.compare(b.v3) in skip;
                     --illegal since C is not subclass
                     --of A so b.v3 is not available
   return b.compare(B`Avalue)
                     --OK since compare is a public instance
                     --attribute and Avalue is public class
                     --attribute in B
  )

end C
\end{lstlisting}
%       b.v1 := 4;           --OK since v1 public in A so is
%                            --public by inheritance



\end{description}

\chapter{Synchronization Constraints (VDM++ and VDM-RT)}\label{ch:sync}

In general a complete system contains objects of a passive
nature (which only react when their operations are invoked) and active
objects which `breath life' into the system. These active objects
behave like virtual machines with their own processing thread of
control and after start up they do not need interaction with other
objects to continue their activities.
In another terminology a system could be described as
consisting of a number of active clients requesting services of passive
or active servers.
In such a parallel environment the server objects need
synchronization control to be able to guarantee internal consistency,
to be able to maintain their state invariants.
Therefore, in a parallel world, a passive object needs to
behave like a Hoare monitor with its operations as entries.

If a sequential system is specified (in which only one thread of control
is active at a time) only a special case of the general properties is used
and no extra syntax is needed. However, in the course of development from
specification to implementation more differences are likely to appear.

The following default synchronization rules for each object apply in
VDM++ and VDM-RT:
\begin{itemize}
\item operations are to be viewed as though they are atomic, from the
point of the caller;
\item operations which have no corresponding permission predicate are
  subject to no restrictions at all;
\item synchronization constraints apply equally to calls within an
  object (i.e.\ one operation within an object calls another operation
  within that object) and outside an object (i.e.\ an operation from
  one object calls an operation in another object);
\item operation invocations have the semantics of a rendez-vous (as in
Ada, see \cite{adalrm}) in case two active objects are involved. Thus if an
object $O_1$ calls an operation $o$ in object $O_2$, if $O_2$ is currently
unable to start operation $o$ then $O_1$ blocks until the operation may be
executed. Thus invocation occurs when both the calling object and the
called object are ready. (Note here a slight difference from the
semantics of Ada: in Ada both parties to the rendez-vous are active
objects; in VDM++ and VDM-RT only the calling party is active).
\end{itemize}
The synchronization definition blocks of the class description provide the
user with ways to override the defaults described above.

\begin{description}
\item[Syntax:]
  \Rule{synchronization definitions}{
    \Lop{sync}, \OptPt{\Ruleref{synchronization}}
  }
  \Rule{synchronization}{
    \Ruleref{permission predicates}
  }

\item[Semantics:]

Synchronization is specified in VDM++ and VDM-RT using permission predicates.

\end{description}


\section{Permission Predicates}
\label{sec:permissionpred}

The following gives the syntax used to state
rules for accepting the execution of concurrently callable operations.
Some notes are given explaining these features.

\begin{description}
\item[Syntax:]
  \Rule{permission predicates}{
    \Ruleref{permission predicate}, \SeqPt{\Lit{;}, \lfeed
    \Ruleref{permission predicate}}
  }
\Rule{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Rule{mutex predicate}{
       \Lop{mutex}, \Lit{(}, (\Lop{all} \dsepl \Ruleref{name list}, \Lit{)}}

\item[Semantics:] Permission to accept execution of a requested
operation depends on a guard condition in a (deontic) permission
predicate of the form:

\begin{quote}
{\keyw{per}} {\em operation name} \texttt{=>} {\em guard condition}
\end{quote}

The use of implication to express the permission means that truth of
the guard condition (expression) is a necessary but not sufficient
condition for the invocation. The permission predicate is to be read
as stating that if the guard condition is false then there is
non-permission. Expressing the permission in this way allows further
similar constraints to be added without risk of contradiction through
inheritance for the subclasses. There is a default for all operations:

\begin{quote}
{\keyw{per}} {\em operation name} \texttt{=>} \keyw{true}
\end{quote}

but when a permission predicate for an operation is specified
this default is overridden.

Guard conditions can be conceptually divided into:
\begin{itemize}
\item
a {\em history guard} defining the dependence on events in the past;
\item
an {\em object state guard}, which depends on the instance variables of the
object, and
\item
a {\em queue condition guard}, which depends on the
states of the queues formed by operation invocations (messages) awaiting
service by the object.
\end{itemize}
These guards can be freely mixed. \textbf{Note} that there is no
\textit{syntactic} distinction between these guards - they are all
expressions. However they may be distinguished at the semantic level.

A mutex predicate allows the user to specify either that all
operations of the class are to be executed mutually exclusive, or that
a list of operations are to be executed mutually exclusive to each
other. Operations that appear in one mutex predicate are allowed to
appear in other mutex predicates as well, and may also be used in the
usual permission predicates. Each mutex predicate will implicitly be
translated to permission predicates using history guards for each
operation mentioned in the name list. For instance,
\begin{lstlisting}
sync
  mutex(opA, opB);
  mutex(opB, opC, opD);
  per opD => someVariable > 42;
\end{lstlisting}
would be translated to the following permission predicates:
\begin{lstlisting}
sync
  per opA => #active(opB) = 0;
  per opB => #active(opA) = 0 and
             #active(opC) + #active(opD) = 0;
  per opC => #active(opB) + #active(opD) = 0;
  per opD => #active(opB) + #active(opC) = 0 and
             someVariable > 42;
\end{lstlisting}

Note that it is only permitted to have one ``stand-alone'' permission
predicate for each operation. It is also important to note that if
permission predicates are made over operations that are overloaded
(see Section~\ref{sec:classdep}) then it will incorporate all of their history
counters as the same operation. The {\bf\ttfamily{\#active}} operator
is explained below.

A \keyw{mutex(all)} constraint specifies that all of the operations
specified in that class \textit{and any superclasses} are to be
executed mutually exclusively.
\end{description}


\subsection{History guards}
\begin{description}
\item[Semantics:] A history guard is a guard which depends on the
sequence of earlier invocations of the operations of the object
expressed in terms of history expressions (see section
\ref{sec:historyexpr}). History expressions denotes the number
of activations and completions of the operations, given as functions

\keyw{\#act} and \keyw{\#fin}, respectively.
\begin{quote}
\keyw{\#act}: operation name $\rightarrow$ $\Nat$ \\
\keyw{\#fin}: operation name $\rightarrow$ $\Nat$
\end{quote}

Furthermore, a derived function {\bf\ttfamily \#active} is available such that
{\bf\ttfamily \#active}{\tt (A}{\tt )} $=$ {\bf\ttfamily \#act}{\tt (A}{\tt )} $-$
{\bf\ttfamily \#fin}{\tt (A}{\tt )}, giving the number of currently active
instances of {\tt A}. Another history function -- {\bf\ttfamily{\#req}} -- is
defined in section~\ref{queuesec}.
\item[Examples:]
Consider a Web server\label{example:webserver} that is capable of
supporting 10 simultaneous
connections and can buffer a further 100 requests. In this case we
have one instance variable, representing the mapping from URLs to
local filenames:
\begin{lstlisting}
instance variables
  site_map : map URL to Filename := {|->}
\end{lstlisting}

The following operations are defined in this class (definitions
omitted for brevity):

\begin{tabular}{lll}
\texttt{ExecuteCGI:} & \texttt{URL ==> File} & Execute a CGI script on the server\\
\texttt{RetrieveURL:} & \texttt{URL ==> File} & Transmit a page of html\\
\texttt{UploadFile:} & \texttt{File * URL ==> ()} & Upload a file onto the server\\
\texttt{ServerBusy:} & \texttt{() ==> File} & Transmit a ``server busy'' page\\
\texttt{DeleteURL:} & \texttt{URL ==> ()} & Remove an obsolete file
\end{tabular}

Since the server can support only 10 simultaneous connects, we can
only permit an execute or retrieve operation to be activated if the
number already active is less than 10:
\begin{lstlisting}
    per RetrieveURL => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
    per ExecuteCGI  => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
\end{lstlisting}
\end{description}

\subsection{The object state guard}
\begin{description}
\item[Semantics:]
The object state guard is a boolean expression which depends on the values of
one (or more) instance variable(s) of the object itself. Object state
guards differ from operation pre-conditions in that a call to an
operation whose permission predicate is false results in the caller
blocking until the predicate is satisfied, whereas a call to an
operation whose pre-condition is false means the operation's behaviour
is unspecified.

\item[Examples:]
Using the web server example again, we can only allow file removal if
some files already exist:
\begin{lstlisting}
    per DeleteURL   => dom site_map <> {}
\end{lstlisting}

Constraints for safe execution of the operations {\tt Push} and {\tt Pop}
in a stack object can be expressed using an object state guard as:
\begin{lstlisting}
per Push => length < maxsize;
per Pop => length > 0
\end{lstlisting}
where {\tt maxsize} and {\tt length} are instance variables of
the stack object.

It is often possible to express such constraints as a
consequence of the history,
for example the empty state of the stack:
\begin{lstlisting}
    length = 0 <=> #fin(Push) = #fin(Pop)
\end{lstlisting}
However, the size is a property which is better regarded as a
property of the particular stack instance, and in such cases it is
more elegant to use available instance variables which store the effects
of history.

%In replacing history expressions by state based ones, however,
%it should be remembered, that the change of a state value which
%results from an action, defined in a post-condition, may not occur as
%the last action of the corresponding operation.
%
%Furthermore, object state guards may only be used if mutual exclusion
%is specified in addition for all operations in order to avoid problems
%with possible simultaneous access to the instance variables.
\end{description}


\subsection{Queue condition guards}\label{queuesec}
\begin{description}
\item[Semantics:]
A queue condition guard acts on requests waiting in the queues for the
execution of the operations.
This requires use of a third history function {\bf\ttfamily \#req} such that
{\bf\ttfamily \#req}{\tt (A)} counts the number of messages which have been received by the
object requesting execution of operation {\tt A}.
Again it is useful to introduce the function {\bf\ttfamily \#waiting} such that:
{\bf\ttfamily \#waiting}{\tt (A}{\tt )} $=$ {\bf\ttfamily \#req}{\tt (A}{\tt )} $-$ {\bf\ttfamily \#act}{\tt (A}{\tt )},
which counts the number of items in the queue.

\item[Examples:]
Once again, with the web server we can only activate the
\texttt{ServerBusy} operation if 100 or more connections are waiting:
\begin{lstlisting}
per ServerBusy  => #waiting(RetrieveURL) +
                   #waiting(ExecuteCGI) >= 100;
\end{lstlisting}

The most important use of such expressions containing queue
state functions is for expressing priority between operations. The
protocol specified by:
%mutex(A,B) $\wedge$ per B \kw{=>} \#req(A) = 0
\begin{lstlisting}
per B => #waiting(A) = 0
\end{lstlisting}
gives priority to waiting  requests for activation of {\tt A}. There
are, however, many other situations when operation dispatch depends on
the state of waiting requests.  Full description of the queuing
requirements to allow specification of operation selection based on
request arrival times or to describe `shortest job next' behaviour
will be a future development.

Note that \texttt{\#\keyw{req}(A)} have value 1 at the time of evaluation of
the permission predicate for the first invocation of operation
\texttt{A}. That is,
\begin{lstlisting}
per A => #req(A) = 0
\end{lstlisting}
would always block.

\end{description}

\subsection{Evaluation of Guards}

Using the previous example, consider the following situation: the web
server is handling 10 \texttt{RetrieveURL} requests already. While it
is dealing with these requests, two further \texttt{RetrieveURL}
requests (from objects $O_1$ and $O_2$) and one \texttt{ExecuteCGI}
request (from object $O_3$) are received. The permission predicates
for these two operations are false since the number of active
\texttt{RetrieveURL} operations is already 10. Thus these objects
block.

Then, one of the active \texttt{RetrieveURL} operations reaches
completion. The permission predicate so far blocking $O_1$, $O_2$ and
$O_3$ will become ``true'' simultaneously.
This raises the question: which object is allowed to proceed? Or even
all of them?

Guard expressions are only reevaluated when an event occurs (in this
case the completion of a \texttt{RetrieveURL} operation). In addition to
that the test of a permission predicate by an object and its (potential)
activation is an atomic operation. This means, that when the first
object evaluates its guard expression, it will find it to be true and
activate the corresponding operation (\texttt{RetrieveURL} or
\texttt{ExecuteCGI} in this case). The other objects evaluating their
guard expressions afterwards will find that
\keyw{\#active}{\tt (RetrieveURL) +} \keyw{\#active}{\tt (ExecuteCGI) = 10}
and thus remain blocked. \textit{Which object is allowed to evaluate the guard
expression first is undefined.}

It is important to understand that the guard expression need only
evaluate to \keyw{true} at the time of the activation. In the
example as soon as $O_1$, $O_2$ or $O_3$'s request is activated its
guard expression becomes false again.


\section{Inheritance of Synchronization Constraints}
\label{ch:sync-inh}

Synchronization constraints specified in a superclass are inherited by
its subclass(es).
The manner in which this occurs depends on
the kind of synchronization.

\subsection{Mutex constraints}
Mutex constraints from base classes and derived classes are
simply added. If the base class and derived class have the mutex
definitions {$M_{A}$} and {$M_{B}$}, respectively, then the derived
class simply has both mutex constraints {$M_{A}$}, and
{$M_{B}$}. The binding of operation names to actual operations is
always performed in the class where the constraint is
defined. Therefore a \keyw{mutex(all)} constraint defined in a
superclass and inherited by a subclass only makes the operations from
the base class mutually exclusive and does not affect operations of
the derived class.

Inheritance of mutex constraints is completely analogous to the
inheritance scheme for  permission predicates. Internally mutex
constraints are always expanded into appropriate permission predicates
which are added to the existing permission predicates as a
conjunction. This inheritance scheme ensures that the result (the
final permission predicate) is the same, regardless of whether the mutex
definitions are expanded in the base class and inherited as permission
predicates or are inherited as mutex definitions and only expanded in
the derived class.

The intention for inheriting synchronization constraints in the way
presented is to ensure, that any derived class at least
satisfies the constraints of the base class.  In addition to that it
must be possible to strengthen the synchronization constraints. This
can be necessary if the derived class adds new operations as in the
following example:
\begin{lstlisting}
class A
operations

  writer: () ==> ()
  writer() == is not yet specified

  reader: () ==> ()
  reader() == is not yet specified

  sync
  per reader => #active(writer) = 0;
  per writer => #active(reader, writer) = 0;
end A

class B is subclass of A
operations

  newWriter: () ==> ()
  newWriter() == is not yet specified

  sync
  per reader => #active(newWriter) = 0;
  per writer => #active(newWriter) = 0;
  per newWriter => #active(reader, writer, newWriter) = 0;

end B
\end{lstlisting}

Class \texttt{A} implements reader and writer operations with the permission
predicates specifying the multiple readers-single writer protocol. The
derived class \texttt{B} adds \texttt{newWriter}. In order to ensure
deterministic behaviour \texttt{B} also has to add permission
predicates for the inherited operations.

The actual permission predicates in the derived class
are therefore:
\begin{lstlisting}
per reader => #active(writer)=0 and #active(newWriter)=0;
per writer => #active(reader, writer)=0 and #active(newWriter)=0;
per newWriter => #active(reader, writer, newWriter)=0;
\end{lstlisting}

A special situation arises when a subclass overrides an
operation from the base class. The overriding operation is
treated as a new operation.  It has no permission predicate (and in
particular inherits none) unless one is defined in the subclass.

The semantics of inheriting mutex constraints for overridden
operations is completely analogous: newly defined overriding
operations are not restricted by mutex definitions for equally named
operations in the base class. The \keyw{mutex(all)} shorthand makes all
inherited and locally defined operations mutually
exclusive. Overridden operations (defined in a base class) are not
affected. In other words, all operations, that can be called with an
unqualified name (``locally visible operations'') will be mutex to
each other.

\chapter{Threads (VDM++ and VDM-RT)}\label{ch:thread}

Objects instantiated from a class with a {\em thread} part are called
{\em active} objects.  The scope of the instance variables and
operations of the current class is considered to extend to the thread
specification. Note that from a tool perspective the thread for the
expression a user would like to evaluate in relation to a VDM model is
called a debug thread. This thread has a special role in the sense
that when it is finished the entire execution is completed (and thus
all other threads ready to be scheduled in or running will be thrown
away and aborted). If a session where a series of expressions are
being evaluated this is not true (in this case the other threads will
be continued when the next expression is executed,
see~\cite{Larsen&13a} for more details about ``sessions'').
Thus if one would like to ensure a specific number
of such other threads to be completed before stopping the execution
one needs to block the debug thread using a synchronisation as
explained in Chapter~\ref{ch:sync}.

\begin{description}
\item[Syntax:]  \Ruledef{thread definitions}{ \Lop{thread},
\OptPt{\Ruleref{thread definition}} } \Rule{thread definition}{
    \Ruleref{periodic thread definition} \dsep
    \Ruleref{procedural thread definition} }

  \Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation}  \dsep
    \Ruleref{sporadic obligation}
  }
\end{description}

Subclasses inherit threads from superclasses.
If a class inherits from several classes only one of these may declare
its own thread (possibly through inheritance). Furthermore, explicitly
declaring a thread in a subclass will override any inherited thread.

\section{Periodic Thread Definitions (VDM-RT)}\label{se:periodic-thread}

The periodic obligation can be regarded as the way of describing repetitive activities in a class.
As the `period' implies a explicit notion of time, this construct is only available in VDM-RT.

\begin{description}
%\item[Syntax (VDM++):] For VDM++, where time is not explicit, it looks like:
%
%\Ruledef{periodic obligation}{
%  \Lop{periodic},\Lit{(}, \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
%}
%
%\item[Semantics (VDM++):] The type of the expression should always yield a natural number, otherwise a run-time error will occur. The expression denotes the size of the time slice, after which the operation \Lop{name} is called, repetitively. The size of the time slice can be used to specify \emph{execution ratios} between multiple periodic threads in VDM++. Its behavior in relation to the other parts of the specification is defined by the interpreter settings with respect to time slicing and scheduling. Note however, that these values have \emph{no} explicit relation to real time.

\item[Syntax(VDM-RT):] Time is explicit in VDM-RT, using a discrete clock with a 1~nsec resolution, where the periodic obligation looks like:

  \Ruledef{periodic obligation}{
    \Lop{periodic},
    \Lit{(}, 4 * \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
  }

\item[Semantics (VDM-RT):] The type of the expressions should all yield a natural number (as we use a natural number valued wall-clock in the VDM-RT interpreter), otherwise a run-time error will occur. Note that the evaluation of the expressions also causes time to elapse whenever the \Lop{start} or \Lop{start\_list} statement is executed. The expressions all denote a time value with a resolution of 1~nsec.
For each periodic obligation, four different numbers are used. They are, in order
of appearance (also illustrated in Figure~\ref{fig:PeriodJitterDelayOffset}):

\begin{enumerate}
\item \textbf{period:} This is a non-negative, non-zero value that describes the length of the
time interval between two adjacent events in a strictly periodic event stream (where jitter = 0). Hence, a value of 1E9 denotes a period of 1~second.
\item \textbf{jitter:} This is a non-negative value that describes the amount of time variance that is allowed
around a single event. We assume that the interval is balanced [-j, j]. Note that jitter is
allowed to be bigger than the period to characterize so-called event bursts.
\item \textbf{delay:} This is a non-negative value smaller than the period which is used to denote the minimum
inter arrival distance between two adjacent events.
\item \textbf{offset:} This is a non-negative value which is used to denote the absolute time value at which
the first period of the event stream starts. Note that the first event occurs in the interval
[offset, offset + jitter].
\end{enumerate}

\begin{figure}
\begin{center}
\resizebox{0.8\textwidth}{!}{\includegraphics{pjdoTuple.png}}
\caption{{Period (p), jitter (j), delay (d) and offset (o)}\label{fig:PeriodJitterDelayOffset}}
\end{center}
\end{figure}

Given a defined time resolution $\Delta$T, a thread with a periodic
obligation invokes the mentioned operation at the beginning of each
time interval with length {\em period}.  This creates the periodic
execution of the operation simulating the discrete equivalent of
continuous relations which have to be maintained between instance
variables, parameter values and possibly other external values
obtained through operation invocations.  It is not possible to dynamically 
change the length of the interval.

Periodic obligations are intended to describe e.g.\
analogue physical relations between values in formulas (e.g.\ transfer
functions) and their discrete event simulation.
It is a requirement on the implementation to
guarantee that the execution time of the operation is at least smaller
than the used periodic time length.
If other operations are present the user has to guarantee that
the fairness criteria for the invocation of these other operations are
maintained by reasoning about the time slices used internally and
available for external invocations.

Note that a periodic thread is \textit{neither} created \textit{nor} started when an instance
of the corresponding class is created. Instead, as with procedural threads,
\Lop{start} (or \Lop{start\_list}) statements should be used with periodic threads.


\item[Examples:]
Consider a timer class which periodically increments its  clock in its
own thread. It provides operations for starting, and stopping timing,
and reading the current time.

\begin{lstlisting}
class Timer
values
  PERIOD : nat = 1000
\end{lstlisting}

The Timer has two instance variables the current time and a flag
indicating whether the Timer is active or not (the current time is
only incremented if the Timer is active).
\begin{lstlisting}
instance variables
  curTime : nat := 0;
  acti    : bool := false;
\end{lstlisting}

The Timer provides straightforward operations which need no further
explanation.
\begin{lstlisting}
operations
  public Start : () ==> ()
  Start() ==
    (acti := true;
     curTime := 0);

  public Stop : () ==> ()
  Stop() ==
    acti := false;

  public GetTime : () ==> nat
  GetTime() ==
    return curTime;

  IncTime: () ==> ()
  IncTime() ==
    if acti
    then curTime := curTime + 100;
\end{lstlisting}

The Timer's thread ensures that the current time is incremented. The period 
with which this is done is 1000 time units (nanoseconds). The allowed jitter is 10 time units
and the minimal distance between two instances is 200 time units and finally
no offset has been used.
%We take one time unit for the Timer to correspond to 10 system time units.

\begin{lstlisting}
thread
  periodic (PERIOD, PERIOD/100, PERIOD/5, 0) (IncTime)

end Timer
\end{lstlisting}

\end{description}


\section{Sporadic Thread Definitions (VDM-RT)}\label{se:sporadic-thread}

The sporadic obligation can be regarded as the way
of describing stochastic activities in a class.

\begin{description}
\item[Syntax: (VDM-RT):]\mbox{}\\

  \Ruledef{sporadic obligation}{
    \Lop{sporadic}, \Lit{(}, 3 * \Ruleref{expression},
    \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
  }

\item[Semantics: (VDM-RT)] The type of the expressions should all yield a natural number (as we use a natural number valued wall-clock in the VDM-RT interpreter), otherwise a run-time error will occur. Note that the evaluation of the expressions also causes time to elapse whenever the \Lop{start} or \Lop{start\_list} statement is executed. The expressions all denote a time value with a resolution of 1~nsec.
For each sporadic obligation, three different numbers are used. They are, in order
of appearance:

\begin{enumerate}
\item \textbf{delay:} This value is used to denote the minimum
inter arrival distance between two adjacent thread invocations.
\item \textbf{bound:} This value, greater than \textbf{delay}, is the maximum inter arrival distance between two adjacent thread invocations.
\item \textbf{offset:} This is a non-negative value which is used to denote the absolute time value at which the first period starts, randomly in the interval $[offset, offset + bound]$.
\end{enumerate}

Given these definitions, and assuming the last thread was invoked at $t_0$ then the next invocation is randomly scheduled in the interval $[t_0 + delay, t_0 + bound]$.

\item[Examples:]

Analogous to the example in \Lop{periodic} for the \texttt{Timer} class, the sporadic definition could be as follows:

\begin{lstlisting}
class Timer
...

thread
  sporadic (100, 1000, 0) (IncTime)

end Timer
\end{lstlisting}

\end{description}

\section{Procedural Thread Definitions (VDM++ and VDM-RT)}\label{se:proc-thread}

A procedural thread provides a mechanism to explicitly define the
external behaviour of an active object through the use of {\em
statements}, which are executed when the object is started (see
section \ref{sec:start}).
%Apart from the statements which are allowed
%in operation bodies (as described in  section \ref{sec:stmt}), it is
%also possible to use {\em answer statements} and {\em select
%statements}.
%based on similar constructs in the language {\small
%POOL}~\cite{Boer91}.
%These allow conditional behaviour within the thread depending on the
%environment.  An answer statement explicitly states that the object
%executing it is prepared to execute a (set of) operation(s).  A select
%statement specifies the conditional execution of operations.

\begin{description}
\item[Syntax:]
  \Ruledef{procedural thread definition}{
    \Ruleref{statement} }

%  \Rule{select statement}{
%    \Lop{sel},
%    \Lit{(},
%    \Ruleref{guarded command}, \lfeed
%    \SeqPt{\Lit{,},
%          \Ruleref{guarded command}},
%    \Lit{)}
%  }

%  \Rule{guarded command}{
%    \OptPt{\Ruleref{expression}},
%    \OptPt{\Ruleref{answer statement}}, \lfeed
%    \OptPt{\Lop{$->$},
%    \Ruleref{statement}}
%  }

%  \Rule{answer statement}{
%    \Lop{answer},
%    \Brack{\Ruleref{name} \dsepl
%    \Lop{all}}
%  }

\item[Semantics:] \mbox{}
A procedural thread is scheduled for execution following the
application of a start statement to the object owning the thread. The
statements in the thread are then executed sequentially, and when
execution of the statements is complete, the thread
dies. Synchronization between multiple threads is achieved using
permission predicates on shared objects.
%Select statements and answer statements can
%occur at any place in a thread and allow conditional execution of the
%thread on the basis of operation invocation requests received by the
%thread. Any number of select and answer statements may occur in a
%thread definition, and they may be freely mixed with other
%statements. Note that select and answer statements may only used in
%active objects (threads), though this restriction is presently not
%enforced by the Toolbox.
%
%The following provisos apply:
%\begin{itemize}
%\item {\em guarded command} may not be empty; it must contain one {\em
%expression}, {\em answer statement} or {\em statement} at minimum.
%\item {\em expression} in {\em guarded command} must be boolean (if it
%is absent its default value is {\bf\ttfamily true}).
%\item {\em name} in the rule for {\em answer statement} must be
%defined in the class or in one of its superclasses.
%\end{itemize}
%Guards without an answer statement can be used to describe the {\em
%else} behaviour of the select statement.
%
%An answer statement \texttt{\keyw{answer} o} waits until the thread
%receives a request for operation \texttt{o}. It then executes this and
%the statement terminates. The \texttt{\keyw{answer all}} statement
%waits until the thread receives a request for any operation defined in
%that class (or superclass), executes that operation and then
%terminates.
%
%The general form of the select statement is
%\begin{lstlisting}
%  \keyw{sel}
%     guard1, \keyw{answer} o1 -> s1,
%       \vdots
%     guardN, \keyw{answer} oN -> sN;
%\end{lstlisting}
%Each line after the \texttt{sel} is a guarded command. For each
%guarded command, each of the guard, answer statement,  and statement
%is optional, but at least one of them must appear.
%
%The select statement is then executed as follows:
%\begin{description}
%\item[Step 1:] All conditions of the guarded command \texttt{guard1}
%$\ldots$ \texttt{guardN} are evaluated.  The guards whose conditions
%result in false are discarded.  The remainder are known as {\em open}
%guards.
%\item[Step 2:] The set of operation names occurring in the answer
%statements of the open guards is determined ({\em open operation
%set}).  The set of all invocations of operations within the open
%operation set is determined (the open invocation set).
%
%We then have three choices
%\begin{description}
%\item[Choice 1] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are open guards without an answer statement
%\end{itemize}
%  then an arbitrary open guard without an answer statement is selected
%  and   its associated statement sequence is executed.  The select
%  statement then terminates.
%\item[Choice 2] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are {\em no} open guards without an answer statement
%\end{itemize}
%then the thread waits until an operation in the open operation set is
%invoked by another object. Following completion of this operation the
%corresponding statement is executed. After this the select statement
%terminates.
%\item[Choice 3] If the set of invocations is {\em not} empty then the
%invocation in the open invocation set which was received first is
%selected. An arbitrary guard with an answer statement matching the
%invoked operation is selected. The operation is executed and after
%that the statement sequence associated with that guard is
%executed. Following this the select statement terminates.
%\end{description}
%\end{description}
%
%In addition to the basic mechanism described above a few points are
%worth noting:
%\begin{itemize}
%\item A select statement must always contain at least one {\em open}
%guard.
%\item A calling object will block until its call is answered by the
%select statement.
%\item The calling object and the thread synchronize on the operation
%call. However if a guarded command includes an answer statement and a
%statement to be executed afterwards, synchronization only occurs on
%the operation named in the answer statement. That is, the calling
%object may proceed following completion of the operation, and does not
%wait for execution of the statement listed in the guarded command.
%\end{itemize}
%
\item[Examples:]  \mbox{}
The example below demonstrates procedural threads by using them to
compute the factorial of a given integer concurrently.

\begin{lstlisting}
class Factorial

instance variables
  result : nat := 5;
operations

public factorial : nat ==> nat
factorial(n) ==
  if n = 0
  then return 1
  else (dcl m : Multiplier;
        m := new Multiplier();
        m.calculate(1,n);
        start(m);
        result:= m.giveResult();
        return result
      )

end Factorial

class Multiplier

instance variables
  i : nat1;
  j : nat1;
  k : nat1;
  result : nat1

operations

public calculate : nat1 * nat1 ==> ()
calculate (first, last) ==
  (i := first; j := last);

doit : () ==> ()
doit() ==
( if i = j
  then result := i
  else (dcl p : Multiplier;
        dcl q : Multiplier;
        p := new Multiplier();
        q := new Multiplier();
        start(p);
        start(q);
        k := (i + j) div 2;
        -- division with rounding down
        p.calculate(i,k);
        q.calculate(k+1,j);
        result := p.giveResult() *  q.giveResult ()
       )
);

public giveResult : () ==> nat1
giveResult() ==
  return result;

sync
-- cyclic constraints allowing only the
-- sequence calculate; doit; giveResult

per doit => #fin (calculate) > #act(doit);
per giveResult => #fin (doit) > #act (giveResult);
per calculate => #fin (giveResult) = #act (calculate)

thread
  doit();

end Multiplier
\end{lstlisting}



%First we consider some examples which illustrate the
%basic mechanism of select statements. Suppose we have a thread with
%instance variables \texttt{x:\keyw{nat}}, \texttt{y:\keyw{nat}} and
%\texttt{l:\keyw{seq1 of nat}}, and operations \texttt{o1} and
%\texttt{o2}. Consider the following select statement:
%\begin{lstlisting}
%  \keyw{sel} (
%    x <= 0, \keyw{answer} o1 -> x:= 1,     -- gc1
%    x >= 0,\mbox{\hspace{0.2em}}          -> y := x,    -- gc2
%            \keyw{answer} o2 -> l := [1]   -- gc3 )
%\end{lstlisting}
%We consider a number of different scenarios:
%\begin{enumerate}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc1}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set consists of only \texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, \texttt{gc2} is open and has no answer
%statement. Therefore choice 1 is taken. The statement \texttt{y := x}
%is executed then the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & -3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} &
%[1,2,3]\\ \hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc2}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, and there are no open guards without an answer
%statement. Therefore choice 2 is taken and the thread waits. While it
%waits it can only respond to invocations of \texttt{o1} or
%\texttt{o2}. Suppose then that while waiting it receives a call to
%\texttt{o1}: \texttt{o1} is executed, then the statement \texttt{x :=
%1} is executed and the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and invocations have been received for operations \texttt{o1} and
%\texttt{o2} (\texttt{o2} arriving first).
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Now since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc3} is selected because the invocation of
%\texttt{o2} was received first. \texttt{o2} is executed and on
%completion the statement \texttt{l := [y]} is executed. The select
%statement then terminates.
%\end{description}
%
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and an invocation has been received for operation \texttt{o1}.
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains only \texttt{o1}.
%\item[Choice] Again, since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc1} is selected  and \texttt{o1} is
%executed. On completion the statement \texttt{ x:= 1} is executed. The
%select statement then terminates.
%\end{description}
%\end{enumerate}
%
%We now give a more complex example.  Suppose we wish to model the
%behaviour of an ATM machine. We might have the following instance
%variables:
%\begin{lstlisting}
%  \keyw{instance variables}
%    status : <InService> | <OutOfService> |  <CardInserted> |
%             <CardAccepted> := <InService>;
%    currentCard : [ATMCard] := \keyw{nil};
%    pinTries : \keyw{nat} := 0;
%    balance :  \keyw{nat} := 10000;
%    keypad : Keypad := \keyw{new} Keypad();
%    accountDB : AccountDB := \keyw{new} AccountDB();
%    retained : \keyw{set} of ATMCard := \{\};
%\end{lstlisting}
%Here \texttt{ATMCard} is a class representing an ATM card,
%\texttt{Keypad} is a simple object that models digit entry by the
%user, and \texttt{AccountDB} is an object modelling the mapping from
%card numbers to account details.
%
%We might wish to perform the following operations on this class (for
%brevity we do not include their definition here):
%
%\begin{tabular}{lll}
%\texttt{EnterCard :} & \texttt{ATMCard ==> ()}  & Enter a card into
%                          the machine\\
%\texttt{GetPin :}    & \texttt{() ==> ()}       & Get the PIN digits typed
%                                                  at \\
%                     &                          & the keypad\\
%\texttt{VerifyPin:}  & \texttt{\keyw{nat} ==> ()}
%                                                & Check the validity of the PIN \\
%                     &                          & given\\
%\texttt{RetainCard :}& \texttt{() ==> ()}       & Retain the card if three failed\\
%                     &                          & attempts to enter the PIN\\
%\texttt{WithdrawCash :}
%                     & \texttt{\keyw{nat} ==> ()}
%                                                & Withdraw cash\\
%\texttt{WithdrawCard :}
%                     & \texttt{() ==> ()}       & Withdraw card from the \\
%                     &                          & machine\\
%\texttt{ReplenishMachine :}
%                    & \texttt{() ==> ()}        & Refill machine with cash
%\end{tabular}
%
%Then we might specify the thread behaviour of this class as follows:
%\begin{lstlisting}
%    \keyw{while true do}
%      \keyw{if} status = <InService>
%      \keyw{then} (
%        \keyw{sel} (\keyw{answer} EnterCard);
%        \keyw{while} status <> <InService> \keyw{do}
%          \keyw{sel} ( status = <CardInserted> \keyw{and} pinTries < 3
%                               \keyw{answer} GetPin,
%               status = <CardInserted> \keyw{and} pinTries = 3
%                               -> RetainCard(),
%               status = <CardAccepted> \keyw{and} balance > 300
%                               \keyw{answer} WithdrawCash,
%               status = <CardAccepted> \keyw{answer} WithdrawCard
%              );
%        \keyw{if} balance <= 300
%        \keyw{then} status := <OutOfService> )
%      \keyw{else}
%        \keyw{sel} (status = <OutOfService> \keyw{answer} ReplenishMachine);
%\end{lstlisting}
%This thread repeatedly loops until the object is destroyed. Within
%this loop behaviour diverges according to whether \texttt{status =
%<InService>} or not. Initially the status is \texttt{<InService>} so
%the \texttt{then} clause will be executed. The thread will then wait
%until a card is entered into the machine.
%
%Following this we loop until the status returns to
%\texttt{<InService>}, which only occurs when the operations
%\texttt{WithdrawCard} or \texttt{RetainCard} are executed. Within this
%loop the thread conditionally allows invocations of the operations
%\texttt{GetPin}, \texttt{WithdrawCash} and
%\texttt{WithdrawCard}. Additionally the thread invokes
%\texttt{RetainCard} itself once 3 unsuccessful attempts have been made
%to enter a pin code.
%
%When this loop is exited the status is \texttt{<InService>}. However
%if insufficient cash is left in the machine it goes out of
%service. This terminates the \texttt{then} clause.
%
%In the \texttt{else} clause, it can be seen that the only way this
%clause can be entered is if the status is
%\texttt{<OutOfService>}. Thus the thread waits until the machine is
%replenished.
%
%Observe that in the second \keyw{sel} statement, if (\texttt{status =
%<CardAccepted>
%\keyw{and} balance > 300}) then the thread could behave
%non-deterministically, since two guards would be open simultaneously.
%
\end{description}
%
%Note that the two methods of specifying synchronization (permission
%predicates %, trace structures
%and answer statements) should not be
%mixed in a class specification: only one of these may be used.
%
%A procedural thread definition has precedence over a
%synchronization specification in a class; when using this way of
%specification, the full external behaviour of an active object has to
%be specified (i.e. for each operation an answer statement must be
%present).  The synchronization definitions can then be derived
%from the procedural thread.  If there is a contradiction between
%synchronization derived from the procedural thread and the specified
%synchronization behaviour then the class is erroneous.

%\section{Inheriting from Active Objects}
%\label{ch:thread-inh}
%
%Threads can, in some cases, be inherited in {\vdmpp}; the situations in which
%this is allowed are determined by whether or not there exists
%a sensible interpretation of polymorphism between active objects (see Section
%\ref{sec:polyao}). The different situations in which inheriting from
%active superclasses is allowed is summarized in the following table:
%
%{\small
%\begin{center}
%\begin{tabular}{|c||c|c|c|c|c|}
%\hline
%& & & {\em active,} & {\em active,}\\
%superclass & {\em none} & {\em passive} & {\em declarative} & {\em procedural}\\
%& & & {\em thread} & {\em thread}\\
%\hline
%\hline
%& & behaviour as & inheritance & inheritance\\
%{\em none} & --- & defined by & allowed, see & allowed, see\\
%& & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%& behaviour as & behaviour as & inheritance & inheritance \\
%{\em passive} & defined by & defined by & allowed, see & allowed, see \\
%& the subclass & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em declarative} & allowed, see & allowed, see & allowed, see & {\bf not} \\
%{\em thread} & Section \ref{decinh} & Section \ref{decinh} & Section \ref{decinh} & allowed\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em procedural} & allowed, see & allowed, see & {\bf not} & allowed, see \\
%{\em thread} & Section \ref{procinh} & Section \ref{procinh} & allowed & Section \ref{procinh} \\
%\hline
%\end{tabular}
%\end{center}}
%
%\subsection{Polymorphism for Active Objects}\label{sec:polyao}
%
%A basic issue for understanding polymorphism for active objects
%is the notion of risk of interference caused by the thread of such objects.
%A basic understanding to this is provided by the Bernstein rules.
% (see e.g. \cite{bernstein66} or \cite[pages 289--290]{peterson}).
%Bernstein defines the {\em read-set} $R$ for statement $S_i$, $\fnapply{R}{S_i} = \setrange{a_1, a_2}{a_n}$, as:
%\begin{quote}
%the set of all variables referenced in statement $S_i$, such that the value
%of each $a_j$ did not change during the execution of $S_i$.
%\end{quote}
%The {\em write-set} $W$ for statement $S_i$, $\fnapply{W}{S_i}= \setrange{b_1,
%b_2}{b_n}$, is then defined as:
%\begin{quote}
%the set of all variables referenced in
%statement $S_i$ such that each $b_j$ is
%updated (i.e. gets a new value) in $S_i$.
%\end{quote}
%
%The following three conditions must hold for two successive statements
%(say: $S_1$ and $S_2$) in order to be executed concurrently and always
%produce the same result as if they were executed sequentially (the
%Bernstein conditions):
%\begin{enumerate}
%\item
%$\fnapply{R}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\end{enumerate}
%
%As an example, consider two statements $S_1$ and $S_2$. Suppose that
%$S_1$ updates a variable $b$, and that $S_2$ is defined as
%$\ass{c}{a + b}$. Since
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \set{b}$, concurrent
%execution of $S_1$ and $S_2$ is not allowed.
%
%In a similar fashion, in {\vdmpp} the read- and write-sets can be defined
%for threads in terms of instance variables.
%
%For presentation purposes a distinction is made between active objects with
%a {\em declarative} thread (periodic obligation) and those with a
%{\em procedural} thread (sequence of statements using answer and select
%statements).
%
%\subsection{Declarative Threads}\label{decinh}
%
%Consider two classes {\tt A} and {\tt B} with a periodic obligation,
%for {\tt A}, say, defined as:
%  \begin{lstlisting}
%    periodic (intervalA)(mA)
%  \end{lstlisting}
%and for {\tt B}, say, defined as:
%  \begin{lstlisting}
%    periodic (intervalB)(mB)
%  \end{lstlisting}
%then a class {\tt C}, defined as subclass of both {\tt A} and {\tt B},
%has a new thread with {\it two} periodic obligations, e.g. graphically
%depicted as follows:
%\ \\
%\ \\
%\insertfig{2periodic}{14cm}{Periodic obligations for class C}{}
%
%
%\subsection{Procedural Threads}\label{procinh}
%
%Polymorphism for active objects of which the behaviour is defined using
%procedural threads instead of declarative threads is more complicated.
%In {\vdmpp} it is only considered for classes with a non-terminating
%behaviour\footnote{It is possible to define terminating threads, implying that
%these (initially) {\it active} objects become {\it passive} after some time.},
%e.g. defined using a loop, typically:
%  \begin{lstlisting}
%    while true do\\
%    sel (
%      condA -> answer mA,
%      condB -> answer mB,
%      ...
%      condN -> answer mN
%    )
%  \end{lstlisting}
%or
%  \begin{lstlisting}
%    while true do
%    answer mA;
%    answer mB;
%    ...
%    answer mN
%  \end{lstlisting}
%
%Procedural threads of these forms define `answer-sets/sequences', i.e.
%sets or sequences defining the possible (orders of) operations these
%objects will answer to.
%Defining a subclass of two classes with such definitions implies that
%the subclass has an answer-sets/sequence composed by taking the union
%or weaving the two answer-sets/sequences of the superclasses into one another.
%So, suppose that objects from class {\tt A} respond to
%
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n}
%\end{expr}
%\end{vdm}
%and that objects from class {\tt B} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_{n+1}, m_{n+2}}{m_p}
%\end{expr}
%\end{vdm}
%and that class {\tt C} is a subclass of both {\tt A} and {\tt B}, then
%objects from class {\tt C} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n, m_{n+1}, m_{n+2}, \ldots, m_p}
%\end{expr}
%\end{vdm}
%
%Because the scope in which the instance variables of
%an object are visible includes the procedural thread, a proof obligation is
%raised to satisfy the Bernstein conditions.
%No problems arise in the simple case where {\tt C} is a subclass of
%{\tt A} and {\tt B} and no further coupling is made in {\tt C}
%between the instance variables of {\tt A} and {\tt B} -- the threads of
%{\tt A} and {\tt B} in {\tt C} only affect the {\tt A} and {\tt B} part
%of the instance variables in {\tt C},
%respectively, hence the Bernstein conditions are always satisfied.
%If, however, a connection is made in {\tt C} between the two state parts
%through an invariant, then it is no longer guaranteed that the Bernstein
%conditions are satisfied.

%\cleardoublepage
%\chapter{Real-time Behaviour}\label{ch:rt}
%
%For the description of requirements and the behaviour of a system
%(component) in real time a small number of concepts suffice.  These
%concepts are based on
%references~\cite{Hayes90,Mahony&91a,Mahony&91b,Mahony92,Mahony&92}.
%At first the time continuous functions are defined and introduced as
%{\em time variables}. Existing concepts like pre-conditions,
%post-\-cond\-it\-ions, hooked values etc. are overloaded with their
%time aspects.
%
%For a complete (sub)system a development process starting in the
%continuous time domain is envisaged.  The initial input-output
%relations from the requirements can be decomposed into a topology of
%subcomponents through refinement steps in the continuous time domain.
%The continuous behaviour of the topology of the derived objects can be
%mapped on equivalent objects, which operate themselves sequentially in
%a discrete time domain.  Relations between the continuous and the
%discrete objects are established through inheritance.  The resulting
%objects can follow the more common {\vdmpp} refinement steps with
%additional descriptions and rules for their time behaviour. The
%resulting time behaviour of the lower level objects in the
%specification will give the limitations/requirements for the component
%implementation.
%
%Time continuous variables appear in classes with a special role
%in the specification. Spreading these functions in arbitrary places is not
%foreseen.
%
%\section{Time continuous Functions}
%\label{sec:timeexpr}
%
%Time continuous functions are those in which time can be assumed to
%increase continuously and implicitly, thus without any influence from
%the specification.
%
%At the input side of a system {\em assumptions} can be made about
%these continuous signals. In many cases these assumptions will
%represent the physical properties of the real-world signals and the
%available sensors in the environment.  Such an assumption is
%functionally equivalent to a {\em pre-condition}.  There is no way of
%enforcing this condition, however, because the environment is in
%principle beyond the scope of control of the system specifier.  The
%consequence of this observation is that the correct behaviour of the
%system can only be guaranteed for those time periods where these
%assumptions are met.  In all other cases the system will react in an
%undefined way or not at all.  In other words: the assumptions on input
%signals are environmental requirements.
%
%The syntactical representation of time continuous variables is
%realised through a syntactic block comparable with the instance
%variables block, beginning with the keyword {\tt time variables}. Then
%the declaration of the names of the time functions follow.  The
%function value changes over time either according to a given formula,
%with the time as an independent variable, or changes as an observation
%value of a physical quantity in the environment.
%
%\begin{description}
%\item[Syntax:]
%\Rule{time variable definitions}{\Lop{time}, \Lop{variables},
%      time spec, \SeqPt{\Lit{;}, time spec}, \OptPt{\Lop{;}}}
%\Rule{time spec}{time var decl \dsep assumption \dsep effect}
%\Rule{time var decl}{\OptPt{\Lop{input}}, name list, \Lit{:}, type}
%\Rule{assumption}{\Lop{assumption}, name list, \Lit{==}, expression}
%\Rule{effect}{\Lop{effect}, name list, \Lit{==}, expression}
%
%\item[Semantics:] If instances are created from a continuous class
%(and used through clientship by other objects) each object represents
%a distinct time continuous function which has in principle no relation
%with the functions in the other instances, i.e. different
%observations.  The following rules hold:
%
%\begin{itemize}
%\item If different subclasses are inheriting from the same continuous
%  superclass, they share the same function, i.e. the same observation of
%  the environment.
%\item If instances are created from a continuous class (and used
%  through clientship by other objects) each object represents a distinct
%  time continuous function which has in principle no relation with the
%  functions in the other instances, i.e. different observations.
%\item Sharing of the information available in an object as server for
%  more than one client object, has to be realised by referencing through
%  clientship to the same server object.
%\end{itemize}
%
%This interpretation can be used e.g. with a number of sensors for the
%temperature in a room; they measure the local temperature in a certain area
%Sharing of the information available can be achieved by using
%an object as server form more
%than one client object.
%The local temperature variations are discarded and
%only one room temperature is used in the model.
%
%A special clause can be added to a time continuous functions to denote
%assumptions over their behaviour.  The keywords used are {\tt
%assumptions} for input variables and {\tt effects} for output
%variables.
%
%The use of the operation interface is reserved for the discrete system
%behaviour and provides the specification of a sampling mechanism, when
%used on continuous variables.
%
%\item[Examples:] \mbox{}
%
%  \begin{lstlisting}
%  class SensorBehaviour
%
%    time variables
%      input theta: real;
%      input myinput: real;
%    assumption myinput == myinput (t) = a * sin (w * t)
%
%  end SensorBehaviour
%  \end{lstlisting}
%
%These functions are in another notation the continuous time functions:
%
%  \begin{lstlisting}
%    theta (t) = temperature (t)
%  \end{lstlisting}
%  and
%  \begin{lstlisting}
%    myinput (t) = a * sin (w * t)
%  \end{lstlisting}
%
%\end{description}
%
%\section{From Continuous Time to Discrete Time}
%
%\subsection{The input side}
%
%To express the way hardware/software based systems handle the continuous time
%problems a next refinement step will practically always mean the discretisizing
%of the continuous time functions. This means that a sampling mechanism has to
%be specified.
%
%The advised steps to specify this translation into the discrete time
%domain is to:
%
%\begin{enumerate}
%\item Inherit into a new {\vdmpp} class from the continuous class the time
%  function.
%\item Specify a sampling operation.
%\item Introduce a thread which regularly invokes this operation,
%  with sample frequency $f_s\;(=\; \frac{1}{\Delta t})$.
%\end{enumerate}
%
%Discrete sampling involves an approximation of the continuous value.
%If the interval length is $\Delta t$ in the interval $<t_1 , t_1 +
%\Delta t>$, a value within $F \ll t_1 \ldots t_1 + \Delta t \gg $ is
%returned as the discrete result. According to the theory of Shannon,
%the sampling frequency should be at least twice the highest frequency
%which is present in the input signal. The error in the approximation
%can be calculated with standard signal processing operations.
%
%The approximation in time is also needed to handle the fact, that discrete
%observations of ideal time continuous functions always include measurement
%errors, rounding off errors, limited accuracy, etc.
%
%\begin{description}
%\item[Examples:] The advised discretisizing operation as first
%  refinement for the continuous class is represented by the following
%  class based on the continuous temperature class:
%
%\begin{lstlisting}
%  class Sensor is subclass of SensorBehaviour
%
%    values
%      fs: real = undefined
%
%    instance variables
%      tempvalues: seq of real := [];
%      currvalue: real;
%    inv len tempvalues > 0 => currvalue = tempvalues(len)
%
%    operations
%      gettemp: () ==> ()
%      gettemp() ==
%      ( currvalue := theta(t);
%        tempvalues := tempvalues ^ [currvalue]
%      )
%
%   thread
%     periodic (1/fs)(gettemp)
%
%end Sensor
%\end{lstlisting}
%
%The introduced sequence of values now models the history of all
%samples.  In a normal case in which a $2^{nd}$ order differential
%equation can describe the system behaviour, the length can be reduced
%to three values: those at $t$, $t - \Delta t$ and $t - 2 \Delta t$
%will be sufficient.
%
%\end{description}
%
%\subsection{The output side}
%
%At the output side a similar approach can be used, although some special
%considerations are needed here.
%If the discrete class is the `producer' of a series of discrete values over
%time, the output of the system itself will be continuous again.
%Therefore, the impossibility for real signals to perform discontinuous behaviour
%has to be build in.
%
%\begin{description}
%\item[Example:] In class {\tt HeaterController} there is an instance
%variable {\tt controlvalue} which represented at each time the
%discrete value of the output of the controller.  The transformation
%backwards into the continuous domain is again performed with an
%operation which sets at discrete time intervals the value of the
%continuous time variable.  At the times in between these moments the
%effect constraint specifies the maximum rate that can be achieved in
%the continuous domain.
%
%The two classes can be specified as follows:
%  \begin{lstlisting}
%  class HCBehaviour
%
%    time variables
%      controloutput: real
%
%  end HCBehaviour
%
%  class HeaterController is subclass of HCBehaviour
%
%    instance variables
%      controlvalue: nat
%
%    operations
%      setheatercontrol: () ==> ()
%      setheatercontrol() ==
%        controloutput(now) := controloutput
%
%    thread
%      periodic (1/fs) (setheatercontrol)
%
%  end HeaterController
%  \end{lstlisting}
%\end{description}
%
%The relation between the momentary values coming from the discrete world to
%the continuous time functions requires some extra discussion.
%The specific relationship between the discrete value and its continuous
%counterpart requires the concept of controlled register-like variables in the
%continuous domain, which
%do not change in time between two successive updates by the operation.
%Given a sampling distance $\Delta t$ and an interval beginning at $t_i$ with
%a value $F(t_i)$, the step reaction
%of the system will take some time constant say $\tau$ with
%$\tau \leq \Delta t$ to stabilise the output value. This value $\tau$ can be
%derived from the effect constraint. This gives the following continuous time
%behaviour:
%\begin{itemize}
%\item
%$<t_i,t_i + \tau>$: the rate defined by constraint,
%value within $F \ll t_{i-1} \ldots t_i \gg$ or equivalently
%$[F(t_{i-1}),F(t_i)]$ excluding possible `overshoot';
%\item
%$<t_i + \tau ,t_i + \Delta t>$: value should have been stabilised on $F(t_i)$;
%\item
%at $t_i + \Delta t$: value is $F(t_i)$.
%\end{itemize}
%
%This time description is of course a kind of macro description of the
%continuous output value. By including the behaviour of more detailed output
%channel components one can refine the above mentioned intervals again.
%The above specification is effectively
%the behaviour of a certain digital-to-analogue converter.

\chapter{Trace Definitions}\label{chap:trace}

In order to automate the testing process VDM-10 contains a notation
enabling the expression of the traces that one would like to have
tested exhaustively. Such traces are used to express combinations of
sequences of operations that wish to be tested in all possible
combinations. In a sense this is similar to model checking limitations
except that this is done with real and not symbolic values. However,
errors in test cases are filtered away so other test cases with the
same prefix will be skipped automatically.

\begin{description}
\item[Syntax:]
\Ruledef{traces definitions}{\Lop{traces},
   \OptPt{\Ruleref{named trace}, \SeqPt{\Lit{;}, \Ruleref{named trace}}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term},
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition}, \SeqPt{\Lit{|}, \Ruleref{trace definition}}
}

\Rule{trace definition}{
  \Ruleref{trace binding definition} \dsep
  \Ruleref{trace repeat definition}
}

\Ruledef{trace binding definition}{
  \Ruleref{trace let def binding} \dsep
  \Ruleref{trace let best binding}
}

\Ruledef{trace let def binding}{
  \Lop{let}, \Ruleref{local definition},
  \SeqPt{ \Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace let best binding}{
  \Lop{let}, \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace repeat definition}{
  \Ruleref{trace core definition},
  \OptPt{\Ruleref{trace repeat pattern}}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \OptPt{\Lit{,}, \Ruleref{numeric literal}, \Lit{\}}}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace concurrent expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{call statement}
}

\Rule{trace concurrent expression}{
  \Lit{||}, \Lit{(}, \Ruleref{trace definition}, \lfeed
  \Lit{,}, \Ruleref{trace definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{trace definition}}, \Lit{)}
}

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\item[Semantics:] Semantically the trace definitions provided in a
             class have no effect. These definitions are simply used
             to enhance testing of a VDM specification using principles from
             combinatorial testing (also called all-pairs
             testing). So each trace definition can be considered as a
             regular expression describing the test sequences in which
             different operations should be executed to test the VDM
             specification. Inside the trace definitions, bindings may appear
             and for each possible binding a particular test case
             can be automatically derived. So one trace definition
             expands into a set of test cases. In this sense a test
             case is a sequence of operation calls executed after each
             other. Between each test case the VDM specification is
             initialised so they become entirely independent. From a
             static semantics perspective it is important to note that
             the expressions used inside trace definitions must be
             executed in the expansion process. This means that it
             cannot directly refer to instance variables, because
             these could be changed during the execution.

So here it makes sense to explain what kind of expansion the different
kinds of trace definitions gives rise to.

The \emph{trace definition lists} simply use a semicolon (``\texttt{;}'') and
this results in sequencing between the \emph{trace definition
  terms} used inside it.

In the \emph{trace definition term} it is possible to introduce
alternatives using the bar (``\texttt{|}'') operator. This results in
test cases for all alternatives.

The \emph{trace binding definition} exists in two forms where the
\emph{trace let def binding} simply enables the binding introduced to
be used after the \Lop{in} in the same way as in
let-expressions. Alternatively the \emph{trace let best binding} can
be used and this will expand to test cases with all the different
possible bindings.

The \emph{trace repeat definition} is used to introduce the
possibility of having repetitions of the operation calls used in the
trace.
The different kinds of repeat patterns have the following meanings:
\begin{itemize}
\item  \Lit{*} means 0 to n occurences (n is tool specific).
\item  \Lit{+} means 1 to n occurences (n is tool specific).
\item  \Lit{?} means 0 or 1 occurences.
\item  \Lit{\{}, n, \Lit{\}} means n occurences.
\item  \Lit{\{}, n, \Lit{,} m \Lit{\}} means between n and m occurences.
\end{itemize}

The \emph{trace core definitions} have three possibilities. These are
ordinary operation calls, trace concurrency expressions and bracketed
trace definitions respectively.
The \emph{trace concurrency expressions} are similar to the
\emph{nondeterministic statements} in the sense that the trace
definition lists inside it will be executed in all possible
permulations of the elements. This is particular useful for concurrent
VDM++ models where potential deadlocks can occur under some
circumstances.

\item[Examples:] In an example like the one below test cases will be
generated in all possible combination starting with a call
of \texttt{Reset} followed by one to four \texttt{Push}es of values
onto the stack followed again by one to three \texttt{Pop}s from the stack. \\
\begin{lstlisting}
class Stack

instance variables
    stack : seq of int := [];

operations

    public Reset : () ==> ()
    Reset () ==
      stack := [];

    public Pop : () ==> int
    Pop() ==
      def res = hd stack in
        (stack := tl stack;
         return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack;

    public Push: int ==> ()
    Push(elem) ==
      stack := stack ^ [elem];

    public Top : () ==> int
    Top() ==
      return (hd stack);

end Stack
class UseStack

instance variables

  s : Stack := new Stack();

traces

  PushBeforePop : s.Reset();
                  (let x in set {1,2} in s.Push(x)){1,4};
                  s.Pop(){1,3}

end UseStack
\end{lstlisting}
\end{description}



\bibliographystyle{newalpha}

\bibliography{../bib/dan}

\appendix

% Do not delete next line:
% Start Of Rules

\chapter{The Syntax of the VDM Languages} \label{app-a}

This appendix specifies the complete syntax for
the VDM languages.

\section{VDM-SL Document}

\Ruledef{document}{
  \Ruleref{module}, \SeqPt{\Ruleref{module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\subsection{Modules}

This entire subsection is not present in the current version of the
VDM-SL standard.
% \marginpar{\hspace*{-3mm}\fbox{{\footnotesize Non standard}}}

\Ruledef{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{interface}{
  \OptPt{\Ruleref{import definition list}}, \lfeed
  \Ruleref{export definition}
  }

\Ruledef{import definition list}{
  \Lop{imports}, \Ruleref{import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{import definition}}
  }

\Ruledef{import definition}{
  \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
  }

\Ruledef{import module signature}{
  \Lop{all} \dsep
  \Ruleref{import signature}, \SeqPt{\Ruleref{import signature}}
  }

\Ruledef{import signature}{
  \Ruleref{import types signature} \dsep
  \Ruleref{import values signature} \dsep
  \Ruleref{import functions signature} \dsep
  \Ruleref{import operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{import types signature}{
  \Lop{types}, \Ruleref{type import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
  }

\Ruledef{type import}{
  \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
  \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import values signature}{
  \Lop{values}, \Ruleref{value import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
  }

\Ruledef{value import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import functions signature}{
  \Lop{functions}, \Ruleref{function import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
  }

\Ruledef{function import}{
  \Ruleref{name}, \OptPt{\OptPt{type variable list},
  \Lit{:}, \Ruleref{function type}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import operations signature}{
  \Lop{operations}, \Ruleref{operation import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{export definition}{
  \Lop{exports}, \Ruleref{export module signature}
  }

\Ruledef{export module signature}{
  \Lop{all} \dsep
  \Ruleref{export signature}, \lfeed
  \SeqPt{\Ruleref{export signature}}
  }

\Ruledef{export signature}{
  \Ruleref{export types signature} \dsep
  \Ruleref{export values signature} \dsep
  \Ruleref{export functions signature} \dsep
  \Ruleref{export operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{export types signature}{
  \Lop{types}, \Ruleref{type export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
  }

\Ruledef{type export}{
  \OptPt{\Lop{struct}}, \Ruleref{name}
  }

\Ruledef{export values signature}{
  \Lop{values}, \Ruleref{value signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{value signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{export functions signature}{
  \Lop{functions}, \Ruleref{function signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{function signature}{
  \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:},  \lfeed
  \Ruleref{function type}
  }

\Ruledef{export operations signature}{
  \Lop{operations}, \Ruleref{operation signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
  }

%\Ruledef{state signature}{
%  \Lop{state}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
%  }

%\Ruledef{dynamic link module}{
%  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
%  \Ruleref{dynamic link interface},\lfeed
%  \OptPt{\Ruleref{use signature}},\lfeed
%  \Lop{end}, \Ruleref{identifier}
%  }

%\Ruledef{dynamic link interface}{
%  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
%  \Ruleref{dynamic link export definition}
%  }

%\Ruledef{use signature}{
%   \Lop{uselib}, \Ruleref{text literal}
%   }

%\Ruledef{dynamic link import definition list}{
%  \Lop{imports}, \lfeed
%  \Ruleref{dynamic link import definition}, \lfeed
%  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
%  }

%\Ruledef{dynamic link import definition}{
%  \Lop{from}, \Ruleref{identifier}, \lfeed
%  \Ruleref{dynamic link import types signatures}
%  }

%\Ruledef{dynamic link import types signatures}{
%  \Lop{types}, \Ruleref{name}, \lfeed
%  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
%  }

%\Ruledef{dynamic link export definition}{
%  \Lop{exports}, \lfeed
%  \Ruleref{dynamic link export signature}, \lfeed
%  \SeqPt{\Ruleref{dynamic link export signature}}
%  }

%\Ruledef{dynamic link export signature}{
%  \Ruleref{values signature} \dsep
%  \Ruleref{functions signature} \dsep
%  \Ruleref{operations signature}
%  }

\section{VDM++ and VDM-RT Document}

\Ruledef{document}{
   (\Ruleref{class}
   \dsepl\ \Ruleref{system})
   , \SeqPt{\Ruleref{class}
   \dsepl\ \Ruleref{system}
   }
}


\section{System (VDM-RT)}

\Ruledef{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}

\subsection{Classes}

\Ruledef{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}

\Ruledef{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
      }

\section{Definitions}

\Ruledef{class body}{
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{module body}{
  \Lop{definitions}, \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
  \dsep
  \Ruleref{instance variable definitions} \dsep
%  \Ruleref{time variable definitions} \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions} \dsep
  \Ruleref{traces definitions}
  }

\subsection{Type Definitions}
\label{mathCSTypeDefs}

\Ruledef{type definitions}{
  \Lop{types},
  \OptPt{\Ruleref{access type definition}
         , \lfeed
         \SeqPt{\Lit{;},
               {\Ruleref{access type definition}}},
         \OptPt{\Lit{;}}}
        }
%  }%
  \nonstandard{1}

  \Ruledef{access type definition}{
     (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}}  \dsepl\ \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
     \Ruleref{type definition}
    }

The access part is only possible in VDM++ and VDM-RT.

  \Ruledef{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }

\Ruledef{type definition}{
  \Ruleref{identifier}, \Lit{=}, \Ruleref{type}, \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{eq clause}}, \OptPt{\Ruleref{ord clause}} \dsep
  \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}, \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{eq clause}}, \OptPt{\Ruleref{ord clause}}
  }

\Ruledef{type}{
  \Ruleref{bracketed type} \dsep
  \Ruleref{basic type} \dsep
  \Ruleref{quote type} \dsep
  \Ruleref{composite type} \dsep
  \Ruleref{union type} \dsep
  \Ruleref{product type} \dsep
  \Ruleref{optional type} \dsep
  \Ruleref{set type} \dsep
  \Ruleref{seq type} \dsep
  \Ruleref{map type} \dsep
  \Ruleref{partial function type} \dsep
  \Ruleref{type name} \dsep
  \Ruleref{type variable}
  }

\Ruledef{bracketed type}{
  \Lit{(}, \Ruleref{type}, \Lit{)}
  }

\Ruledef{basic type}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token}
  }

\Ruledef{quote type}{
  \Ruleref{quote literal}
  }

\Ruledef{composite type}{
  \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \Lop{end}
  }

\Ruledef{field list}{
  \SeqPt{\Ruleref{field}}
  }

\Ruledef{field}{
  \OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type} \dsep
  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

\Ruledef{union type}{
  \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
  }

\Ruledef{product type}{
  \Ruleref{type}, \Lit{*}, \Ruleref{type}, \SeqPt{\Lit{*}, \Ruleref{type}}
  }

\Ruledef{optional type}{
  \Lit{[}, \Ruleref{type}, \Lit{]}
  }

\Ruledef{set type}{
  \Ruleref{set0 type} \dsep
  \Ruleref{set1 type}
}

\Ruledef{set0 type}{
  \Lop{set of}, \Ruleref{type}
  }

\Ruledef{set1 type}{
  \Lop{set1 of}, \Ruleref{type}
  }

\Ruledef{seq type}{
  \Ruleref{seq0 type} \dsep
  \Ruleref{seq1 type}
  }

\Ruledef{seq0 type}{
  \Lop{seq of}, \Ruleref{type}
  }

\Ruledef{seq1 type}{
  \Lop{seq1 of}, \Ruleref{type}
  }

\Ruledef{map type}{
  \Ruleref{general map type} \dsep
  \Ruleref{injective map type}
  }

\Ruledef{general map type}{
  \Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{injective map type}{
  \Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Ruledef{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Ruledef{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Ruledef{discretionary type}{
  \Ruleref{type} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{type name}{
  \Ruleref{name}
  }

\Ruledef{type variable}{
  \Ruleref{type variable identifier}
  }

%#ifdef VDMPP
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }

\Ruledef{eq clause}{
  \Lop{eq}, \Ruleref{pattern}, \Lop{=}, \Ruleref{pattern}, \Lop{==}, \Ruleref{expression}
  }

\Ruledef{ord clause}{
  \Lop{ord}, \Ruleref{pattern}, \Lop{<}, \Ruleref{pattern}, \Lop{==}, \Ruleref{expression}
  }

\subsection{The VDM-SL State Definition}

\Ruledef{state definition}{
  \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
  \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}

\Ruledef{initialisation}{
  \Lop{init}, \Ruleref{invariant initial function}
  }

\subsection{Value Definitions}

\Ruledef{value definitions}{
  \Lop{values},
  \OptPt{\Ruleref{access value definition}, \lfeed
         \SeqPt{\Lit{;},
               \Ruleref{access value definition}
               },
         \OptPt{\Lit{;}}}
        }
%  }
  \nonstandard{1}

%  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       \OptPt{\Ruleref{access}},
         \Ruleref{value definition}
    }
%}{}

\Ruledef{value definition}{
  \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
  }
  \nonstandard{1}

\subsection{Function Definitions}\label{functiondef2}

\Ruledef{function definitions}{
  \Lop{functions},
    \OptPt{\Ruleref{access function definition}, \lfeed
         \SeqPt{\Lit{;},
                \Ruleref{access function definition}},
         \OptPt{\Lit{;}}
    }
  }
%  \nonstandard{1}

%\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    \OptPt{\Ruleref{access}},
      \Ruleref{function definition}
  }
%}{}

\Ruledef{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }
  \nonstandard{1}

\Ruledef{explicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \lfeed
  \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{measure body}}
  }
  \nonstandard{1}

\Ruledef{implicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
  }

%In VDM-SL extended explicit function definition looks like:

%This should be removed and exchanged with a more general solution.
%#ifdef VDMSL
%\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

%\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{measure body}}
}
%#endif VDMSL
%In VDM++ and VDM-RT extended explicit function definition looks like:
%#ifdef VDMPP
%\Ruledef{extended explicit function definition}{
%  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
%  \Ruleref{parameter types}, \lfeed
%  \Ruleref{identifier type pair list}, \lfeed
%  \Lit{==}, \Ruleref{function body}, \lfeed
%  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
%  \OptPt{\Lop{post}, \Ruleref{expression}}
%}
%#endif VDMPP

\Ruledef{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Ruledef{identifier type pair}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Ruledef{identifier type pair list}{
  \Ruleref{identifier type pair}, \SeqPt{\Lit{,}, \Ruleref{identifier type pair}}
}

\Ruledef{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Ruledef{parameters list}{
  \Ruleref{parameters}, \SeqPt{\Ruleref{parameters}}
  }

\Ruledef{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Ruledef{function body}{
  \Ruleref{expression} \dsep
  \Lop{is subclass responsibility} \dsep
  \Lop{is not yet specified}
  }

\Ruledef{measure body}{
  \Ruleref{expression} \dsep
  \Lop{is not yet specified}
  } \nonstandard{1}

\subsection{Operation Definitions}\label{op-def2}

\Ruledef{operation definitions}{
  \Lop{operations},
  \OptPt{\Ruleref{access operation definition}, \lfeed
         \SeqPt{\Lit{;},
                \Ruleref{access operation definition}
               },
         \OptPt{\Lit{;}}}
  }\nonstandard{1}

%  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{access operation definition}{
    \SeqPt{
%#ifdef VICEMAN
      \Lop{pure} \dsep
      \Lop{async} \dsep
%#endif VICEMAN
      \Ruleref{access} \dsep
      \Lop{static}}, \lfeed
      \Ruleref{operation definition}
    }
%}{}

\Ruledef{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }\nonstandard{1}

\Ruledef{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
%#ifdef VDMPP
%  , \lfeed
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}
%#endif VDMPP
  }\nobreak\nonstandard{1}

\Ruledef{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Ruledef{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Ruledef{extended explicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}\nonstandard{7}

\Ruledef{operation type}{
  \Ruleref{discretionary type}, \Lit{==>}, \Ruleref{discretionary type}
  }

\Ruledef{operation body}{
  \Ruleref{statement} \dsep
  \Lop{is subclass responsibility} \dsep
  \Lop{is not yet specified}
  } \nonstandard{1}

\Ruledef{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Ruledef{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Ruledef{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Ruledef{error list}{
  \Ruleref{error}, \SeqPt{error}
  }

\Ruledef{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\subsection{Instance Variable Definitions (VDM++ and VDM-RT)}

\Ruledef{instance variable definitions}{
  \Lop{instance}, \Lop{variables}, \lfeed
  \OptPt{\Ruleref{instance variable definition}, \lfeed
         \SeqPt{\Lit{;},
               \Ruleref{instance variable definition}
               }
        }
  }

\Ruledef{instance variable definition}{
  \Ruleref{access assignment definition} \dsep
  \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}}  \dsepl
    \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Ruledef{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Ruledef{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

%\subsection{Time Variable Definitions}
%
%\Ruledef{time variable definitions}{
%      \Lop{time}, \Lop{variables},
%      \Ruleref{time spec}, \SeqPt{\Lit{;}, \Ruleref{time spec}}, \OptPt{\Lop{;}}}
%\Ruledef{time spec}{
%      \Ruleref{time var decl} \dsep \Ruleref{assumption} \dsep \Ruleref{effect}}
%\Ruledef{time var decl}{
%      \OptPt{\Lop{input}}, \Ruleref{name list}, \Lit{:}, \Ruleref{type}}
%\Ruledef{assumption}{
%      \Lop{assumption}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
%\Ruledef{effect}{
%      \Lop{effect}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}

\subsection{Synchronization Definitions (VDM++ and VDM-RT)}

\Ruledef{synchronization definitions}{
      \Lop{sync}, \OptPt{\Ruleref{synchronization}}}

\Ruledef{synchronization}{
      \Ruleref{permission predicates} %\dsep
%      \Ruleref{trace structures}
}

\Ruledef{permission predicates}{
      \Ruleref{permission predicate},\lfeed
      \SeqPt{\Lit{;}, \Ruleref{permission predicate}}}
\Ruledef{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Ruledef{mutex predicate}{
       \Lop{mutex}, \Lit{(}, (\Lop{all} \dsepl \Ruleref{name list}), \Lit{)}}

% \Ruledef{trace structures}{
%       \SeqPt{\Ruleref{subtrace structure}, \Lit{;}},
%       \Ruleref{general trace structure}}
% \Ruledef{subtrace structure}{
%       \Lop{subtrace}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}
% \Ruledef{general trace structure}{
%       \Lop{general}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}

% \Ruledef{trace structure}{
%      \Ruleref{identifier} \dsep
%      \Lit{$<$}, \Ruleref{trace set}, \Lit{,}, \Ruleref{alphabet}, \Lit{$>$} \dsep
%      \Lop{pref}, \Lit{(}, \Ruleref{trace structure}, \Lit{)} \dsep
%      \Lop{del}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{w\_}, \Ruleref{trace structure} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{sync}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{{qsync}}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \lfeed
%      \Lit{,}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{**}, \Ruleref{alphabet}}
% \Ruledef{alphabet}{
%       \Lit{\{}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}, \Lit{\}} \dsep
%       \Lop{a\_}, \Ruleref{trace structure}}

% \Ruledef{trace set}{
%      \Ruleref{trace expression} \dsepl
%      \Ruleref{alphabet}, \Lit{$\ast$} \dsepl
%      \Lop{t\_}, \Ruleref{trace structure}}
% \Ruledef{trace expression}{
%       \Ruleref{term}, \SeqPt{\Lit{;}, \Ruleref{term}}}
% \Ruledef{term}{
%       \Ruleref{cterm} \dsepl \Ruleref{cterm}, \Lit{+} \dsepl \Ruleref{cterm}, \Lit{*}}
% \Ruledef{cterm}{
%       \Lit{(}, \Ruleref{trace expression}, \Lit{)} \dsepl \Ruleref{name}}

\subsection{Thread Definitions (VDM++ and VDM-RT)}

\Ruledef{thread definitions}{ \Lop{thread},
    \OptPt{\Ruleref{thread definition}} }

\Rule{thread definition}{
    \Ruleref{periodic thread definition} \dsep
    \Ruleref{procedural thread definition} }

\Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation}  \dsep
    \Ruleref{sporadic obligation} }

%For VDM++ where time is not explicit, it looks like:
%
%\Ruledef{periodic obligation}{
%  \Lop{periodic},\Lit{(}, \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
%}

For VDM-RT where time is explicit, it looks like:

\Ruledef{periodic obligation}{
  \Lop{periodic}, \Lit{(}, 4 * \Ruleref{expression},
  \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
}

\Ruledef{sporadic obligation}{
  \Lop{sporadic}, \Lit{(}, 3 * \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
}

For both VDM++ and VDM-RT, we can define:

\Ruledef{procedural thread definition}{
      \Ruleref{statement}}

\subsection{Trace Definitions}

\Ruledef{traces definitions}{\Lop{traces},
   \OptPt{\Ruleref{named trace}, \SeqPt{\Lit{;}, \Ruleref{named trace}}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term},
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition}, \SeqPt{\Lit{|}, \Ruleref{trace definition}}
}

\Rule{trace definition}{
  \Ruleref{trace binding definition} \dsep
  \Ruleref{trace repeat definition}
}

\Ruledef{trace binding definition}{
  \Ruleref{trace let def binding} \dsep
  \Ruleref{trace let best binding}
}

\Ruledef{trace let def binding}{
  \Lop{let}, \Ruleref{local definition},
  \SeqPt{ \Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace let best binding}{
  \Lop{let}, \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace repeat definition}{
  \Ruleref{trace core definition},
  \OptPt{\Ruleref{trace repeat pattern}}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \OptPt{\Lit{,}, \Ruleref{numeric literal}}, \Lit{\}}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace concurrent expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{call statement}
}

\Rule{trace concurrent expression}{
  \Lit{||}, \Lit{(}, \Ruleref{trace definition}, \lfeed
  \Lit{,}, \Ruleref{trace definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{trace definition}}, \Lit{)}
}

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\section{Expressions}

\Ruledef{expression list}{
  \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
  }

\Ruledef{expression}{
  \Ruleref{bracketed expression} \dsep
  \Ruleref{let expression} \dsep
  \Ruleref{let be expression} \dsep
  \Ruleref{def expression} \dsep
  \Ruleref{if expression} \dsep
  \Ruleref{cases expression} \dsep
  \Ruleref{unary expression} \dsep
  \Ruleref{binary expression} \dsep
  \Ruleref{quantified expression} \dsep
  \Ruleref{iota expression} \dsep
  \Ruleref{set enumeration} \dsep
  \Ruleref{set comprehension} \dsep
  \Ruleref{set range expression} \dsep
  \Ruleref{sequence enumeration} \dsep
  \Ruleref{sequence comprehension} \dsep
  \Ruleref{subsequence} \dsep
  \Ruleref{map enumeration} \dsep
  \Ruleref{map comprehension} \dsep
  \Ruleref{tuple constructor} \dsep
  \Ruleref{record constructor} \dsep
  \Ruleref{record modifier}  \dsep
  \Ruleref{apply} \dsep
  \Ruleref{field select} \dsep
  \Ruleref{tuple select} \dsep
  \Ruleref{function type instantiation} \dsep
  \Ruleref{lambda expression} \dsep
  \Ruleref{narrow expression} \dsep
  \Ruleref{new expression} \dsep
  \Ruleref{self expression} \dsep
  \Ruleref{threadid expression} \dsep
  \Ruleref{general is expression} \dsep
  \Ruleref{undefined expression} \dsep
  \Ruleref{precondition expression} \dsep
  \Ruleref{isofbaseclass expression} \dsep
  \Ruleref{isofclass expression} \dsep
  \Ruleref{samebaseclass expression}  \dsep
  \Ruleref{sameclass expression} \dsep
  \Ruleref{act expression} \dsep
  \Ruleref{fin expression} \dsep
  \Ruleref{active expression} \dsep
  \Ruleref{req expression} \dsep
  \Ruleref{waiting expression} \dsep
  \Ruleref{time expression} \dsep
  \Ruleref{name} \dsep
  \Ruleref{old name}  \dsep
  \Ruleref{symbolic literal}
}
\nonstandard{4}

\subsection{Bracketed Expressions}

\Ruledef{bracketed expression}{
  \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsection{Local Binding Expressions}

\Ruledef{let expression}{
  \Lop{let}, \Ruleref{local definition},
   \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\Ruledef{let be expression}{
  \Lop{let}, \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{expression}
  }

\Ruledef{def expression}{
  \Lop{def},
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }
  \nonstandard{2}

\subsection{Conditional Expressions}

\Ruledef{if expression}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
  \SeqPt{\Ruleref{elseif expression}}, \lfeed
  \Lop{else}, \Ruleref{expression}
  }

\Ruledef{elseif expression}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
  }

\Ruledef{cases expression}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:},\lfeed
  \Ruleref{cases expression alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
  }

\Ruledef{cases expression alternatives}{
  \Ruleref{cases expression alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
  }

\Ruledef{cases expression alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
  }

\Ruledef{others expression}{
  \Lop{others}, \Lit{->}, \Ruleref{expression}
  }

\subsection{Unary Expressions}

\Ruledef{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Ruledef{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

\Ruledef{unary operator}{
  \Ruleref{unary plus} \dsep
  \Ruleref{unary minus} \dsep
  \Ruleref{arithmetic abs} \dsep
  \Ruleref{floor} \dsep
  \Ruleref{not} \dsep
  \Ruleref{set cardinality} \dsep
  \Ruleref{finite power set} \dsep
  \Ruleref{distributed set union} \dsep
  \Ruleref{distributed set intersection} \dsep
  \Ruleref{sequence head} \dsep
  \Ruleref{sequence tail} \dsep
  \Ruleref{sequence length} \dsep
  \Ruleref{sequence elements} \dsep
  \Ruleref{sequence indices} \dsep
  \Ruleref{sequence reverse} \dsep
  \Ruleref{distributed sequence concatenation} \dsep
  \Ruleref{map domain} \dsep
  \Ruleref{map range} \dsep
  \Ruleref{distributed map merge}
  }

\Ruledef{unary plus}{
  \Lit{+}
  }

\Ruledef{unary minus}{
  \Lit{-}
  }

\Ruledef{arithmetic abs}{
  \Lop{abs}
  }

\Ruledef{floor}{
  \Lop{floor}
  }

\Ruledef{not}{
  \Lop{not}
  }

\Ruledef{set cardinality}{
  \Lop{card}
  }

\Ruledef{finite power set}{
  \Lop{power}
  }

\Ruledef{distributed set union}{
  \Lop{dunion}
  }

\Ruledef{distributed set intersection}{
  \Lop{dinter}
  }

\Ruledef{sequence head}{
  \Lop{hd}
  }

\Ruledef{sequence tail}{
  \Lop{tl}
  }

\Ruledef{sequence length}{
  \Lop{len}
  }

\Ruledef{sequence elements}{
  \Lop{elems}
  }

\Ruledef{sequence indices}{
  \Lop{inds}
  }

\Ruledef{sequence reverse}{
  \Lop{reverse}
  }

\Ruledef{distributed sequence concatenation}{
  \Lop{conc}
  }

\Ruledef{map domain}{
  \Lop{dom}
  }

\Ruledef{map range}{
  \Lop{rng}
  }

\Ruledef{distributed map merge}{
  \Lop{merge}
  }

\Ruledef{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

\subsection{Binary Expressions}

\Ruledef{binary expression}{
  \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}
  }

\Ruledef{binary operator}{
  \Ruleref{arithmetic plus} \dsep
  \Ruleref{arithmetic minus} \dsep
  \Ruleref{arithmetic multiplication} \dsep
  \Ruleref{arithmetic divide} \dsep
  \Ruleref{arithmetic integer division} \dsep
  \Ruleref{arithmetic rem} \dsep
  \Ruleref{arithmetic mod} \dsep
  \Ruleref{less than} \dsep
  \Ruleref{less than or equal} \dsep
  \Ruleref{greater than} \dsep
  \Ruleref{greater than or equal} \dsep
  \Ruleref{equal} \dsep
  \Ruleref{not equal} \dsep
  \Ruleref{or} \dsep
  \Ruleref{and} \dsep
  \Ruleref{imply} \dsep
  \Ruleref{logical equivalence} \dsep
  \Ruleref{in set} \dsep
  \Ruleref{not in set} \dsep
  \Ruleref{subset} \dsep
  \Ruleref{proper subset} \dsep
  \Ruleref{set union} \dsep
  \Ruleref{set difference} \dsep
  \Ruleref{set intersection} \dsep
  \Ruleref{sequence concatenate} \dsep
  \Ruleref{map or sequence modify} \dsep
  \Ruleref{map merge} \dsep
  \Ruleref{map domain restrict to} \dsep
  \Ruleref{map domain restrict by} \dsep
  \Ruleref{map range restrict to} \dsep
  \Ruleref{map range restrict by} \dsep
  \Ruleref{composition} \dsep
  \Ruleref{iterate}
}

\Ruledef{arithmetic plus}{
  \Lit{+}
  }

\Ruledef{arithmetic minus}{
  \Lit{-}
  }

\Ruledef{arithmetic multiplication}{
  \Lit{*}
  }

\Ruledef{arithmetic divide}{
  \Lit{/}
  }

\Ruledef{arithmetic integer division}{
  \Lop{div}
  }

\Ruledef{arithmetic rem}{
  \Lop{rem}
  }

\Ruledef{arithmetic mod}{
  \Lop{mod}
  }

\Ruledef{less than}{
  \Lit{<}
  }

\Ruledef{less than or equal}{
  \Lit{<=}
  }

\Ruledef{greater than}{
  \Lit{>}
  }

\Ruledef{greater than or equal}{
  \Lit{>=}
  }

\Ruledef{equal}{
  \Lit{=}
  }

\Ruledef{not equal}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{approx}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{or}{
  \Lop{or}
  }

\Ruledef{and}{
  \Lop{and}
  }

\Ruledef{imply}{
  \Lit{=>}
  }

\Ruledef{logical equivalence}{
  \Lit{<=>}
  }

\Ruledef{in set}{
  \Lop{in set}
  }

\Ruledef{not in set}{
  \Lop{not in set}
  }

\Ruledef{subset}{
  \Lop{subset}
  }

\Ruledef{proper subset}{
  \Lop{psubset}
  }

\Ruledef{set union}{
  \Lop{union}
  }

\Ruledef{set difference}{
  \Lit{\char'134}
  }

\Ruledef{set intersection}{
  \Lop{inter}
  }

\Ruledef{sequence concatenate}{
  \Lit{\char'136}
  }

\Ruledef{map or sequence modify}{
  \Lit{++}
  }

\Ruledef{map merge}{
  \Lop{munion}
  }

\Ruledef{map domain restrict to}{
  \Lit{<:}
  }

\Ruledef{map domain restrict by}{
  \Lit{<-:}
  }

\Ruledef{map range restrict to}{
  \Lit{:>}
  }

\Ruledef{map range restrict by}{
  \Lit{:->}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\subsection{Quantified Expressions}

\Ruledef{quantified expression}{
  \Ruleref{all expression} \dsep
  \Ruleref{exists expression} \dsep
  \Ruleref{exists unique expression}
  }

\Ruledef{all expression}{
  \Lop{forall}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists expression}{
  \Lop{exists}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists unique expression}{
  \Lop{exists1}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The Iota Expression}

\Ruledef{iota expression}{
  \Lop{iota}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{Set Expressions}

\Ruledef{set enumeration}{
  \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
  }

\Ruledef{set comprehension}{
  \Lit{\{}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\Ruledef{set range expression}{
  \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{expression},
  \Lit{\}}
  }

\subsection{Sequence Expressions}

\Ruledef{sequence enumeration}{
  \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
  }

\Ruledef{sequence comprehension}{
  \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{]}
  }

\Ruledef{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\subsection{Map Expressions}

\Ruledef{map enumeration}{
  \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{maplet}{
  \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
  }

\Ruledef{map comprehension}{
  \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\subsection{The Tuple Constructor Expression}

\Ruledef{tuple constructor}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
  }

\subsection{Record Expressions}

\Ruledef{record constructor}{
  \Lop{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{record modifier}{
  \Lit{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
  \Ruleref{record modification}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{record modification}}, \Lit{)}
  }

\Ruledef{record modification}{
  \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
  }

\subsection{Apply Expressions}

\Ruledef{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Ruledef{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{tuple select}{
  \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
  }

\Ruledef{function type instantiation}{
  \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\subsection{The Lambda Expression}

\Ruledef{lambda expression}{
  \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The narrow Expression}

\Ruledef{narrow expression}{
  \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)}
  }


\subsection{The New Expression (VDM++ and VDM-RT)}

  \Ruledef{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\subsection{The Self Expression (VDM++ and VDM-RT)}
  \Ruledef{self expression}{
    \Lop{self}
  }

\subsection{The Threadid Expression (VDM++ and VDM-RT)}
  \Ruledef{threadid expression}{
    \Lop{threadid}
  }

\subsection{The Is Expression}

\Ruledef{general is expression}{
  \Ruleref{is expression} \dsep
  \Ruleref{type judgement}
  }

\Ruledef{is expression}{
  \Lit{\keyw{is}\_},\nmk (\Ruleref{name} \dsepl \Ruleref{basic type}), \Lit{(}, \Ruleref{expression}, \Lit{)}
}
\ntext{no delimiter is allowed}

\Ruledef{type judgement}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\subsection{The Undefined Expression}

\Ruledef{undefined expression}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsection{The Precondition Expression}

\Ruledef{precondition expression}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{expression list}, \Lit{)}
  }

\subsection{Base Class Membership (VDM++ and VDM-RT)}

\Ruledef{isofbaseclass expression}{
      \Lop{isofbaseclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\subsection{Class Membership (VDM++ and VDM-RT)}

\Ruledef{isofclass expression}{
      \Lop{isofclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\subsection{Same Base Class Membership (VDM++ and VDM-RT)}

\Ruledef{samebaseclass expression}{
      \Lop{samebaseclass}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsection{Same Class Membership (VDM++ and VDM-RT)}

\Ruledef{sameclass expression}{
      \Lop{sameclass}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsection{History Expressions (VDM++ and VDM-RT)}

  \Ruledef{act expression}{
    \Lop{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{fin expression}{
    \Lop{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{active expression}{
    \Lop{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{req expression}{
    \Lop{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{waiting expression}{
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }


\subsection{Time Expressions (VDM-RT)}

 \Ruledef{time expression}{\Lop{time}}

\subsection{Names}

\Ruledef{name}{
  \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
  }

\Ruledef{name list}{
  \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
  }

\Ruledef{old name}{
  \Ruleref{identifier}, \Lit{\char'176}
  }

\section{State Designators}

\Ruledef{state designator}{
  \Ruleref{name} \dsep
  \Ruleref{field reference} \dsep
  \Ruleref{map or sequence reference}
  }

\Ruledef{field reference}{
  \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{map or sequence reference}{
  \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\section{Statements}

\Ruledef{statement}{
  \Ruleref{let statement} \dsep
  \Ruleref{let be statement} \dsep
  \Ruleref{def statement} \dsep
  \Ruleref{block statement} \dsep
  %\ifthenelse{\boolean{VDMpp}}{
  \Ruleref{general assign statement}
%}%
%                              {\Ruleref{assign statement}}
  \dsep
  \Ruleref{if statement} \dsep
  \Ruleref{cases statement} \dsep
  \Ruleref{sequence for loop} \dsep
  \Ruleref{set for loop} \dsep
  \Ruleref{index for loop} \dsep
  \Ruleref{while loop} \dsep
  \Ruleref{nondeterministic statement} \dsep
  \Ruleref{call statement} \dsep
  \Ruleref{specification statement} \dsep
%#ifdef VDMPP
%  \Ruleref{select statement} \dsep
  \Ruleref{start statement} \dsep
  \Ruleref{start list statement} \dsep
  \Ruleref{stop statement} \dsep
  \Ruleref{stop list statement} \dsep
%  \Ruleref{delay statement} \dsep
%#endif VDMPP
%#ifdef VICEMAN
  \Ruleref{duration statement} \dsep
  \Ruleref{cycles statement} \dsep
%#endif VICEMAN
  \Ruleref{return statement} \dsep
  \Ruleref{always statement} \dsep
  \Ruleref{trap statement} \dsep
  \Ruleref{recursive trap statement} \dsep
  \Ruleref{exit statement} \dsep
  \Ruleref{error statement} \dsep
  \Ruleref{identity statement}
  }
  \nonstandard{2}

\subsection{Local Binding Statements}

\Ruledef{let statement}{
  \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{local definition}{
  \Ruleref{value definition} \dsep
  \Ruleref{function definition}
  }

\Ruledef{let be statement}{
  \Lop{let}, \Ruleref{multiple bind}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{statement}
  }

\Ruledef{def statement}{
  \Lop{def}, \Ruleref{equals definition}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{equals definition}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }
  \nonstandard{1}

\Ruledef{equals definition}{
  \Ruleref{pattern bind}, \Lit{=},
   \Ruleref{expression}}

\subsection{Block and Assignment Statements}

\Ruledef{block statement}{
  \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
  \Ruleref{statement}, \SeqPt{\Lit{;},  \Ruleref{statement}}, \OptPt{\Lit{;}},
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl statement}{
  \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
  }

\Ruledef{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression} }
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
%}%
%{}

\Ruledef{assign statement}{
  \Ruleref{state designator}, \Lit{:=},
    \Ruleref{expression}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{multiple assign statement}{
    \Lop{atomic},
    \Lit{(},
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{assign statement}},
    \Lit{)}
    }
%  }%
%{}


\subsection{Conditional Statements}\label{condstmt2}

\Ruledef{if statement}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
  \SeqPt{\Ruleref{elseif statement}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{statement}}
  }

\Ruledef{elseif statement}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
  }


\Ruledef{cases statement}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
  \Ruleref{cases statement alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
  }

\Ruledef{cases statement alternatives}{
  \Ruleref{cases statement alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
  }

\Ruledef{cases statement alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
  }

\Ruledef{others statement}{
  \Lop{others}, \Lit{->}, \Ruleref{statement}
  }

\subsection{Loop Statements}

\Ruledef{sequence for loop}{
  \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
  \lfeed
  \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }

\Ruledef{set for loop}{
  \Lop{for}, \Lop{all}, \Ruleref{pattern}, \Lop{in set},
  \Ruleref{expression},\lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{index for loop}{
  \Lop{for}, \Ruleref{identifier}, \Lit{=}, \Ruleref{expression},
  \Lop{to}, \Ruleref{expression}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{expression}}, \lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{while loop}{
  \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }
\subsection{The Nondeterministic Statement}

\Ruledef{nondeterministic statement}{
  \Lit{||}, \Lit{(}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
  }

\subsection{Call and Return Statements}

In VDM-SL a call statement looks like:
%#ifdef VDMSL
\Ruledef{call statement}{
  \Ruleref{name}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{expression list}}, \Lit{)}
}
%#endif VDMSL
In VDM++ and VDM-RT a call statement looks like:

%#ifdef VDMPP
  \Ruledef{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},\lfeed
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }
  \Ruledef{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
    \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Ruledef{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Ruledef{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
%#endif VDMPP

\Ruledef{return statement}{
  \Lop{return}, \OptPt{\Ruleref{expression}}
  }

\subsection{The Specification Statement}

\Ruledef{specification statement}{
  \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }\nonstandard{1}

%#ifdef VDMPP
%\subsection{The Select Statement}
%
%\Ruledef{select statement}{
%      \Lop{sel}, \Lit{(}, \Ruleref{guarded command},\lfeed
%      \SeqPt{\Lit{,}, \Ruleref{guarded command}}, \Lit{)}}
%\Ruledef{guarded command}{
%      \OptPt{\Ruleref{expression}}, \OptPt{\Ruleref{answer statement}},\lfeed
%      \OptPt{\Lop{$->$}, \Ruleref{statement}}}
%\Ruledef{answer statement}{
%      \Lop{answer}, \Brack{\Ruleref{name} \dsepl \Lop{all}}}
%
\subsection{Start and Start List Statements (VDM++ and VDM-RT)}

\Ruledef{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\Ruledef{start list statement}{
      \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\subsection{Stop and Stop List Statements (VDM++ and VDM-RT)}

\Ruledef{stop statement}{
    \Lop{stop}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\Ruledef{stop list statement}{
      \Lop{stoplist}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

%\subsection{The Delay Statement}
%
%\Ruledef{delay statement}{
%      \Lop{delay}, \Lit{(},\Ruleref{expression}, \Lit{)}}
%#endif VDMPP

%#ifdef VICEMAN
\subsection{The Duration and Cycles Statements (VDM-RT)}

\Ruledef{duration statement}{
  \Lop{duration}, \Lit{(}, \Ruleref{expression}, \Lit{)},\lfeed
  \Ruleref{statement}
}

\Ruledef{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{expression}, \Lit{)},\lfeed
    \Ruleref{statement}
  }

%#endif VICEMAN

\subsection{Exception Handling Statements}

\Ruledef{always statement}{
  \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{trap statement}{
  \Lop{trap}, \Ruleref{pattern bind}, \Lop{with}, \Ruleref{statement},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{recursive trap statement}{
  \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{traps}{
  \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}},
  \Lit{\}}
  }

\Ruledef{exit statement}{
  \Lop{exit}, \OptPt{\Ruleref{expression}}
  }

\subsection{The Error Statement}

  \Ruledef{error statement}{
    \Lop{error}
    }\nonstandard{1}

\subsection{The Identity Statement}

\Ruledef{identity statement}{
  \Lop{skip}
  }

\section{Patterns and Bindings}

\subsection{Patterns}\label{patterns2}

\Ruledef{pattern}{
  \Ruleref{pattern identifier} \dsep
  \Ruleref{match value} \dsep
  \Ruleref{set enum pattern} \dsep
  \Ruleref{set union pattern} \dsep
  \Ruleref{seq enum pattern} \dsep
  \Ruleref{seq conc pattern} \dsep
  \Ruleref{map enumeration pattern} \dsep
  \Ruleref{map munion pattern} \dsep
  \Ruleref{tuple pattern} \dsep
  \Ruleref{object pattern} \dsep
  \Ruleref{record pattern}
  }

\Ruledef{pattern identifier}{
  \Ruleref{identifier} \dsepl \Lit{-}
  }

\Ruledef{match value}{
  \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{symbolic literal}
  }

\Ruledef{set enum pattern}{
  \Lit{\{}, \OptPt{\Ruleref{pattern list}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{set union pattern}{
  \Ruleref{pattern}, \Lit{union}, \Ruleref{pattern}
  }

\Ruledef{seq enum pattern}{
  \Lit{[}, \OptPt{\Ruleref{pattern list}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{seq conc pattern}{
  \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
  }

\Ruledef{map enumeration pattern}{
\Lit{\{}, \Ruleref{maplet pattern list}, \Lit{\}} \dsep \Lit{\{}, \Lit{|->}, \Lit{\}}
}

\Ruledef{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

\Ruledef{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

\Ruledef{map munion pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  }

\Ruledef{record pattern}{
  \Lit{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}


  \Ruledef{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}\nmk
    }
 \ntext{\Ruleref{object pattern} is only be used in VDM++ and VDM-RT}

  \Ruledef{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Ruledef{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

\Ruledef{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\subsection{Bindings}

\Ruledef{pattern bind}{
  \Ruleref{pattern} \dsepl \Ruleref{bind}
  }

\Ruledef{bind}{
  \Ruleref{set bind} \dsepl \Ruleref{seq bind} \dsepl \Ruleref{type bind}
  }

\Ruledef{set bind}{
  \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{seq bind}{
  \Ruleref{pattern}, \Lop{in seq}, \Ruleref{expression}
  }

\Ruledef{type bind}{
  \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{bind list}{
  \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
  }

\Ruledef{multiple bind}{
  \Ruleref{multiple set bind} \dsep
  \Ruleref{multiple seq bind} \dsep
  \Ruleref{multiple type bind}
  }

\Ruledef{multiple set bind}{
  \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{multiple seq bind}{
  \Ruleref{pattern list}, \Lop{in seq}, \Ruleref{expression}
  }

\Ruledef{multiple type bind}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

\chapter{Lexical Specification}\label{app-b}\label{ap:lexis}

\section{Characters}

The characters that comprise a valid VDM specification are defined in
terms of Unicode codepoints. The actual character encoding of a VDM
source file (for example UTF-8, ISO-Latin-1 or Shift-JIS) is not
defined, and the tool support is responsible for converting whatever
encoding is used into Unicode during the parse of the file.

All VDM keywords and delimiter tokens are composed of characters from
the Basic Latin block (``ASCII'' codepoints less than U+0080). On the
other hand, user identifiers (variable names, function names and so
on) can be composed of a rich variety of Unicode codepoints,
reflecting the need for fully internationalized specifications.

All Unicode codepoints have a ``category''. Certain categories are
entirely excluded from the set of codepoints that are permitted in
identifiers. This prevents, say, punctuation characters from being
used. On the other hand, to provide a degree of compatibility with the
original VDM ISO standard, and for backward compatibility, there are
different rules for the formation of user identifiers that only use
ASCII characters. For example, the underscore is permitted in
identifiers (U+005F), even though this is in the connecting
punctuation category, which would not normally be allowed.

See \url{http://www.fileformat.info/info/unicode/category/index.htm} for
more information about categories.

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
        \begin{tabular}{lp{13cm}}
        \multicolumn{2}{l}{\rm initial letter:} \\
        if   & codepoint $<$ U+0100 \\
        then &  Any character in categories Ll, Lm, Lo, Lt, Lu or U+0024 (a dollar sign) \\
        else & Any character except categories Cc, Zl, Zp, Zs, Cs,
                Cn, Nd, Pc \\
    \end{tabular}

\blankline
\begin{tabular}{lp{13cm}}
        \multicolumn{2}{l}{following letter: }\\
        if   & codepoint $<$ U+0100 \\
        then & Any character in categories Ll, Lm, Lo, Lt, Lu, Nd or
               U+0024 (a dollar sign) or U+005F (underscore) or U+0027 (apostrophe) \\
        else & Any character except categories Cc, Zl, Zp, Zs, Cs, Cn
    \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{digit:} \\
        {\tt 0}
        & {\tt 1}
        & {\tt 2}
        & {\tt 3}
        & {\tt 4}
        & {\tt 5}
        & {\tt 6}
        & {\tt 7}
        & {\tt 8}
        & {\tt 9}
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{hexadecimal digit:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f}
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{octal digit:} \\
        {\tt 0}
        & {\tt 1}
        & {\tt 2}
        & {\tt 3}
        & {\tt 4}
        & {\tt 5}
        & {\tt 6}
        & {\tt 7}
     \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{Character set}}
\label{charSetTable}

\end{table}



\clearpage % to force table to appear *here*


\section{Symbols}\label{Symbols}

The following kinds of symbols exist: keywords, delimiters,
% simple names -- these do not seem to exist anymore DJA
symbolic literals, and comments.  The transformation from characters to
symbols is given by the following rules; these use the same notation as the
syntax definition but differ in meaning in that no separators may appear
between adjacent terminals.  Where ambiguity is possible otherwise, two
consecutive symbols must be separated by a separator.

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{keyword}{
%#ifdef VDMPP
  \Lks{\#act}
  \Lks{\#active}
  \Lks{\#fin}
  \Lks{\#req}
  \Lks{\#waiting}
%  \Lksb{a\_}
  \Lksb{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
\Lks{as}
  \Lks{async}
  \Lks{atomic}
  \Lksb{be}
  \Lks{bool}
  \Lks{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lksb{class}
  \Lks{comp}
  \Lks{compose}
  \Lks{conc}
%#ifdef VICEMAN
  \Lks{cycles}
%#endif VICEMAN
  \Lks{dcl}
  \Lksb{def}
  \Lks{definitions}
%  \Lks{delay}
  \Lks{dinter}
  \Lks{div}
  \Lks{dlmodule}
  \Lksb{do}
  \Lks{dom}
  \Lks{dunion}
%#ifdef VICEMAN
  \Lks{duration}
%#endif VICEMAN
  \Lks{elems}
  \Lks{else}
  \Lksb{elseif}
  \Lks{end}
  \Lks{eq}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lksb{exit}
  \Lks{exports}
  \Lks{ext}
  \Lks{false}
  \Lksb{floor}
  \Lks{for}
  \Lks{forall}
  \Lks{from}
  \Lks{functions}
%  \Lks{general}
  \Lks{hd}
  \Lks{if}
  \Lksb{in}
  \Lks{inds}
 % \Lks{init}
  \Lks{inmap}
%  \Lks{input}
  \Lks{instance}
  \Lks{int}
  \Lksb{inter}
  \Lks{imports}
  \Lks{init}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lksb{is}
  \Lks{isofbaseclass}
  \Lks{isofclass}
  \Lks{lambda}
  \Lks{len}
  \Lksb{let}
  \Lks{map}
  \Lks{measure}
  \Lks{merge}
  \Lks{mod}
  \Lks{module}
  \Lksb{mu}
  \Lks{munion}
  \Lks{mutex}
  \Lks{nat}
  \Lks{nat1}
  \Lks{new}
  \Lks{nil}
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{ord}
  \Lks{others}
  \Lks{per}
  \Lks{periodic}
  \Lksb{post}
  \Lks{power}
  \Lks{pre}
  \Lks{private}
  \Lks{protected}
  \Lksb{psubset}
  \Lks{public}
  \Lks{pure}
 % \Lksb{qsync}
  \Lks{rat}
  \Lks{rd}
  \Lks{real}
  \Lks{rem}
  \Lksb{renamed}
  \Lks{responsibility}
  \Lks{return}
  \Lks{reverse}
  \Lksb{rng}
  \Lks{samebaseclass}
  \Lks{sameclass}
 % \Lksb{sel}
  \Lks{self}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{set1}
  \Lks{skip}
  \Lks{specified}
  \Lks{sporadic}
  \Lks{st}
  \Lksb{start}
  \Lks{startlist}
  \Lks{state}
  \Lks{stop}
  \Lksb{stoplist}
  \Lks{struct}
  \Lks{subclass}
  \Lks{subset}
  \Lksb{sync}
%#ifdef VICEMAN
  \Lks{system}
%#endif VICEMAN
%  \Lks{synonym}
%  \Lks{t\_}
  \Lks{then}
  \Lks{thread}
  \Lks{threadid}
%#ifdef VICEMAN
  \Lks{time}
%#endif VICEMAN
  \Lksb{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lks{traces}
  \Lks{trap}
  \Lks{true}
  \Lksb{types}
  \Lks{undefined}
  \Lks{union}
  \Lks{uselib}
  \Lksb{values}
  \Lks{variables}
%  \Lks{w\_}
  \Lks{while}
  \Lks{with}
  \Lks{wr}
  \Lks{yet}
  \Lop{RESULT}
%#endif VDMPP
  }

%\Ruledef{separator}{
%  \hyperlink{charSetTable}{newline} \dsepl
%  \hyperlink{charSetTable}{white space}
%  }

\Ruledef{identifier}{
  \Ruleref{initial letter},
  \SeqPt{following letter}
  }

\medskip


\noindent Note that in VDM-RT the \texttt{CPU} and \texttt{BUS} classes are
reserved and cannot be redefined by the user. These two predefined
classes contain the functionality described in
Section~\ref{sec:system} above.

All identifiers beginning with one of the reserved prefixes are
reserved: \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} and \keyw{pre\_}.

\Ruledef{type variable identifier}{
  \Lit{@}, \Ruleref{identifier}
  }

\Ruledef{symbolic literal}{
  \Ruleref{numeric literal} \dsepl
  \Ruleref{boolean literal} \dsep
  \Ruleref{nil literal} \dsepl
  \Ruleref{character literal} \dsepl
  \Ruleref{text literal} \dsep
  \Ruleref{quote literal}
  }

\Ruledef{numeral}{
  \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}
  }

\Ruledef{numeric literal}{
  \hyperlink{charSetTable}{decimal literal} \dsepl \hyperlink{charSetTable}{hexadecimal literal}
  }

\Ruledef{exponent}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{numeral}
  }

\Ruledef{decimal literal}{
  \Ruleref{numeral},
  \OptPt{\Lit{.}, \Ruleref{numeral}},
  \OptPt{\Ruleref{exponent}}
}

\Ruledef{hexadecimal literal}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{hexadecimal digit}, \SeqPt{\hyperlink{charSetTable}{hexadecimal digit}}
}

\Ruledef{boolean literal}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nil literal}{
  \Lop{nil}
  }

\Ruledef{character literal}{
  \Lit{\mbox{\,}'\mbox{\,}}, (\Ruleref{character} \dsepl
  \Ruleref{escape sequence}),
  \Lit{\mbox{\,}'\mbox{\,}}
  }\nonstandard{1}

\Ruledef{escape sequence}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x}, 2 * \hyperlink{charSetTable}{hexadecimal
    digit} \dsep
  \Lit{{\char'134}u}, 4 * \hyperlink{charSetTable}{hexadecimal
    digit} \dsep
  \Lit{{\char'134}c}, \Ruleref{character} \dsep
  \Lit{{\char'134}}, 3 * \hyperlink{charSetTable}{octal digit} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'}
  }

\Ruledef{text literal}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}\char'134"\mbox{\,}}\dsepl
     \Ruleref{character} \dsepl \Ruleref{escape sequence}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{quote literal}{
  \Lit{$<$}, \Ruleref{identifier}, \Lit{$>$}

  }

\Ruledef{single line comment}{
  \Lit{--}, \SeqPt{\Ruleref{character} -- newline}, newline
  }

\Ruledef{multiple line comment}{
  \Lit{/*}, \SeqPt{\Ruleref{character}}, \Lit{*/}
  }

The escape sequences given above are to be interpreted as follows:

\begin{table}[htb]
\begin{center}
\begin{tabular}{ll}\hline
Sequence & Interpretation\\ \hline
  \Lit{\char'134\char'134} & U+005C (backslash character)\\
  \Lit{{\char'134}r}       & U+000D (return character)\\
  \Lit{{\char'134}n}       & U+000A (newline character)\\
  \Lit{{\char'134}t}       & U+0009 (tab character)\\
  \Lit{{\char'134}f}       & U+000C (formfeed character)\\
  \Lit{{\char'134}e}       & U+001B (escape character)\\
  \Lit{{\char'134}a}       & U+0007 (alarm (bell))\\
  \Lit{{\char'134}x} hexadecimal digit, hexadecimal digit
                           & U+00xy (hex representation of character\\
                           & (e.g.\ \texttt{{\char'134}x41} is `A'))\\
  \Lit{{\char'134}u}, 4 * hexadecimal digit
                           & U+abcd (hex representation of character\\
                           & (e.g.\ \texttt{{\char'134}u0041} is `A'))\\
  \Lit{{\char'134}c}, character
                           & U+00nn (control character)\\
                           & (e.g.\ \texttt{{\char'134}cA} $\equiv$
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}}, 3 * octal digit
                           & U+00nn (octal representation of character)\\
  \Lit{{\char'134}{\char'042}}       & U+0022 (double quote)\\
  \Lit{{\char'134}'}       & U+0027 (apostrophe) \\ \hline
\end{tabular}
\end{center}
\caption{Escape sequences}
\end{table}



\chapter{Operator Precedence}\label{app-c}

The precedence ordering for operators in the concrete syntax is defined
using a two-level approach: operators are divided into families, and an
upper-level precedence ordering, $>$, is given for the families, such that
if families $F\sb{1}$ and $F\sb{2}$ satisfy

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent then every operator in the family $F\sb{1}$ is of a higher precedence
than every operator in the family $F\sb{2}$.

The relative precedences of the operators within families is determined by
considering type information, and this is used to resolve ambiguity. The
type constructors are treated separately, and are not placed in a
precedence ordering with the other operators.

There are six families of operators, namely Combinators, Applicators,
Evaluators, Relations, Connectives and Constructors:

\begin{description}%{Connectivesxx}
\item[Combinators:] Operations that allow function and mapping values to be
  combined, and function, mapping and numeric values to be iterated.

\item[Applicators:] Function application, field selection, sequence
  indexing, etc.

\item[Evaluators:] Operators that are non-predicates.

\item[Relations:] Operators that are relations.

\item[Connectives:] The logical connectives.

\item[Constructors:] Operators that are used, implicitly or explicitly, in
  the construction of expressions; e.g.  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', etc.
\end{description}

\noindent The precedence ordering on the families is:

\begin{quote}
$\mbox{\small combinators} >
\mbox{\small applicators} >
\mbox{\small evaluators}  >
\mbox{\small relations}   >
\mbox{\small connectives} >
\mbox{\small constructors}$
\end{quote}

\section{The Family of Combinators}

These combinators have the highest family priority.

\Ruledef{combinator}{
  \Ruleref{iterate} \dsepl \Ruleref{composition}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & combinator \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\section{The Family of Applicators}

All applicators have equal precedence.

\Ruledef{applicator}{
  \Ruleref{subsequence}
% \dsep \Ruleref{tuple constructor}
  \dsep \Ruleref{apply}
  \dsep \Ruleref{function type instantiation}
  \dsep \Ruleref{field select}
  }

\Rule{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\Rule{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Rule{function type instantiation}{
  \Ruleref{expression}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\Rule{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\section{The Family of Evaluators}

The family of evaluators is divided into nine groups, according to the type
of expression they are used in.

\Ruledef{evaluator}{
  \Ruleref{arithmetic prefix operator} \dsep
  \Ruleref{set prefix operator} \dsep
  \Ruleref{sequence prefix operator} \dsep
  \Ruleref{map prefix operator} \dsep
  \Ruleref{arithmetic infix operator} \dsep
  \Ruleref{set infix operator} \dsep
  \Ruleref{sequence infix operator} \dsep
  \Ruleref{map infix operator}
  }

\Ruledef{arithmetic prefix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{set prefix operator}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{sequence prefix operator}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc} \dsepl
  \Lop{reverse}
  }

\Ruledef{map prefix operator}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{arithmetic infix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{set infix operator}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{sequence infix operator}{
  \Lit{\char'136}
  }

\Ruledef{map infix operator}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent The precedence ordering follows a pattern of analogous operators. The
family is defined in the following table.

\blankline
\begin{table}[thb]
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    precedence level & arithmetic       & set                   & map                    & sequence \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (unary) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (unary) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
                     &                  &                       &                        & \keyw{reverse}        \\
    \hline
  \end{tabular}
\end{center}
\caption{Operator precedence}
\end{table}

\section{The Family of Relations}

This family includes all the relational operators whose results are of type
\keyw{bool}.

\Ruledef{relation}{
  \Ruleref{relational infix operator} \dsepl \Ruleref{set relational operator}
  }

\Ruledef{relational infix operator}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{set relational operator}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    precedence level & relation \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent All operators in the Relations family have equal precedence.  Typing
dictates that there is no meaningful way of using them adjacently.

\section{The Family of Connectives}

This family includes all the logical operators whose result is of type
\keyw{bool}.

\Ruledef{connective}{
  \Ruleref{logical prefix operator} \dsepl \Ruleref{logical infix operator}
  }

\Ruledef{logical prefix operator}{
  \Lop{not}
  }

\Ruledef{logical infix operator}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & connective \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\section{The Family of Constructors}

This family includes all the operators used to construct a value.  Their
priority is given either by brackets, which are an implicit part of the
operator, or by the syntax.

\section{Grouping}\label{grouping}

The grouping of operands of the binary operators are as follows:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[Combinators:] Right grouping.

\item[Applicators:] Left grouping.

\item[Connectives:] The `{\tt =>}' operator has right grouping.  The other
  operators are associative and therefore right and left grouping are
  equivalent.

\item[Evaluators:] Left grouping\footnote{Except the ``map domain restrict
    to'' and the ``map domain restrict by'' operators which have a right
    grouping. This is not standard.}.

\item[Relations:] No grouping, as it has no meaning.

\item[Constructors:] No grouping, as it has no meaning.
\end{list}

\section{The Type Operators}\label{preceedence}

Type operators have their own separate precedence ordering, as follows:
\begin{enumerate}
\item Function types: {\tt ->, +>} (right grouping).

\item Union type: {\tt |} (left grouping).

\item Other binary type operators: \verb+*+ (no grouping).

\item Map types: \keyw{map} \ldots \keyw{to} \ldots and \keyw{inmap} \ldots
  \keyw{to} \ldots\ (right grouping).\nonstandard{0}

\item Unary type operators: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}, \keyw{set1 of}.
\end{enumerate}

\chapter{Differences between the Concrete Syntaxes}\label{sec:diff}

When VDM was originally developed a mathematical syntax was used and
this have also been retained in the ISO/VDM-SL standard. However, most
VDM tools today mainly use an ASCII syntax. Below is a list of the
symbols which are different in the mathematical syntax and the ASCII
syntax:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 Mathematical syntax & ASCII syntax  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\X$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\bf\ttfamily munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\bf\ttfamily psubset}                     \\
 $\Subset$       & {\bf\ttfamily subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\bf\ttfamily dinter}                      \\
 $\Dunion$          & {\bf\ttfamily dunion}                      \\
 $\Power$          & {\bf\ttfamily power}                        \\
 \ldots$\Set$            & {\bf\ttfamily set of ...}                    \\
 \ldots$\Set_1$            & {\bf\ttfamily set1 of ...}                    \\
 \ldots$\Seq*$              & {\bf\ttfamily seq of ...}                 \\
 \ldots$\Seq+$              & {\bf\ttfamily seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\bf\ttfamily map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\bf\ttfamily inmap ... to ...}                 \\
 $\Muop$           & {\bf\ttfamily mu}                           \\
 $\Bool$           & {\bf\ttfamily bool}                         \\
 $\Nat$            & {\bf\ttfamily nat}                          \\
 $\Nat_1$            & {\bf\ttfamily nat1}                          \\
 $\Int$            & {\bf\ttfamily int}                          \\
 $\Real$           & {\bf\ttfamily real}                         \\
 $\Not$            & {\bf\ttfamily not}                          \\
 $\Inter$          & {\bf\ttfamily inter}                        \\
 $\Union$          & {\bf\ttfamily union}                        \\
 $\In$             & {\bf\ttfamily in set}                       \\
 $\Notin$          & {\bf\ttfamily not in set}                   \\
 $\And$            & {\bf\ttfamily and}                          \\
 $\Or$             & {\bf\ttfamily or}                           \\
 $\All$            & {\bf\ttfamily forall}                       \\
 $\Exists$         & {\bf\ttfamily exists}                       \\
 $\Exists!$        & {\bf\ttfamily exists1}                      \\
 $\Lambdaop$       & {\bf\ttfamily lambda} \\
 $\Iotaop$         & {\bf\ttfamily iota} \\
 $\ldots\Inverse$  & {\bf\ttfamily inverse ...} \\
\hline
\end{longtable}
% \end{center}


\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


