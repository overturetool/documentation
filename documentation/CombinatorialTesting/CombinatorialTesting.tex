% Overture Combinatorial Testing Guidelines
\documentclass{overturerepchap}
\usepackage{url}
\usepackage{graphics}
\usepackage{times}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{longtable} % ,multirow
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage{fancyhdr}

\newcommand{\nonstandard}[1]{}
\newcommand{\vdmtools}{VDMTools}
\newcommand{\vdmstyle}[1]{\texttt{#1}}
\newcounter{exerciseno}
\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newcounter{exerciseno}
\newcommand{\MYEQUIV}{$\equiv$}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  Operator Name & Semantics Description \\ \hline\hline \endhead}%
  {\hline\end{longtable}}

\newcommand\thebookexercise{\thechapter.\arabic{exerciseno}}
\newenvironment{myexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise}\enskip}{$\Box$\\
}
\newenvironment{myhardexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise $\star$}\enskip}{$\Box$\\
}
\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newenvironment{mysolution}{
%} %% This will be replaced by a perl script extracting the solutions
  %% and inserting them automatically into the solutions chapter.
\newcommand{\insertfig}[4]{ % Filename, epsheight, epswidth, caption,  label
\begin{figure}[htb]
\begin{center}
\includegraphics[width=#2]{#1}
\end{center}
\caption{{\em #3}} #4
\end{figure}
}

\newcommand{\insertfignw}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\includegraphics{#1}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\newcommand{\insertfignwrot}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\scalebox{1}%
{\rotatebox{270}{%
\includegraphics{#1}}}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

%\newcommand{\insertcommentedvdm*}[2]{}
  %% This macro is identified by perl script which will move the
  %% parameter to the solutions chapter.
% definition of VDM++, JavaCC, JJTree, JTB, ANTLR and SableCC for listings
\include{customlangdef}
% define the layout for listings
\lstdefinestyle{tool}{basicstyle=\ttfamily,
                         frame=trBL,
			 showstringspaces=false,
			 frameround=ffff,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
\lstdefinestyle{mystyle}{basicstyle=\ttfamily,
                         frame=trBL,
%                         numbers=left,
%			 gobble=0,
			 showstringspaces=false,
%			 linewidth=\textwidth,
			 frameround=fttt,
			 aboveskip=5mm,
			 belowskip=5mm,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
%\lstdefinestyle{mystyle}{basicstyle=\sffamily\small,
%			 frame=tb,
%                         numbers=left,
%			 gobble=0,
%			 showstringspaces=false,
%			 linewidth=345pt,
%			 frameround=ffff,
%			 framexleftmargin=8mm,
%			 framexrightmargin=8mm,
%			 framextopmargin=1mm,
%			 framexbottommargin=1mm,
%			 aboveskip=7mm,
%			 belowskip=5mm,
%			 xleftmargin=10mm,}

\lstset{style=mystyle}
\lstset{language=VDM++}
\lstset{alsolanguage=Java}
% The command below enables you to escape into normal LaTeX mode inside your 
% VDM chunks by starting with a `!\UTF{FFFD}\UTF{FFFD}? character and ending with a `!\UTF{FFFD}\UTF{FFFD}?
\lstset{escapeinside=!!}

%\newcommand{\kw}[1]{{\tt #1}}

%%%%%%%%%%%%%%%%%% Commands for bibtex %%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************
%                                                                       *
%       Bibliography and Terminology supporting commands                *
%                                                                       *
%************************************************************************

\newcommand{\bthisbibliography}[1]{\chapter*{References}%
   \begin {list} {}%
     {\settowidth {\labelwidth} {[#1]XX}%
      \setlength {\leftmargin} {\labelwidth}%
      \addtolength{\leftmargin} {\labelsep}%
      \setlength {\parsep} {1ex}%
      \setlength {\itemsep} {2ex}%
     }
  }
\newcommand{\ethisbibliography}{\end{list}}
\newcommand{\refitem}[2]
  {\bibitem[#1]{#2}}

% Requirements environment
\newenvironment{reqs}{%
\begin{enumerate}
%\renewcommand{\labelenumi}{\textbf{R\theenumi}}
\renewcommand{\theenumi}{\textbf{R\arabic{enumi}}}
}{%
\end{enumerate}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index

  \end{tabbing}\end{quote}
  }
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\bf\ttfamily #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt
    #1}\makebox[\kwlen][l]{{\bf\ttfamnily #1}}}
\newcommand{\keyw}[1]{{\bf\ttfamily #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{lstlisting}\input{#1}\end{lstlisting}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\keyw{map }#1\keyw{ to }#2}
\newcommand{\INMAP}[2]{\keyw{inmap }#1\keyw{ to }#2}
\newcommand{\SEQ}[1]{\keyw{seq of }#1}
\newcommand{\NSEQ}[1]{\keyw{seq1 of }#1}
\newcommand{\SET}[1]{\keyw{set of }#1}
\newcommand{\SETONE}[1]{\keyw{set1 of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{#1 $\To$ #2}
\newcommand{\FUN}[2]{#1 $\To$ #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}

\newcommand{\experience}[1]{%
\begin{center}
\fbox{
\begin{minipage}[t]{.8\textwidth}
#1
\end{minipage}}
\end{center}}


\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{The VDM Combinatorial Testing Guidelines}
\fancyhead[RO,LE]{\resizebox{0.05\textwidth}{!}{\includegraphics{overture}}}
\fancyfoot[C]{\thepage}
\makeindex

\begin{document}

\title{Guidelines for using VDM Combinatorial Testing Features}
\author{Nick Battle\\
            Peter Gorm Larsen}

\date{December 2020}
\reportno{TR-005}

\pagenumbering{roman}
\maketitle


{\textbf{Document history}}

\begin{tabular}{|l|l|l|l|l|}\hline
Month   & Year & Version & Version of Overture.exe & Comment \\ \hline
December   & 2010 &    0.1     & 3.0.2   & Initial version\\ \hline
\end{tabular}

%\addtocounter{page}{2}
\tableofcontents
\newpage
\mbox{}
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Introduction}

This manual is a complete guide the combinatorial testing of VDM models. It
assumes the reader has no prior knowledge of combinatorial testing, but a
working knowledge of VDM, in particular, the VDM++ and VDM-SL dialects.

\section{What is Combinatorial Testing?}

Creating a comprehensive set of tests for VDM specifications can be a time
consuming process. To try to make the generation of test cases simpler, Overture
provides a VDM language extension (for all dialects) called Combinatorial
Testing.

In general, specifications are tested to verify that certain properties or
behaviours are met, as specified by constraints in the specification and
validation conjectures in the tests.

The simplest way to test a specification is to write ad-hoc tests, starting from
a known system state and proceeding with a sequence of operation calls that
should move to a new state or produce some particular result or error response.
The problem with this kind of testing is that it can be very laborious to produce
the number of tests needed to cover the complete system behaviour. It is also
expensive to maintain a large test suite as the specification evolves.

The most complete way to test a specification is to produce a formal
mathematical proof that it will never violate its constraints, and always meet
its validation conjectures if presented with a legal sequence of operation
calls. This provides the highest level of confidence in the correctness of a
specification, but it can be unrealistic to produce a complete formal proof for
complex specifications, even with tool support.

Model checking provides an approach to formal testing that is considerably
better than ad-hoc testing but not as complete as formal proof. This approach
uses a formal specification of the system properties desired, often written in a
temporal calculus, and the model checker symbolically executes the
specification searching for execution paths that violate the constraints. Since
the execution is symbolic, extremely large state spaces can be searched
(billions of cases is not uncommon), and failed cases can produce a ``counter
example'' that demonstrates the failure. This is a very powerful technique, but
in practice, realistic specifications often produce a state space explosion
that is too great for model checkers.

Combinatorial testing is an approach that is far more powerful than ad-hoc
testing, but not as complete as model checking. Tests are produced automatically
from ``traces'' that are relatively simple to define. The approach allows
specifications to be tested with perhaps millions of test cases, but cannot
guarantee to catch every corner case in the way that a model checker can.
Therefore the technique is useful for specifications that are too complex for
model checking or formal proof.

A combinatorial trace is a pattern that describes the construction of
argument values and the sequences of operation calls that will exercise the
specification. A specification may contain several traces, each designed to test
a particular aspect. Traces are automatically expanded into a (potentially
large) number of tests, each of which is a particular sequence of operation
calls and argument values. The execution of tests is performed
automatically, starting each in a known state; a test is considered to pass if
it does not violate the specification's constraints, or the test's validation
conjectures. Individual failed tests can be executed in isolation to find out
why they failed, which is similar to a model checker's counter example. 

\chapter{Working with Traces}
\label{chap:traces}

\section{Basic Trace Constructs}
Combinatorial tests are embedded within a VDM specification using a section
called ``traces''. Typically, one or more traces are added to a separate class
or module that is intended for testing rather than the main specification,
though you can add traces to any class you wish. In this chapter, we will use
the example classes below:

\small
\begin{lstlisting}
class Counter
instance variables
    total:int := 0;

operations
    public inc: () ==> int
    inc() == ( total := total + 1; return total; )

    public dec: () ==> int
    dec() == ( total := total - 1; return total; )

end Counter

class Tester
instance variables
    obj:Counter := new Counter();

traces
    T1: obj.inc();

end Tester
\end{lstlisting}
\normalsize

Notice that there are two classes, Counter and Tester. The Counter defines a
simple class that increments and decrements a total state value that is
initially zero. The Tester class creates an instance of Counter and defines a
single trace called T1. Trace names are simple identifiers, optionally separated
by slashes (eg. \texttt{item456/interface/all}). This example is the simplest
trace possible and indicates that the trace should expand to a single test that
just calls \texttt{obj.inc()}.

This trace can either be executed in Overture in the Combinatorial Testing
perspective (see Appendix \ref{chap:OvertureShots}), or it can be executed from
the command line using the \texttt{runtrace} command. The command line output is
illustrated here for simplicity:

\begin{verbatim}
> runtrace Tester`T1
Generated 1 tests in 0.004 secs. 
Test 1 = obj.inc()
Result = [1, PASSED]
Executed in 0.007 secs. 
All tests passed
\end{verbatim}

The first line of output indicates that one test has been generated from the
trace. With more complex examples, this generation could expand to thousands or
millions of tests, and consequently it may take a few seconds.

The next line of the output describes the test that was generated. Note that
this is called ``Test 1'', and consists of a single call to \texttt{obj.inc()}.

The line below the test gives the result of executing that test. There is a
single return value from the call to \texttt{obj.inc()}, 1, which is listed
along with the word ``PASSED'' that indicates that there were no constraint violations
in the test execution.

Lastly the time taken to execute all of the tests is given, and an indication of
whether any tests failed.

The reason that this trace only expands to a single test is that the trace, when
considered as a pattern, only matches a single operation call. But if we change
the trace to the following:

\small
\begin{lstlisting}
traces
    T1: obj.inc() | obj.dec();
\end{lstlisting}
\normalsize

The trace is now saying that it would match either a call to \texttt{obj.inc()}
or a call to \texttt{obj.dec()}. Therefore the test expansion produces the
following:

\begin{verbatim}
> runtrace Tester`T1
Generated 2 tests
Test 1 = obj.inc()
Result = [1, PASSED]
Test 2 = obj.dec()
Result = [-1, PASSED]
Executed in 0.033 secs. 
All tests passed
\end{verbatim}

This time two tests are generated. The first calls \texttt{obj.inc()}, the
second \texttt{obj.dec()}. Notice that the decrement test is completely separate
from the increment test. It produces -1 as its result, because the Counter
object is re-created for each test. It does not decrement the counter back to
zero after the first test incremented it.

If we want to test an increment followed by a decrement, that would be expressed
using a semi-colon separator:

\small
\begin{lstlisting}
traces
    T1: obj.inc(); obj.dec();
\end{lstlisting}
\normalsize

This produces the output:

\small
\begin{verbatim}
Generated 1 tests
Test 1 = obj.inc(); obj.dec()
Result = [1, 0, PASSED]
Executed in 0.027 secs. 
All tests passed
\end{verbatim}
\normalsize

This generates a single test again, but you can see that the test involves two
calls and that they return 1 and 0, respectively. So this time the second call
is operating on the same object instance as the first.

If the increment and decrement operations are independent, it makes sense to
test calls to them in either order, which would be expressed as:

\small
\begin{lstlisting}
traces
    T1: || ( obj.inc(), obj.dec() );
\end{lstlisting}
\normalsize

Notice that the separator has changed to a comma. That produces the output:

\small
\begin{verbatim}
Generated 2 tests
Test 1 = obj.inc(); obj.dec()
Result = [1, 0, PASSED]
Test 2 = obj.dec(); obj.inc()
Result = [-1, 0, PASSED]
Executed in 0.029 secs. 
All tests passed
\end{verbatim}
\normalsize

So now both orderings of the two calls are produced. This is because there are
two orderings that match the pattern \texttt{|| ( \ldots, \ldots )}. This
particular trace construct naturally expands to an arbitrary number of calls and
produces a test for every permutation of the calls in brackets.

But what if some tests are a pair of calls and some are not? If we want to make
a call optional, the \texttt{?} operator can be added to any operation call
(ie. not just within \texttt{||} operators) to indicate that this will match
tests where the call is made and where it is not. For example:

\small
\begin{lstlisting}
traces
    T1: || ( obj.inc(), obj.dec()? );
\end{lstlisting}
\normalsize

This means that the decrement call is optional and so although it is included in
the orderings of the pair, it should also be absent in some cases. This
example produces the following:

\small
\begin{verbatim}
Generated 4 tests
Test 1 = obj.inc(); skip
Result = [1, (), PASSED]
Test 2 = obj.inc(); obj.dec()
Result = [1, 0, PASSED]
Test 3 = skip; obj.inc()
Result = [(), 1, PASSED]
Test 4 = obj.dec(); obj.inc()
Result = [-1, 0, PASSED]
Executed in 0.043 secs. 
All tests passed
\end{verbatim}
\normalsize

You see that the decrement call is sometimes present and sometimes replaced by
\texttt{skip}, which indicates the absence of an optional call. Notice also that
the \texttt{||} operator and the \texttt{?} operator work together to combine their
effects in this example, though \texttt{?} can be used for any operation call.

Along the same lines as \texttt{?}, it is possible to add \texttt{*} and
\texttt{+} operators to any call, which indicate that it should be called zero
or more times, and one or more times. The maximum number of times is a tool preset
value that defaults to 5, though it can be changed. So for example:

\small
\begin{lstlisting}
traces
    T1: obj.inc()*;
    T2: obj.dec()+;
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 6 tests
Test 1 = skip
Result = [(), PASSED]
Test 2 = obj.inc()
Result = [1, PASSED]
Test 3 = obj.inc(); obj.inc()
Result = [1, 2, PASSED]
Test 4 = obj.inc(); obj.inc(); obj.inc()
Result = [1, 2, 3, PASSED]
Test 5 = obj.inc(); obj.inc(); obj.inc(); obj.inc()
Result = [1, 2, 3, 4, PASSED]
Test 6 = obj.inc(); obj.inc(); obj.inc(); obj.inc(); obj.inc()
Result = [1, 2, 3, 4, 5, PASSED]
Executed in 0.046 secs. 
All tests passed

> runtrace Tester`T2
Generated 5 tests
Test 1 = obj.dec()
Result = [-1, PASSED]
Test 2 = obj.dec(); obj.dec()
Result = [-1, -2, PASSED]
Test 3 = obj.dec(); obj.dec(); obj.dec()
Result = [-1, -2, -3, PASSED]
Test 4 = obj.dec(); obj.dec(); obj.dec(); obj.dec()
Result = [-1, -2, -3, -4, PASSED]
Test 5 = obj.dec(); obj.dec(); obj.dec(); obj.dec(); obj.dec()
Result = [-1, -2, -3, -4, -5, PASSED]
Executed in 0.042 secs. 
All tests passed
\end{verbatim}
\normalsize

The important difference between these two is that T1 includes an extra
\texttt{skip} case, whereas T2 does not.

Lastly, it is possible to indicate a specific number of repetitions of a call or
a range of repetitions. For example:

\small
\begin{lstlisting}
traces
    T1: obj.inc(){3};
    T2: obj.dec(){2, 4};
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 1 tests
Test 1 = obj.inc(); obj.inc(); obj.inc()
Result = [1, 2, 3, PASSED]
Executed in 0.026 secs. 
All tests passed

> runtrace Tester`T2
Generated 3 tests
Test 1 = obj.dec(); obj.dec()
Result = [-1, -2, PASSED]
Test 2 = obj.dec(); obj.dec(); obj.dec()
Result = [-1, -2, -3, PASSED]
Test 3 = obj.dec(); obj.dec(); obj.dec(); obj.dec()
Result = [-1, -2, -3, -4, PASSED]
Executed in 0.01 secs. 
All tests passed
\end{verbatim}
\normalsize

The T1 trace now produces a single test with precisely three repetitions, while
the T2 trace gives three tests with 2, 3 and 4 repetitions respectively.

If you combine a \texttt{||} operator with a repetition, the result is to repeat
all of the possibilities of the permutation with the given number of repetitions.
For example:

\small
\begin{lstlisting}
traces
    T1: || ( obj.inc(), obj.dec() ) {2};
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 4 tests
Test 1 = obj.inc(); obj.dec(); obj.inc(); obj.dec()
Result = [1, 0, 1, 0, PASSED]
Test 2 = obj.dec(); obj.inc(); obj.inc(); obj.dec()
Result = [-1, 0, 1, 0, PASSED]
Test 3 = obj.inc(); obj.dec(); obj.dec(); obj.inc()
Result = [1, 0, -1, 0, PASSED]
Test 4 = obj.dec(); obj.inc(); obj.dec(); obj.inc()
Result = [-1, 0, -1, 0, PASSED]
Executed in 0.038 secs. 
All tests passed
\end{verbatim}
\normalsize

Here, the \texttt{||} operator produces (inc, dec) and (dec, inc); then the
repetition doubles this, but it doubles every combination of the two rather than
simply repeating each one twice.

\section{Using Variables}

So far, the trace examples have called operations that do not include any
arguments. Arguments can be passed as literals, but traces also provide the
means to define variables that can change value as tests are generated from a
trace.

If we overload the example increment and decrement operations with versions that
take an integer parameter, by which to change the counter, we can write traces
like this:

\small
\begin{lstlisting}
...
    public inc: int ==> int
    inc(i) == ( total := total + i; return total; );

    public dec: int ==> int
    dec(i) == ( total := total - i; return total; )

traces
    T1:
        let a in set {1, ..., 10} be st a mod 2 = 0 in
            obj.inc(a);
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 5 tests
Test 1 = obj.inc(2)
Result = [2, PASSED]
Test 2 = obj.inc(4)
Result = [4, PASSED]
Test 3 = obj.inc(6)
Result = [6, PASSED]
Test 4 = obj.inc(8)
Result = [8, PASSED]
Test 5 = obj.inc(10)
Result = [10, PASSED]
Executed in 0.04 secs. 
All tests passed
\end{verbatim}
\normalsize

In a standard VDM specification, the \texttt{let\ldots be st} expression would
choose an arbitrary element from the set that meets the \texttt{st} clause. But
in a trace context, this looseness is used as a pattern that expands to a test
covering each possible set value that would match. Notice that the tests list
the actual value of the argument passed, rather than the symbolic name, ``a''.

A trace can include multiple \texttt{let} clauses, but if these are nested, then
the trace expands to the \emph{combination} of the variables. For example:

\small
\begin{lstlisting}
traces
    T1:
        let a in set {1, 2, 3} in
            let b in set {4, 5, 6} in
                ( obj.inc(a); obj.dec(b) );
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 9 tests
Test 1 = obj.inc(1); obj.dec(4)
Result = [1, -3, PASSED]
Test 2 = obj.inc(1); obj.dec(5)
Result = [1, -4, PASSED]
Test 3 = obj.inc(1); obj.dec(6)
Result = [1, -5, PASSED]
Test 4 = obj.inc(2); obj.dec(4)
Result = [2, -2, PASSED]
Test 5 = obj.inc(2); obj.dec(5)
Result = [2, -3, PASSED]
Test 6 = obj.inc(2); obj.dec(6)
Result = [2, -4, PASSED]
Test 7 = obj.inc(3); obj.dec(4)
Result = [3, -1, PASSED]
Test 8 = obj.inc(3); obj.dec(5)
Result = [3, -2, PASSED]
Test 9 = obj.inc(3); obj.dec(6)
Result = [3, -3, PASSED]
Executed in 0.066 secs. 
All tests passed
\end{verbatim}
\normalsize

This example produces a test for every combination of ``a'' and ``b'' values,
which is therefore nine tests. The round brackets are needed around the pair of
operation calls because a call binds tightly to the \texttt{let}. Without the
brackets, you get the following scope error, referring to the ``a'' in the
second call to \texttt{obj.dec(a)}:

\small
\begin{lstlisting}
traces
    T1:
        let a in set {6, 7, 10} in
            obj.inc(a); obj.dec(a)
\end{lstlisting}
\scriptsize
\begin{verbatim}
Error 3182: Name 'Tester`a' is not in scope in 'Tester' (example.vpp) at line 28:29
Type checked 2 classes in 0.12 secs. Found 1 type error

\end{verbatim}
\normalsize

Note also that the variables defined are in scope
throughout the clauses below, so the ``a'' variable could be used to define the
set of ``b'' values:

\small
\begin{lstlisting}
traces
    T1:
        let a in set {1, 2, 3} in
            let b in set {a, ..., a + 2} in
                ( obj.inc(a); obj.dec(b) );
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 9 tests
Test 1 = obj.inc(1); obj.dec(1)
Result = [1, 0, PASSED]
Test 2 = obj.inc(1); obj.dec(2)
Result = [1, -1, PASSED]
Test 3 = obj.inc(1); obj.dec(3)
Result = [1, -2, PASSED]
Test 4 = obj.inc(2); obj.dec(2)
Result = [2, 0, PASSED]
Test 5 = obj.inc(2); obj.dec(3)
Result = [2, -1, PASSED]
Test 6 = obj.inc(2); obj.dec(4)
Result = [2, -2, PASSED]
Test 7 = obj.inc(3); obj.dec(3)
Result = [3, 0, PASSED]
Test 8 = obj.inc(3); obj.dec(4)
Result = [3, -1, PASSED]
Test 9 = obj.inc(3); obj.dec(5)
Result = [3, -2, PASSED]
Executed in 0.059 secs. 
All tests passed
\end{verbatim}
\normalsize

If two variables should take values from the same set of values, it is possible
to use a \texttt{multiple bind} in a trace, but not a \texttt{bind list}. For
example:

\small
\begin{lstlisting}
traces
    T1:
        let a, b in set {1, 2, 3} in
            ( obj.inc(a); obj.dec(b) );
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 9 tests
Test 1 = obj.inc(1); obj.dec(1)
Result = [1, 0, PASSED]
Test 2 = obj.inc(2); obj.dec(1)
Result = [2, 1, PASSED]
Test 3 = obj.inc(3); obj.dec(1)
Result = [3, 2, PASSED]
Test 4 = obj.inc(1); obj.dec(2)
Result = [1, -1, PASSED]
Test 5 = obj.inc(2); obj.dec(2)
Result = [2, 0, PASSED]
Test 6 = obj.inc(3); obj.dec(2)
Result = [3, 1, PASSED]
Test 7 = obj.inc(1); obj.dec(3)
Result = [1, -2, PASSED]
Test 8 = obj.inc(2); obj.dec(3)
Result = [2, -1, PASSED]
Test 9 = obj.inc(3); obj.dec(3)
Result = [3, 0, PASSED]
Executed in 0.061 secs. 
All tests passed
\end{verbatim}
\normalsize


As well as defining a variable value from a set, variables can be used to
simplify calculations that would otherwise have to be made in the arguments to
operation calls. These simpler \texttt{let} definitions do not increase the
number of tests generated from the trace, they just introduce new names in the
scope that follows. Multiple variable definitions can be declared in 
one \texttt{let} expression. For example:

\small
\begin{lstlisting}
traces
T1:
    let a in set {1, 2, 3} in
        let b = a + 1, c = a - 1 in
            ( obj.inc(b); obj.dec(c) );
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 3 tests
Test 1 = obj.inc(2); obj.dec(0)
Result = [2, 2, PASSED]
Test 2 = obj.inc(3); obj.dec(1)
Result = [3, 2, PASSED]
Test 3 = obj.inc(4); obj.dec(2)
Result = [4, 2, PASSED]
Executed in 0.054 secs. 
All tests passed
\end{verbatim}
\normalsize

If repetitions are added to a clause within a \texttt{let} body, they bind
tightly to the operation call rather than the entire \texttt{let} clause.
If you want to repeat the entire \texttt{let}, you have to
bracket the whole clause and add a repetition to that. For example:

\small
\begin{lstlisting}
traces
    T1:
        let a in set {1, 2, 3} in
            obj.inc(a){1, 2}
    T2:
        ( let a in set {1, 2, 3} in
            obj.inc(a) ){1, 2}
\end{lstlisting}

\begin{verbatim}
> runtrace Tester`T1
Generated 6 tests
Test 1 = obj.inc(1)
Result = [1, PASSED]
Test 2 = obj.inc(1); obj.inc(1)
Result = [1, 2, PASSED]
Test 3 = obj.inc(2)
Result = [2, PASSED]
Test 4 = obj.inc(2); obj.inc(2)
Result = [2, 4, PASSED]
Test 5 = obj.inc(3)
Result = [3, PASSED]
Test 6 = obj.inc(3); obj.inc(3)
Result = [3, 6, PASSED]
Executed in 0.044 secs. 
All tests passed

> runtrace Tester`T2
Generated 12 tests
Test 1 = obj.inc(1)
Result = [1, PASSED]
Test 2 = obj.inc(2)
Result = [2, PASSED]
Test 3 = obj.inc(3)
Result = [3, PASSED]
Test 4 = obj.inc(1); obj.inc(1)
Result = [1, 2, PASSED]
Test 5 = obj.inc(2); obj.inc(1)
Result = [2, 3, PASSED]
Test 6 = obj.inc(3); obj.inc(1)
Result = [3, 4, PASSED]
Test 7 = obj.inc(1); obj.inc(2)
Result = [1, 3, PASSED]
Test 8 = obj.inc(2); obj.inc(2)
Result = [2, 4, PASSED]
Test 9 = obj.inc(3); obj.inc(2)
Result = [3, 5, PASSED]
Test 10 = obj.inc(1); obj.inc(3)
Result = [1, 4, PASSED]
Test 11 = obj.inc(2); obj.inc(3)
Result = [2, 5, PASSED]
Test 12 = obj.inc(3); obj.inc(3)
Result = [3, 6, PASSED]
Executed in 0.03 secs. 
All tests passed
\end{verbatim}
\normalsize

The difference may seem subtle, but the effect is significant. T1 behaves like a
simple ``\{1, 2\}'' repetition for each of the \texttt{let} values, whereas T2
produces either one or two cases from the \emph{entire set} created by the \texttt{let}
clause.

Although the example above uses a \texttt{let <set bind>} expression, it is also
possible to use a \texttt{let <seq bind>} or \texttt{let <type bind>}. In a
trace context, the ordering that a sequence bind carries does not affect the
generation of tests; if the example had \texttt{let a in seq [1,2,3]}, the
same tests would be generated, and since tests are indepedent their order is not
meaningful. So sequence binds are not particularly useful in traces. However
type binds (of finite types) are a shorthand for ``all values of this type'',
which can be useful in some circumstances. This is covered later in Chapter
\ref{chap:patterns}.

\section{Tests with Errors}

The examples so far have only includes tests that PASSED. This means that they
completed the sequence of operation calls without violating any preconditions,
postconditions, state invariants, type invariants, recursive measures or dynamic
type checks.

If a sequence of operations causes a postcondition failure, then it
is certain that there is a problem with the specification â€“ it should not be
possible to provoke a post condition failure with a set of legal calls (ie. ones
which pass the preconditions and type invariants). On the other hand, if a 
sequence of operations violates a precondition, or a type or class invariant, 
then it is \emph{possible} that the specification has a problem, but it is also 
possible that the test itself is at fault (passing illegal values).

The combinatorial testing environment indicates the exit status of the test  in
the verdict returned in the last item of the results (all PASSED above). So if 
pre/post/invariant conditions are violated during a test, this may be set to 
FAILED or INDETERMINATE\footnote{The tools sometimes call this INCONCLUSIVE}. If
a test fails, then any subsequent test which starts \emph{with the same
sequence of calls} as the failed sequence will also fail. These tests are
filtered out of the remaining test sequence automatically, and not executed.

For example, if we introduce a pre- and postcondition into our example, we see
this behaviour:

\small
\begin{lstlisting}
...
    public inc: int ==> int
    inc(i) == ( total := total + i; return total; )
    pre i < 10
    post total < 20;

traces
    T1:
        let a in set {6, 7, 10} in
            obj.inc(a){1, 5}
\end{lstlisting}

\scriptsize
\begin{verbatim}
> runtrace Tester`T1
Generated 15 tests
Test 1 = obj.inc(6)
Result = [6, PASSED]
Test 2 = obj.inc(6); obj.inc(6)
Result = [6, 12, PASSED]
Test 3 = obj.inc(6); obj.inc(6); obj.inc(6)
Result = [6, 12, 18, PASSED]
Test 4 = obj.inc(6); obj.inc(6); obj.inc(6); obj.inc(6)
Result = [6, 12, 18, Error 4072: Postcondition failure: post_inc in 'Counter' at line 15:16, FAILED]
Test 5 = obj.inc(6); obj.inc(6); obj.inc(6); obj.inc(6); obj.inc(6)
Test 5 FILTERED by test 4
Test 6 = obj.inc(7)
Result = [7, PASSED]
Test 7 = obj.inc(7); obj.inc(7)
Result = [7, 14, PASSED]
Test 8 = obj.inc(7); obj.inc(7); obj.inc(7)
Result = [7, 14, Error 4072: Postcondition failure: post_inc in 'Counter' at line 15:16, FAILED]
Test 9 = obj.inc(7); obj.inc(7); obj.inc(7); obj.inc(7)
Test 9 FILTERED by test 8
Test 10 = obj.inc(7); obj.inc(7); obj.inc(7); obj.inc(7); obj.inc(7)
Test 10 FILTERED by test 8
Test 11 = obj.inc(10)
Result = [Error 4071: Precondition failure: pre_inc in 'Counter' at line 14:11, INCONCLUSIVE]
Test 12 = obj.inc(10); obj.inc(10)
Test 12 FILTERED by test 11
Test 13 = obj.inc(10); obj.inc(10); obj.inc(10)
Test 13 FILTERED by test 11
Test 14 = obj.inc(10); obj.inc(10); obj.inc(10); obj.inc(10)
Test 14 FILTERED by test 11
Test 15 = obj.inc(10); obj.inc(10); obj.inc(10); obj.inc(10); obj.inc(10)
Test 15 FILTERED by test 11
Executed in 0.075 secs. 
Some tests failed or indeterminate
\end{verbatim}
\normalsize

The \texttt{inc} operation now has a precondition that the argument must be
less than 10 and a postcondition that the resulting total must be less than 20.
The trace makes 1 to 5 calls to the \texttt{inc} operation with arguments 6, 7
and 10, respectively.

The first three tests are fine, but Test 4 fails because the fourth call to
\texttt{inc(6)} pushes the total over the limit. This is therefore a
postcondition FAILED test, and the error message is listed along with the
results of the earlier operation calls. Test 5 then tries to do the same, but
adds a further call. This must fail in the same place as Test 4, because Test 4
is the ``stem'' of Test 5. Therefore this test is ``FILTERED by Test 4''.
Similarly, Test 8 fails and Tests 9 and 10 are filtered by this failure.

Test 11 fails on the first call to \texttt{inc(10)}, since the argument must be
less than 10. This produces an INDETERMINATE error because we are not
sure whether this is a problem with the trace or the specification being tested.
Lastly, Tests 12 to 15 are filtered by Test 11, since they would behave the same
way.

At the end of the run, the \texttt{runtrace} command indicates that some tests
failed or were indeterminate, just to remind you.

\section{How Does Trace Expansion Work?}

The sections above have given an overview of all the trace operators, and there
are some examples of combinations of operators. But to see how traces are
expanded in general, we need to look at traces from a different point of view.
The syntax of traces is deliberately made similar to the syntax of VDM-SL, but
to understand how operators combine to produce multiple tests, it helps to look
at operators as though they followed a separate ``expansion'' grammar. In the
description that follows, a \texttt{set} is a set of tests:

\begin{itemize}
\item \texttt{set = object.opname(args)}. The simplest form of a trace is a set
that comprises a single call to an operation or function with arguments. The
arguments can be symbolic, and bound to various values by the \texttt{let}
operator described below.
\item \texttt{set = set1; set2; ...; setn}. A set of tests may be formed from
an ordered sequence of sets. This expands to all possible selections of one test
from each of the sets. In its simplest form, this could be a sequence of
operation calls which therefore just expands to one test. But a combination of
sets of tests results in a set of the product of the sizes of those sets.
\item \texttt{set = set1 ?}. A set of tests may be formed from another set with
a \texttt{?} operator. This produces the same set, but includes a ``skip'' step.
\item \texttt{set = set1 \{n[, n]\}}. A set of tests may be formed from another
set with a \texttt{\{n\}} or \texttt{\{n1, n2\}} operator. This produces a set
with every member of the original set repeated \texttt{n} times, or between
\texttt{n1} and \texttt{n2} times (inclusive).
\item \texttt{set = set1 *|+}. A set of tests may be formed from another set
with a \texttt{*} or \texttt{+} operator. This produces another set with every member
of the original set repeated from 0 to N times (with \texttt{*}) or 1 to N times
(with \texttt{+}). The value of N is tool dependent, but defaults to 5.
\item \texttt{set = set1 | set2 | ... | setn}. A set of tests may be formed by
combining a number of other test sets with a \texttt{|} operator. This produces
a set with the union of the other sets.
\item \texttt{set = || (set1, set2, ..., setn)}. A set may be formed from the
permutations of a number of other sets. This produces a set with each
permutation of each selection of one test from each set.
\item \texttt{set = let <multiple bind> [be st <cond>] in set1}. A set of
tests may be formed from a \texttt{multiple bind}, which expands to the
substitution of all the possible the bound values in the original set.
\item \texttt{set = let <name> = <exp> [, <name2> = <exp2>, ...] in set1}. A set
of tests may be evaluated in a scope that defines name/value pairs. This does
not increase the number of tests in the set, but just binds free variables.
\end{itemize}

For example, if (for brevity) we say that a test with a single call to
\texttt{obj.opA()} is written as ``[A]'', and similarly ``[B]'' and ``[C]'' 
for other operation calls, and ``[-]'' for a skip, then we can say the 
following trace operators produce these sets of tests:

\small
\begin{verbatim}
A? = { [A], [-] }
A;B = { [AB] }
A;B? = { [AB], [A] }
A* = { [-], [A], [AA], [AAA], [AAAA], [AAAAA], ... }
A+ = { [A], [AA], [AAA], [AAAA], [AAAAA], ... }
A{3} = { [AAA] }
A{1,3} = { [A], [AA], [AAA] }
A | B = { [A], [B] }
A | B? = { [A], [B], [-] )
|| (A, B, C) = { [ABC], [ACB], [BAC], [BCA], [CAB], [CBA] }
|| (A, (B;C)) = { [ABC], [BCA] }
|| (A, B+) = { [AB], [BA], [ABB], [BBA], [ABBB], [BBBA], ... }
let a in set {1,2,3} in A(a) = { [A(1)], [A(2)], [A(3)] }
let b : bool * bool in B(b) = {
    [B(mk_(true, true))], [B(mk_(true, false))],
    [B(mk_(false, true))], [B(mk_(false, false))]
}
let z = 1 in B(z) = { [B(1)] }
\end{verbatim}
\normalsize

Note that the repeat limits in a trace (like \{1,3\}) must be numeric literals.
But values in a multiple bind set or sequence can be variables, either bound
earlier in the trace or other fields within scope of the trace inside the object
or module where it is defined. Similarly, the values in the right hand side of
let definitions can be variables within the trace or the object/module scope.

\section{Language Considerations}

Combinatorial tests are available for both VDM-SL and VDM++/VDM-RT. The process 
of trace expansion and execution is very similar in all cases, but there are
some differences that are described below.

\subsection{Traces in VDM-SL}

Traces are added in a ``traces'' section within a VDM-SL specification. This can
either be within one or more modules or within a flat specification. The name of
the traces in a module are implicitly exported, so they are referred to as
\texttt{<modulename>`<tracename>}. You can omit the module name if it is the
default module.

The VDM-SL specification that is equivalent to the example used above is like
this:

\small
\begin{lstlisting}
module Counter
exports all
definitions

state S of
    total:int
init s == s = mk_S(0)
end

operations
    inc: int ==> int
    inc(i) == ( total := total + i; return total; );

    dec: int ==> int
    dec(i) == ( total := total - i; return total; )
end Counter

module Tester
imports from Counter all
definitions

traces
    T1: Counter`inc(1)*;

end Tester
\end{lstlisting}
\normalsize

And in the VDM-SL command line, that would be executed as follows. Note that
Tester is not the default module, so the trace name is qualified:

\scriptsize
\begin{verbatim}
> modules
Counter (default)
Tester
> runtrace Tester`T1
Generated 6 tests in 0.002 secs. 
Test 1 = skip
Result = [(), PASSED]
Test 2 = inc(1)
Result = [1, PASSED]
Test 3 = inc(1); inc(1)
Result = [1, 2, PASSED]
Test 4 = inc(1); inc(1); inc(1)
Result = [1, 2, 3, PASSED]
Test 5 = inc(1); inc(1); inc(1); inc(1)
Result = [1, 2, 3, 4, PASSED]
Test 6 = inc(1); inc(1); inc(1); inc(1); inc(1)
Result = [1, 2, 3, 4, 5, PASSED]
Executed in 0.019 secs. 
All tests passed
>
\end{verbatim}
\normalsize

This trace is very similar to the VDM++ example. The Counter module has a
single state that is equivalent to the VDM++ ``total'' instance variable. Note
that this is reset to zero automatically before each test is executed. This is
because each test re-initializes the specification, and the module
state has an ``init'' clause that sets the total to zero.

Notice also that the operation calls are not applied to a Counter object, unlike
VDM++.

\subsection{Traces in VDM++ and VDM-RT}

Traces are added in a ``traces'' section within a VDM++ or VDM-RT
specification, inside one or more classes. In effect, the name of the trace is
a public static symbol, so it is referred to as
\texttt{<classname>`<tracename>}, as we have seen in the examples above. You
can omit the class name if that is the default class.

Although a VDM++ trace is effectively a static scope, and can call static
operations directly (similar to a VDM-SL trace), every test execution occurs in
a \emph{new instance} of the containing class - in our examples, in a new Tester
instance. This means that objects created within the Tester's construction will
be freshly initialized and ready for use in each test run. In the example, the
Counter object \texttt{obj} is created for each test, because the instance
variable is initialized at construction.

\subsection{Expansion and Execution Considerations}

The process of running a combinatorial test has two phases: expanding the trace
to a number of test definitions; and subsequently executing those definitions.
The trace expansion typically does not take very long, since it is only
constructing a tree of iterators that are capable of generating the tests one
after another. The subsequent execution of those tests can obviously take a long
time, depending on how many there are.

We have seen (above) how the specification is initialized before test execution,
and the state of the module or class is available to the trace, but care must be
taken if operations or functions within the environment are used as part of a
trace. This is because some expressions are evaluated during trace expansion and
some during test execution. For example:

\small
\begin{lstlisting}
...
functions
    private static range: int * int -> set of int
    range(a, b) == {a, ..., b};

values
    Z = 100;

traces
    T1: let x in set range(3, 5) in
        let y in set range(x, x+2) in
            obj.inc(Z + x + y);
\end{lstlisting}
\normalsize

In this case, the \texttt{range} function is used to create a set for the
multi-binds, and this is executed during \emph{expansion}, once for ``x'' and three
times for ``y''. Similarly, the right hand side of simple let definitions are
executed during trace expansion. But the addition of \texttt{Z + x + y} in the
argument to \texttt{inc} is called during \emph{execution} (once for each test).

Trace generation starts inside a fresh object instance of the class (or
initialized module) that contains the trace. So if operations are called during
trace \emph{expansion}, these can modify state and so affect subsequent
operation calls elsewhere in the expansion. This can become very confusing, and
it is not a recommended trace design strategy! On the other hand, calling
functions as part of the trace expansion can make traces easier to understand
and can provide the means to build complex sets that would be difficult to
construct directly within the trace statements.

When a test is listed in the trace output, the arguments that are passed to
operation calls are shown as literals, if possible. As seen in the examples
here, a call to \texttt{obj.inc(1)} is shown, rather than \texttt{obj.inc(a)}. This is
possible whenever arguments can be easily evaluated. For example the \texttt{Z
+ x + y} case above would produce \texttt{Test 1 = obj.inc(106)}, which is 100 +
3 + 3. But if the argument is a more complex expression involving operation
applies or new object creation, these cannot be evaluated and so the argument
expression is listed ``as is''. For example, if the trace above is changed to
call \texttt{obj.inc(max(x, y))}, the test would be listed with ``x'' and ``y''
rather than their current values:

\small
\begin{verbatim}
> runtrace Tester`T1
Generated 9 tests in 0.006 secs. 
Test 1 = inc(max(x, y))
Result = [3, PASSED]
Test 2 = inc(max(x, y))
Result = [3, PASSED]
...
\end{verbatim}
\normalsize

The operation calls that each expanded test contains do not have to be
operations on the ``main'' specification, but can rather be testing operations
that maintain their own state and then call on to main operations. This allows
more complex trace scenarios to be created without encoding the detail in the
trace statements. More examples of this strategy are given in the next chapter.

\chapter{Combinatorial Testing Patterns}
\label{chap:patterns}

\chapter{Combinatorial Testing Examples}
\label{chap:examples}

\appendix
\chapter{Combinatorial Testing Syntax}
\label{chap:CTsyntax}

\Ruledef{traces definitions}{\Lop{traces},
   \OptPt{\Ruleref{named trace}, \SeqPt{\Lit{;}, \Ruleref{named trace}}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term},
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition}, \SeqPt{\Lit{|}, \Ruleref{trace definition}}
}

\Rule{trace definition}{
  \Ruleref{trace binding definition} \dsep
  \Ruleref{trace repeat definition}
}

\Ruledef{trace binding definition}{
  \Ruleref{trace let def binding} \dsep
  \Ruleref{trace let best binding}
}

\Ruledef{trace let def binding}{
  \Lop{let}, \Ruleref{local definition},
  \SeqPt{ \Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace let best binding}{
  \Lop{let}, \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace repeat definition}{
  \Ruleref{trace core definition},
  \OptPt{\Ruleref{trace repeat pattern}}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \OptPt{\Lit{,}, \Ruleref{numeric literal}, \Lit{\}}}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace concurrent expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{call statement}
}

\Rule{trace concurrent expression}{
  \Lit{||}, \Lit{(}, \Ruleref{trace definition}, \lfeed
  \Lit{,}, \Ruleref{trace definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{trace definition}}, \Lit{)}
}

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\chapter{Overture Screenshots}
\label{chap:OvertureShots}


\bibliographystyle{newalpha}

\bibliography{../bib/dan}

\end{document}


